/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _Vue = __webpack_require__(1);

	var _Vue2 = _interopRequireDefault(_Vue);

	var _vueRouter = __webpack_require__(2);

	var _vueRouter2 = _interopRequireDefault(_vueRouter);

	var _App = __webpack_require__(4);

	var _App2 = _interopRequireDefault(_App);

	var _index = __webpack_require__(22);

	var _index2 = _interopRequireDefault(_index);

	var _index3 = __webpack_require__(34);

	var _index4 = _interopRequireDefault(_index3);

	var _index5 = __webpack_require__(39);

	var _index6 = _interopRequireDefault(_index5);

	var _index7 = __webpack_require__(45);

	var _index8 = _interopRequireDefault(_index7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_Vue2.default.use(_vueRouter2.default);

	_Vue2.default.config.debug = true; //开启错误提示

	window.onload = function () {

		var routes = [{
			path: '/',
			component: _index2.default
		}, {
			path: '/home',
			component: _index2.default
		}, {
			path: '/history',
			component: _index4.default
		}, {
			path: '/risk',
			component: _index8.default
		}, {
			path: '/success',
			component: _index6.default
		}];
		var router = new _vueRouter2.default({
			routes: routes // short for routes: routes
		});
		var app = new _Vue2.default({
			router: router,
			render: function render(h) {
				return h(_App2.default);
			},
			data: {
				user: {}
			}
		}).$mount('#app');
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * Vue.js v2.1.8
	 * (c) 2014-2016 Evan You
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Vue = factory());
	}(this, (function () { 'use strict';

	/*  */

	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function _toString (val) {
	  return val == null
	    ? ''
	    : typeof val === 'object'
	      ? JSON.stringify(val, null, 2)
	      : String(val)
	}

	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber (val) {
	  var n = parseFloat(val, 10);
	  return (n || n === 0) ? n : val
	}

	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap (
	  str,
	  expectsLowerCase
	) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase
	    ? function (val) { return map[val.toLowerCase()]; }
	    : function (val) { return map[val]; }
	}

	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);

	/**
	 * Remove an item from an array
	 */
	function remove$1 (arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1)
	    }
	  }
	}

	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn (obj, key) {
	  return hasOwnProperty.call(obj, key)
	}

	/**
	 * Check if value is primitive
	 */
	function isPrimitive (value) {
	  return typeof value === 'string' || typeof value === 'number'
	}

	/**
	 * Create a cached version of a pure function.
	 */
	function cached (fn) {
	  var cache = Object.create(null);
	  return (function cachedFn (str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str))
	  })
	}

	/**
	 * Camelize a hyphen-delmited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
	});

	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1)
	});

	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str
	    .replace(hyphenateRE, '$1-$2')
	    .replace(hyphenateRE, '$1-$2')
	    .toLowerCase()
	});

	/**
	 * Simple bind, faster than native
	 */
	function bind$1 (fn, ctx) {
	  function boundFn (a) {
	    var l = arguments.length;
	    return l
	      ? l > 1
	        ? fn.apply(ctx, arguments)
	        : fn.call(ctx, a)
	      : fn.call(ctx)
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn
	}

	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray (list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret
	}

	/**
	 * Mix properties into target object.
	 */
	function extend (to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to
	}

	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject (obj) {
	  return obj !== null && typeof obj === 'object'
	}

	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	function isPlainObject (obj) {
	  return toString.call(obj) === OBJECT_STRING
	}

	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject (arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res
	}

	/**
	 * Perform no operation.
	 */
	function noop () {}

	/**
	 * Always return false.
	 */
	var no = function () { return false; };

	/**
	 * Return same value
	 */
	var identity = function (_) { return _; };

	/**
	 * Generate a static keys string from compiler modules.
	 */
	function genStaticKeys (modules) {
	  return modules.reduce(function (keys, m) {
	    return keys.concat(m.staticKeys || [])
	  }, []).join(',')
	}

	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual (a, b) {
	  var isObjectA = isObject(a);
	  var isObjectB = isObject(b);
	  if (isObjectA && isObjectB) {
	    return JSON.stringify(a) === JSON.stringify(b)
	  } else if (!isObjectA && !isObjectB) {
	    return String(a) === String(b)
	  } else {
	    return false
	  }
	}

	function looseIndexOf (arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) { return i }
	  }
	  return -1
	}

	/*  */

	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),

	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,

	  /**
	   * Whether to enable devtools
	   */
	  devtools: "development" !== 'production',

	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,

	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: [],

	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),

	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,

	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,

	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,

	  /**
	   * Parse the real tag name for the specific platform.
	   */
	  parsePlatformTagName: identity,

	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,

	  /**
	   * List of asset types that a component can own.
	   */
	  _assetTypes: [
	    'component',
	    'directive',
	    'filter'
	  ],

	  /**
	   * List of lifecycle hooks.
	   */
	  _lifecycleHooks: [
	    'beforeCreate',
	    'created',
	    'beforeMount',
	    'mounted',
	    'beforeUpdate',
	    'updated',
	    'beforeDestroy',
	    'destroyed',
	    'activated',
	    'deactivated'
	  ],

	  /**
	   * Max circular updates allowed in a scheduler flush cycle.
	   */
	  _maxUpdateCount: 100
	};

	/*  */

	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved (str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F
	}

	/**
	 * Define a property.
	 */
	function def (obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}

	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath (path) {
	  if (bailRE.test(path)) {
	    return
	  } else {
	    var segments = path.split('.');
	    return function (obj) {
	      for (var i = 0; i < segments.length; i++) {
	        if (!obj) { return }
	        obj = obj[segments[i]];
	      }
	      return obj
	    }
	  }
	}

	/*  */
	/* globals MutationObserver */

	// can we use __proto__?
	var hasProto = '__proto__' in {};

	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function () {
	  if (_isServer === undefined) {
	    /* istanbul ignore if */
	    if (!inBrowser && typeof global !== 'undefined') {
	      // detect presence of vue-server-renderer and avoid
	      // Webpack shimming the process
	      _isServer = global['process'].env.VUE_ENV === 'server';
	    } else {
	      _isServer = false;
	    }
	  }
	  return _isServer
	};

	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	/* istanbul ignore next */
	function isNative (Ctor) {
	  return /native code/.test(Ctor.toString())
	}

	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;

	  function nextTickHandler () {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }

	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    var logError = function (err) { console.error(err); };
	    timerFunc = function () {
	      p.then(nextTickHandler).catch(logError);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) { setTimeout(noop); }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (
	    isNative(MutationObserver) ||
	    // PhantomJS and iOS 7.x
	    MutationObserver.toString() === '[object MutationObserverConstructor]'
	  )) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function () {
	      setTimeout(nextTickHandler, 0);
	    };
	  }

	  return function queueNextTick (cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	      if (cb) { cb.call(ctx); }
	      if (_resolve) { _resolve(ctx); }
	    });
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	    if (!cb && typeof Promise !== 'undefined') {
	      return new Promise(function (resolve) {
	        _resolve = resolve;
	      })
	    }
	  }
	})();

	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = (function () {
	    function Set () {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has (key) {
	      return this.set[key] === true
	    };
	    Set.prototype.add = function add (key) {
	      this.set[key] = true;
	    };
	    Set.prototype.clear = function clear () {
	      this.set = Object.create(null);
	    };

	    return Set;
	  }());
	}

	var warn = noop;
	var formatComponentName;

	{
	  var hasConsole = typeof console !== 'undefined';

	  warn = function (msg, vm) {
	    if (hasConsole && (!config.silent)) {
	      console.error("[Vue warn]: " + msg + " " + (
	        vm ? formatLocation(formatComponentName(vm)) : ''
	      ));
	    }
	  };

	  formatComponentName = function (vm) {
	    if (vm.$root === vm) {
	      return 'root instance'
	    }
	    var name = vm._isVue
	      ? vm.$options.name || vm.$options._componentTag
	      : vm.name;
	    return (
	      (name ? ("component <" + name + ">") : "anonymous component") +
	      (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
	    )
	  };

	  var formatLocation = function (str) {
	    if (str === 'anonymous component') {
	      str += " - use the \"name\" option for better debugging messages.";
	    }
	    return ("\n(found in " + str + ")")
	  };
	}

	/*  */


	var uid$1 = 0;

	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep () {
	  this.id = uid$1++;
	  this.subs = [];
	};

	Dep.prototype.addSub = function addSub (sub) {
	  this.subs.push(sub);
	};

	Dep.prototype.removeSub = function removeSub (sub) {
	  remove$1(this.subs, sub);
	};

	Dep.prototype.depend = function depend () {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};

	Dep.prototype.notify = function notify () {
	  // stablize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};

	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];

	function pushTarget (_target) {
	  if (Dep.target) { targetStack.push(Dep.target); }
	  Dep.target = _target;
	}

	function popTarget () {
	  Dep.target = targetStack.pop();
	}

	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */

	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);[
	  'push',
	  'pop',
	  'shift',
	  'unshift',
	  'splice',
	  'sort',
	  'reverse'
	]
	.forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator () {
	    var arguments$1 = arguments;

	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments$1[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break
	      case 'unshift':
	        inserted = args;
	        break
	      case 'splice':
	        inserted = args.slice(2);
	        break
	    }
	    if (inserted) { ob.observeArray(inserted); }
	    // notify change
	    ob.dep.notify();
	    return result
	  });
	});

	/*  */

	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true,
	  isSettingProps: false
	};

	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer (value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto
	      ? protoAugment
	      : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};

	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};

	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};

	// helpers

	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment (target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}

	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 */
	/* istanbul ignore next */
	function copyAugment (target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}

	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe (value, asRootData) {
	  if (!isObject(value)) {
	    return
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (
	    observerState.shouldConvert &&
	    !isServerRendering() &&
	    (Array.isArray(value) || isPlainObject(value)) &&
	    Object.isExtensible(value) &&
	    !value._isVue
	  ) {
	    ob = new Observer(value);
	  }
	  if (asRootData && ob) {
	    ob.vmCount++;
	  }
	  return ob
	}

	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1 (
	  obj,
	  key,
	  val,
	  customSetter
	) {
	  var dep = new Dep();

	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return
	  }

	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;

	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter () {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value
	    },
	    set: function reactiveSetter (newVal) {
	      var value = getter ? getter.call(obj) : val;
	      /* eslint-disable no-self-compare */
	      if (newVal === value || (newVal !== newVal && value !== value)) {
	        return
	      }
	      /* eslint-enable no-self-compare */
	      if ("development" !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}

	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set$1 (obj, key, val) {
	  if (Array.isArray(obj)) {
	    obj.length = Math.max(obj.length, key);
	    obj.splice(key, 1, val);
	    return val
	  }
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return
	  }
	  var ob = obj.__ob__;
	  if (obj._isVue || (ob && ob.vmCount)) {
	    "development" !== 'production' && warn(
	      'Avoid adding reactive properties to a Vue instance or its root $data ' +
	      'at runtime - declare it upfront in the data option.'
	    );
	    return
	  }
	  if (!ob) {
	    obj[key] = val;
	    return
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val
	}

	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del (obj, key) {
	  var ob = obj.__ob__;
	  if (obj._isVue || (ob && ob.vmCount)) {
	    "development" !== 'production' && warn(
	      'Avoid deleting properties on a Vue instance or its root $data ' +
	      '- just set it to null.'
	    );
	    return
	  }
	  if (!hasOwn(obj, key)) {
	    return
	  }
	  delete obj[key];
	  if (!ob) {
	    return
	  }
	  ob.dep.notify();
	}

	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray (value) {
	  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}

	/*  */

	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;

	/**
	 * Options with restrictions
	 */
	{
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn(
	        "option \"" + key + "\" can only be used during instance " +
	        'creation with the `new` keyword.'
	      );
	    }
	    return defaultStrat(parent, child)
	  };
	}

	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData (to, from) {
	  if (!from) { return to }
	  var key, toVal, fromVal;
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    key = keys[i];
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set$1(to, key, fromVal);
	    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to
	}

	/**
	 * Data
	 */
	strats.data = function (
	  parentVal,
	  childVal,
	  vm
	) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal
	    }
	    if (typeof childVal !== 'function') {
	      "development" !== 'production' && warn(
	        'The "data" option should be a function ' +
	        'that returns a per-instance value in component ' +
	        'definitions.',
	        vm
	      );
	      return parentVal
	    }
	    if (!parentVal) {
	      return childVal
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn () {
	      return mergeData(
	        childVal.call(this),
	        parentVal.call(this)
	      )
	    }
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn () {
	      // instance merge
	      var instanceData = typeof childVal === 'function'
	        ? childVal.call(vm)
	        : childVal;
	      var defaultData = typeof parentVal === 'function'
	        ? parentVal.call(vm)
	        : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData)
	      } else {
	        return defaultData
	      }
	    }
	  }
	};

	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	function mergeHook (
	  parentVal,
	  childVal
	) {
	  return childVal
	    ? parentVal
	      ? parentVal.concat(childVal)
	      : Array.isArray(childVal)
	        ? childVal
	        : [childVal]
	    : parentVal
	}

	config._lifecycleHooks.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});

	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets (parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal
	    ? extend(res, childVal)
	    : res
	}

	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});

	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  /* istanbul ignore if */
	  if (!childVal) { return parentVal }
	  if (!parentVal) { return childVal }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent
	      ? parent.concat(child)
	      : [child];
	  }
	  return ret
	};

	/**
	 * Other object hashes.
	 */
	strats.props =
	strats.methods =
	strats.computed = function (parentVal, childVal) {
	  if (!childVal) { return parentVal }
	  if (!parentVal) { return childVal }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret
	};

	/**
	 * Default strategy.
	 */
	var defaultStrat = function (parentVal, childVal) {
	  return childVal === undefined
	    ? parentVal
	    : childVal
	};

	/**
	 * Validate component names
	 */
	function checkComponents (options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn(
	        'Do not use built-in or reserved HTML elements as component ' +
	        'id: ' + key
	      );
	    }
	  }
	}

	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps (options) {
	  var props = options.props;
	  if (!props) { return }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val)
	        ? val
	        : { type: val };
	    }
	  }
	  options.props = res;
	}

	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives (options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}

	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions (
	  parent,
	  child,
	  vm
	) {
	  {
	    checkComponents(child);
	  }
	  normalizeProps(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = typeof extendsFrom === 'function'
	      ? mergeOptions(parent, extendsFrom.options, vm)
	      : mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      if (mixin.prototype instanceof Vue$3) {
	        mixin = mixin.options;
	      }
	      parent = mergeOptions(parent, mixin, vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField (key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options
	}

	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset (
	  options,
	  type,
	  id,
	  warnMissing
	) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return
	  }
	  var assets = options[type];
	  // check local registration variations first
	  if (hasOwn(assets, id)) { return assets[id] }
	  var camelizedId = camelize(id);
	  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
	  var PascalCaseId = capitalize(camelizedId);
	  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
	  // fallback to prototype chain
	  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	  if ("development" !== 'production' && warnMissing && !res) {
	    warn(
	      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
	      options
	    );
	  }
	  return res
	}

	/*  */

	function validateProp (
	  key,
	  propOptions,
	  propsData,
	  vm
	) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isType(Boolean, prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value
	}

	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue (vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    "development" !== 'production' && warn(
	      'Invalid default value for prop "' + key + '": ' +
	      'Props with type Object/Array must use a factory function ' +
	      'to return the default value.',
	      vm
	    );
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData &&
	    vm.$options.propsData[key] === undefined &&
	    vm[key] !== undefined) {
	    return vm[key]
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && prop.type !== Function
	    ? def.call(vm)
	    : def
	}

	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp (
	  prop,
	  name,
	  value,
	  vm,
	  absent
	) {
	  if (prop.required && absent) {
	    warn(
	      'Missing required prop: "' + name + '"',
	      vm
	    );
	    return
	  }
	  if (value == null && !prop.required) {
	    return
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType || '');
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn(
	      'Invalid prop: type check failed for prop "' + name + '".' +
	      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
	      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
	      vm
	    );
	    return
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn(
	        'Invalid prop: custom validator check failed for prop "' + name + '".',
	        vm
	      );
	    }
	  }
	}

	/**
	 * Assert the type of a value
	 */
	function assertType (value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (expectedType === 'String') {
	    valid = typeof value === (expectedType = 'string');
	  } else if (expectedType === 'Number') {
	    valid = typeof value === (expectedType = 'number');
	  } else if (expectedType === 'Boolean') {
	    valid = typeof value === (expectedType = 'boolean');
	  } else if (expectedType === 'Function') {
	    valid = typeof value === (expectedType = 'function');
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  }
	}

	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType (fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match && match[1]
	}

	function isType (type, fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === getType(type)
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === getType(type)) {
	      return true
	    }
	  }
	  /* istanbul ignore next */
	  return false
	}



	var util = Object.freeze({
		defineReactive: defineReactive$$1,
		_toString: _toString,
		toNumber: toNumber,
		makeMap: makeMap,
		isBuiltInTag: isBuiltInTag,
		remove: remove$1,
		hasOwn: hasOwn,
		isPrimitive: isPrimitive,
		cached: cached,
		camelize: camelize,
		capitalize: capitalize,
		hyphenate: hyphenate,
		bind: bind$1,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		toObject: toObject,
		noop: noop,
		no: no,
		identity: identity,
		genStaticKeys: genStaticKeys,
		looseEqual: looseEqual,
		looseIndexOf: looseIndexOf,
		isReserved: isReserved,
		def: def,
		parsePath: parsePath,
		hasProto: hasProto,
		inBrowser: inBrowser,
		UA: UA,
		isIE: isIE,
		isIE9: isIE9,
		isEdge: isEdge,
		isAndroid: isAndroid,
		isIOS: isIOS,
		isServerRendering: isServerRendering,
		devtools: devtools,
		nextTick: nextTick,
		get _Set () { return _Set; },
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		get warn () { return warn; },
		get formatComponentName () { return formatComponentName; },
		validateProp: validateProp
	});

	/* not type checking this file because flow doesn't play well with Proxy */

	var initProxy;

	{
	  var allowedGlobals = makeMap(
	    'Infinity,undefined,NaN,isFinite,isNaN,' +
	    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
	    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
	    'require' // for Webpack/Browserify
	  );

	  var warnNonPresent = function (target, key) {
	    warn(
	      "Property or method \"" + key + "\" is not defined on the instance but " +
	      "referenced during render. Make sure to declare reactive data " +
	      "properties in the data option.",
	      target
	    );
	  };

	  var hasProxy =
	    typeof Proxy !== 'undefined' &&
	    Proxy.toString().match(/native code/);

	  if (hasProxy) {
	    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
	    config.keyCodes = new Proxy(config.keyCodes, {
	      set: function set (target, key, value) {
	        if (isBuiltInModifier(key)) {
	          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
	          return false
	        } else {
	          target[key] = value;
	          return true
	        }
	      }
	    });
	  }

	  var hasHandler = {
	    has: function has (target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warnNonPresent(target, key);
	      }
	      return has || !isAllowed
	    }
	  };

	  var getHandler = {
	    get: function get (target, key) {
	      if (typeof key === 'string' && !(key in target)) {
	        warnNonPresent(target, key);
	      }
	      return target[key]
	    }
	  };

	  initProxy = function initProxy (vm) {
	    if (hasProxy) {
	      // determine which proxy handler to use
	      var options = vm.$options;
	      var handlers = options.render && options.render._withStripped
	        ? getHandler
	        : hasHandler;
	      vm._renderProxy = new Proxy(vm, handlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}

	/*  */


	var queue = [];
	var has$1 = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;

	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState () {
	  queue.length = 0;
	  has$1 = {};
	  {
	    circular = {};
	  }
	  waiting = flushing = false;
	}

	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue () {
	  flushing = true;

	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) { return a.id - b.id; });

	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    var watcher = queue[index];
	    var id = watcher.id;
	    has$1[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if ("development" !== 'production' && has$1[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn(
	          'You may have an infinite update loop ' + (
	            watcher.user
	              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
	              : "in a component render function."
	          ),
	          watcher.vm
	        );
	        break
	      }
	    }
	  }

	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }

	  resetSchedulerState();
	}

	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher (watcher) {
	  var id = watcher.id;
	  if (has$1[id] == null) {
	    has$1[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i >= 0 && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(Math.max(i, index) + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}

	/*  */

	var uid$2 = 0;

	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher (
	  vm,
	  expOrFn,
	  cb,
	  options
	) {
	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  if (options) {
	    this.deep = !!options.deep;
	    this.user = !!options.user;
	    this.lazy = !!options.lazy;
	    this.sync = !!options.sync;
	  } else {
	    this.deep = this.user = this.lazy = this.sync = false;
	  }
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.expression = expOrFn.toString();
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      "development" !== 'production' && warn(
	        "Failed watching path: \"" + expOrFn + "\" " +
	        'Watcher only accepts simple dot-delimited paths. ' +
	        'For full control, use a function instead.',
	        vm
	      );
	    }
	  }
	  this.value = this.lazy
	    ? undefined
	    : this.get();
	};

	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get () {
	  pushTarget(this);
	  var value = this.getter.call(this.vm, this.vm);
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  popTarget();
	  this.cleanupDeps();
	  return value
	};

	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};

	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps () {
	    var this$1 = this;

	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};

	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update () {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};

	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run () {
	  if (this.active) {
	    var value = this.get();
	    if (
	      value !== this.value ||
	      // Deep watchers and watchers on Object/Arrays should fire even
	      // when the value is the same, because the value may
	      // have mutated.
	      isObject(value) ||
	      this.deep
	    ) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          /* istanbul ignore else */
	          if (config.errorHandler) {
	            config.errorHandler.call(null, e, this.vm);
	          } else {
	            "development" !== 'production' && warn(
	              ("Error in watcher \"" + (this.expression) + "\""),
	              this.vm
	            );
	            throw e
	          }
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};

	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate () {
	  this.value = this.get();
	  this.dirty = false;
	};

	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend () {
	    var this$1 = this;

	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};

	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown () {
	    var this$1 = this;

	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed.
	    if (!this.vm._isBeingDestroyed) {
	      remove$1(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};

	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse (val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}

	function _traverse (val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
	    return
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) { _traverse(val[i], seen); }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) { _traverse(val[keys[i]], seen); }
	  }
	}

	/*  */

	function initState (vm) {
	  vm._watchers = [];
	  var opts = vm.$options;
	  if (opts.props) { initProps(vm, opts.props); }
	  if (opts.methods) { initMethods(vm, opts.methods); }
	  if (opts.data) {
	    initData(vm);
	  } else {
	    observe(vm._data = {}, true /* asRootData */);
	  }
	  if (opts.computed) { initComputed(vm, opts.computed); }
	  if (opts.watch) { initWatch(vm, opts.watch); }
	}

	var isReservedProp = { key: 1, ref: 1, slot: 1 };

	function initProps (vm, props) {
	  var propsData = vm.$options.propsData || {};
	  var keys = vm.$options._propKeys = Object.keys(props);
	  var isRoot = !vm.$parent;
	  // root instance props should be converted
	  observerState.shouldConvert = isRoot;
	  var loop = function ( i ) {
	    var key = keys[i];
	    /* istanbul ignore else */
	    {
	      if (isReservedProp[key]) {
	        warn(
	          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
	          vm
	        );
	      }
	      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
	        if (vm.$parent && !observerState.isSettingProps) {
	          warn(
	            "Avoid mutating a prop directly since the value will be " +
	            "overwritten whenever the parent component re-renders. " +
	            "Instead, use a data or computed property based on the prop's " +
	            "value. Prop being mutated: \"" + key + "\"",
	            vm
	          );
	        }
	      });
	    }
	  };

	  for (var i = 0; i < keys.length; i++) loop( i );
	  observerState.shouldConvert = true;
	}

	function initData (vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function'
	    ? data.call(vm)
	    : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    "development" !== 'production' && warn(
	      'data functions should return an object:\n' +
	      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
	      vm
	    );
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var i = keys.length;
	  while (i--) {
	    if (props && hasOwn(props, keys[i])) {
	      "development" !== 'production' && warn(
	        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
	        "Use prop default value instead.",
	        vm
	      );
	    } else {
	      proxy(vm, keys[i]);
	    }
	  }
	  // observe data
	  observe(data, true /* asRootData */);
	}

	var computedSharedDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};

	function initComputed (vm, computed) {
	  for (var key in computed) {
	    /* istanbul ignore if */
	    if ("development" !== 'production' && key in vm) {
	      warn(
	        "existing instance property \"" + key + "\" will be " +
	        "overwritten by a computed property with the same name.",
	        vm
	      );
	    }
	    var userDef = computed[key];
	    if (typeof userDef === 'function') {
	      computedSharedDefinition.get = makeComputedGetter(userDef, vm);
	      computedSharedDefinition.set = noop;
	    } else {
	      computedSharedDefinition.get = userDef.get
	        ? userDef.cache !== false
	          ? makeComputedGetter(userDef.get, vm)
	          : bind$1(userDef.get, vm)
	        : noop;
	      computedSharedDefinition.set = userDef.set
	        ? bind$1(userDef.set, vm)
	        : noop;
	    }
	    Object.defineProperty(vm, key, computedSharedDefinition);
	  }
	}

	function makeComputedGetter (getter, owner) {
	  var watcher = new Watcher(owner, getter, noop, {
	    lazy: true
	  });
	  return function computedGetter () {
	    if (watcher.dirty) {
	      watcher.evaluate();
	    }
	    if (Dep.target) {
	      watcher.depend();
	    }
	    return watcher.value
	  }
	}

	function initMethods (vm, methods) {
	  for (var key in methods) {
	    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
	    if ("development" !== 'production' && methods[key] == null) {
	      warn(
	        "method \"" + key + "\" has an undefined value in the component definition. " +
	        "Did you reference the function correctly?",
	        vm
	      );
	    }
	  }
	}

	function initWatch (vm, watch) {
	  for (var key in watch) {
	    var handler = watch[key];
	    if (Array.isArray(handler)) {
	      for (var i = 0; i < handler.length; i++) {
	        createWatcher(vm, key, handler[i]);
	      }
	    } else {
	      createWatcher(vm, key, handler);
	    }
	  }
	}

	function createWatcher (vm, key, handler) {
	  var options;
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  vm.$watch(key, handler, options);
	}

	function stateMixin (Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data
	  };
	  {
	    dataDef.set = function (newData) {
	      warn(
	        'Avoid replacing instance root $data. ' +
	        'Use nested data properties instead.',
	        this
	      );
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);

	  Vue.prototype.$set = set$1;
	  Vue.prototype.$delete = del;

	  Vue.prototype.$watch = function (
	    expOrFn,
	    cb,
	    options
	  ) {
	    var vm = this;
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn () {
	      watcher.teardown();
	    }
	  };
	}

	function proxy (vm, key) {
	  if (!isReserved(key)) {
	    Object.defineProperty(vm, key, {
	      configurable: true,
	      enumerable: true,
	      get: function proxyGetter () {
	        return vm._data[key]
	      },
	      set: function proxySetter (val) {
	        vm._data[key] = val;
	      }
	    });
	  }
	}

	/*  */

	var VNode = function VNode (
	  tag,
	  data,
	  children,
	  text,
	  elm,
	  context,
	  componentOptions
	) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = undefined;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.child = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	};

	var createEmptyVNode = function () {
	  var node = new VNode();
	  node.text = '';
	  node.isComment = true;
	  return node
	};

	function createTextVNode (val) {
	  return new VNode(undefined, undefined, undefined, String(val))
	}

	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode (vnode) {
	  var cloned = new VNode(
	    vnode.tag,
	    vnode.data,
	    vnode.children,
	    vnode.text,
	    vnode.elm,
	    vnode.context,
	    vnode.componentOptions
	  );
	  cloned.ns = vnode.ns;
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isCloned = true;
	  return cloned
	}

	function cloneVNodes (vnodes) {
	  var res = new Array(vnodes.length);
	  for (var i = 0; i < vnodes.length; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res
	}

	/*  */

	function mergeVNodeHook (def, hookKey, hook, key) {
	  key = key + hookKey;
	  var injectedHash = def.__injected || (def.__injected = {});
	  if (!injectedHash[key]) {
	    injectedHash[key] = true;
	    var oldHook = def[hookKey];
	    if (oldHook) {
	      def[hookKey] = function () {
	        oldHook.apply(this, arguments);
	        hook.apply(this, arguments);
	      };
	    } else {
	      def[hookKey] = hook;
	    }
	  }
	}

	/*  */

	function updateListeners (
	  on,
	  oldOn,
	  add,
	  remove$$1,
	  vm
	) {
	  var name, cur, old, fn, event, capture, once;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    if (!cur) {
	      "development" !== 'production' && warn(
	        "Invalid handler for event \"" + name + "\": got " + String(cur),
	        vm
	      );
	    } else if (!old) {
	      once = name.charAt(0) === '~'; // Prefixed last, checked first
	      event = once ? name.slice(1) : name;
	      capture = event.charAt(0) === '!';
	      event = capture ? event.slice(1) : event;
	      if (Array.isArray(cur)) {
	        add(event, (cur.invoker = arrInvoker(cur)), once, capture);
	      } else {
	        if (!cur.invoker) {
	          fn = cur;
	          cur = on[name] = {};
	          cur.fn = fn;
	          cur.invoker = fnInvoker(cur);
	        }
	        add(event, cur.invoker, once, capture);
	      }
	    } else if (cur !== old) {
	      if (Array.isArray(old)) {
	        old.length = cur.length;
	        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }
	        on[name] = old;
	      } else {
	        old.fn = cur;
	        on[name] = old;
	      }
	    }
	  }
	  for (name in oldOn) {
	    if (!on[name]) {
	      once = name.charAt(0) === '~'; // Prefixed last, checked first
	      event = once ? name.slice(1) : name;
	      capture = event.charAt(0) === '!';
	      event = capture ? event.slice(1) : event;
	      remove$$1(event, oldOn[name].invoker, capture);
	    }
	  }
	}

	function arrInvoker (arr) {
	  return function (ev) {
	    var arguments$1 = arguments;

	    var single = arguments.length === 1;
	    for (var i = 0; i < arr.length; i++) {
	      single ? arr[i](ev) : arr[i].apply(null, arguments$1);
	    }
	  }
	}

	function fnInvoker (o) {
	  return function (ev) {
	    var single = arguments.length === 1;
	    single ? o.fn(ev) : o.fn.apply(null, arguments);
	  }
	}

	/*  */

	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:

	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// nomralization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren (children) {
	  for (var i = 0; i < children.length; i++) {
	    if (Array.isArray(children[i])) {
	      return Array.prototype.concat.apply([], children)
	    }
	  }
	  return children
	}

	// 2. When the children contains constrcuts that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren (children) {
	  return isPrimitive(children)
	    ? [createTextVNode(children)]
	    : Array.isArray(children)
	      ? normalizeArrayChildren(children)
	      : undefined
	}

	function normalizeArrayChildren (children, nestedIndex) {
	  var res = [];
	  var i, c, last;
	  for (i = 0; i < children.length; i++) {
	    c = children[i];
	    if (c == null || typeof c === 'boolean') { continue }
	    last = res[res.length - 1];
	    //  nested
	    if (Array.isArray(c)) {
	      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
	    } else if (isPrimitive(c)) {
	      if (last && last.text) {
	        last.text += String(c);
	      } else if (c !== '') {
	        // convert primitive to vnode
	        res.push(createTextVNode(c));
	      }
	    } else {
	      if (c.text && last && last.text) {
	        res[res.length - 1] = createTextVNode(last.text + c.text);
	      } else {
	        // default key for nested array children (likely generated by v-for)
	        if (c.tag && c.key == null && nestedIndex != null) {
	          c.key = "__vlist" + nestedIndex + "_" + i + "__";
	        }
	        res.push(c);
	      }
	    }
	  }
	  return res
	}

	/*  */

	function getFirstComponentChild (children) {
	  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
	}

	/*  */

	function initEvents (vm) {
	  vm._events = Object.create(null);
	  vm._hasHookEvent = false;
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  if (listeners) {
	    updateComponentListeners(vm, listeners);
	  }
	}

	var target;

	function add$1 (event, fn, once) {
	  if (once) {
	    target.$once(event, fn);
	  } else {
	    target.$on(event, fn);
	  }
	}

	function remove$2 (event, fn) {
	  target.$off(event, fn);
	}

	function updateComponentListeners (
	  vm,
	  listeners,
	  oldListeners
	) {
	  target = vm;
	  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);
	}

	function eventsMixin (Vue) {
	  var hookRE = /^hook:/;
	  Vue.prototype.$on = function (event, fn) {
	    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);
	    // optimize hook:event cost by using a boolean flag marked at registration
	    // instead of a hash lookup
	    if (hookRE.test(event)) {
	      vm._hasHookEvent = true;
	    }
	    return vm
	  };

	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on () {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm
	  };

	  Vue.prototype.$off = function (event, fn) {
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break
	      }
	    }
	    return vm
	  };

	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        cbs[i].apply(vm, args);
	      }
	    }
	    return vm
	  };
	}

	/*  */

	var activeInstance = null;

	function initLifecycle (vm) {
	  var options = vm.$options;

	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }

	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;

	  vm.$children = [];
	  vm.$refs = {};

	  vm._watcher = null;
	  vm._inactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}

	function lifecycleMixin (Vue) {
	  Vue.prototype._mount = function (
	    el,
	    hydrating
	  ) {
	    var vm = this;
	    vm.$el = el;
	    if (!vm.$options.render) {
	      vm.$options.render = createEmptyVNode;
	      {
	        /* istanbul ignore if */
	        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {
	          warn(
	            'You are using the runtime-only build of Vue where the template ' +
	            'option is not available. Either pre-compile the templates into ' +
	            'render functions, or use the compiler-included build.',
	            vm
	          );
	        } else {
	          warn(
	            'Failed to mount component: template or render function not defined.',
	            vm
	          );
	        }
	      }
	    }
	    callHook(vm, 'beforeMount');
	    vm._watcher = new Watcher(vm, function () {
	      vm._update(vm._render(), hydrating);
	    }, noop);
	    hydrating = false;
	    // manually mounted instance, call mounted on self
	    // mounted is called for render-created child components in its inserted hook
	    if (vm.$vnode == null) {
	      vm._isMounted = true;
	      callHook(vm, 'mounted');
	    }
	    return vm
	  };

	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevVnode = vm._vnode;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    vm._vnode = vnode;
	    // Vue.prototype.__patch__ is injected in entry points
	    // based on the rendering backend used.
	    if (!prevVnode) {
	      // initial render
	      vm.$el = vm.__patch__(
	        vm.$el, vnode, hydrating, false /* removeOnly */,
	        vm.$options._parentElm,
	        vm.$options._refElm
	      );
	    } else {
	      // updates
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    if (vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  };

	  Vue.prototype._updateFromParent = function (
	    propsData,
	    listeners,
	    parentVnode,
	    renderChildren
	  ) {
	    var vm = this;
	    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
	    vm.$options._parentVnode = parentVnode;
	    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	    if (vm._vnode) { // update child tree's parent
	      vm._vnode.parent = parentVnode;
	    }
	    vm.$options._renderChildren = renderChildren;
	    // update props
	    if (propsData && vm.$options.props) {
	      observerState.shouldConvert = false;
	      {
	        observerState.isSettingProps = true;
	      }
	      var propKeys = vm.$options._propKeys || [];
	      for (var i = 0; i < propKeys.length; i++) {
	        var key = propKeys[i];
	        vm[key] = validateProp(key, vm.$options.props, propsData, vm);
	      }
	      observerState.shouldConvert = true;
	      {
	        observerState.isSettingProps = false;
	      }
	      vm.$options.propsData = propsData;
	    }
	    // update listeners
	    if (listeners) {
	      var oldListeners = vm.$options._parentListeners;
	      vm.$options._parentListeners = listeners;
	      updateComponentListeners(vm, listeners, oldListeners);
	    }
	    // resolve slots + force update if has children
	    if (hasChildren) {
	      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	      vm.$forceUpdate();
	    }
	  };

	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };

	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove$1(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	  };
	}

	function callHook (vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      handlers[i].call(vm);
	    }
	  }
	  if (vm._hasHookEvent) {
	    vm.$emit('hook:' + hook);
	  }
	}

	/*  */

	var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
	var hooksToMerge = Object.keys(hooks);

	function createComponent (
	  Ctor,
	  data,
	  context,
	  children,
	  tag
	) {
	  if (!Ctor) {
	    return
	  }

	  var baseCtor = context.$options._base;
	  if (isObject(Ctor)) {
	    Ctor = baseCtor.extend(Ctor);
	  }

	  if (typeof Ctor !== 'function') {
	    {
	      warn(("Invalid Component definition: " + (String(Ctor))), context);
	    }
	    return
	  }

	  // async component
	  if (!Ctor.cid) {
	    if (Ctor.resolved) {
	      Ctor = Ctor.resolved;
	    } else {
	      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
	        // it's ok to queue this on every render because
	        // $forceUpdate is buffered by the scheduler.
	        context.$forceUpdate();
	      });
	      if (!Ctor) {
	        // return nothing if this is indeed an async component
	        // wait for the callback to trigger parent update.
	        return
	      }
	    }
	  }

	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);

	  data = data || {};

	  // extract props
	  var propsData = extractProps(data, Ctor);

	  // functional component
	  if (Ctor.options.functional) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children)
	  }

	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  data.on = data.nativeOn;

	  if (Ctor.options.abstract) {
	    // abstract components do not keep anything
	    // other than props & listeners
	    data = {};
	  }

	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);

	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode(
	    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
	    data, undefined, undefined, undefined, context,
	    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
	  );
	  return vnode
	}

	function createFunctionalComponent (
	  Ctor,
	  propsData,
	  data,
	  context,
	  children
	) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (propOptions) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData);
	    }
	  }
	  // ensure the createElement function in functional components
	  // gets a unique context - this is necessary for correct named slot check
	  var _context = Object.create(context);
	  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
	  var vnode = Ctor.options.render.call(null, h, {
	    props: props,
	    data: data,
	    parent: context,
	    children: children,
	    slots: function () { return resolveSlots(children, context); }
	  });
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode
	}

	function createComponentInstanceForVnode (
	  vnode, // we know it's MountedComponentVNode but flow doesn't
	  parent, // activeInstance in lifecycle state
	  parentElm,
	  refElm
	) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children,
	    _parentElm: parentElm || null,
	    _refElm: refElm || null
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (inlineTemplate) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options)
	}

	function init (
	  vnode,
	  hydrating,
	  parentElm,
	  refElm
	) {
	  if (!vnode.child || vnode.child._isDestroyed) {
	    var child = vnode.child = createComponentInstanceForVnode(
	      vnode,
	      activeInstance,
	      parentElm,
	      refElm
	    );
	    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	  } else if (vnode.data.keepAlive) {
	    // kept-alive components, treat as a patch
	    var mountedNode = vnode; // work around flow
	    prepatch(mountedNode, mountedNode);
	  }
	}

	function prepatch (
	  oldVnode,
	  vnode
	) {
	  var options = vnode.componentOptions;
	  var child = vnode.child = oldVnode.child;
	  child._updateFromParent(
	    options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	  );
	}

	function insert (vnode) {
	  if (!vnode.child._isMounted) {
	    vnode.child._isMounted = true;
	    callHook(vnode.child, 'mounted');
	  }
	  if (vnode.data.keepAlive) {
	    vnode.child._inactive = false;
	    callHook(vnode.child, 'activated');
	  }
	}

	function destroy$1 (vnode) {
	  if (!vnode.child._isDestroyed) {
	    if (!vnode.data.keepAlive) {
	      vnode.child.$destroy();
	    } else {
	      vnode.child._inactive = true;
	      callHook(vnode.child, 'deactivated');
	    }
	  }
	}

	function resolveAsyncComponent (
	  factory,
	  baseCtor,
	  cb
	) {
	  if (factory.requested) {
	    // pool callbacks
	    factory.pendingCallbacks.push(cb);
	  } else {
	    factory.requested = true;
	    var cbs = factory.pendingCallbacks = [cb];
	    var sync = true;

	    var resolve = function (res) {
	      if (isObject(res)) {
	        res = baseCtor.extend(res);
	      }
	      // cache resolved
	      factory.resolved = res;
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        for (var i = 0, l = cbs.length; i < l; i++) {
	          cbs[i](res);
	        }
	      }
	    };

	    var reject = function (reason) {
	      "development" !== 'production' && warn(
	        "Failed to resolve async component: " + (String(factory)) +
	        (reason ? ("\nReason: " + reason) : '')
	      );
	    };

	    var res = factory(resolve, reject);

	    // handle promise
	    if (res && typeof res.then === 'function' && !factory.resolved) {
	      res.then(resolve, reject);
	    }

	    sync = false;
	    // return in case resolved synchronously
	    return factory.resolved
	  }
	}

	function extractProps (data, Ctor) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (!propOptions) {
	    return
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  var domProps = data.domProps;
	  if (attrs || props || domProps) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      checkProp(res, props, key, altKey, true) ||
	      checkProp(res, attrs, key, altKey) ||
	      checkProp(res, domProps, key, altKey);
	    }
	  }
	  return res
	}

	function checkProp (
	  res,
	  hash,
	  key,
	  altKey,
	  preserve
	) {
	  if (hash) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true
	    }
	  }
	  return false
	}

	function mergeHooks (data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = hooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}

	function mergeHook$1 (one, two) {
	  return function (a, b, c, d) {
	    one(a, b, c, d);
	    two(a, b, c, d);
	  }
	}

	/*  */

	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;

	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement (
	  context,
	  tag,
	  data,
	  children,
	  normalizationType,
	  alwaysNormalize
	) {
	  if (Array.isArray(data) || isPrimitive(data)) {
	    normalizationType = children;
	    children = data;
	    data = undefined;
	  }
	  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
	  return _createElement(context, tag, data, children, normalizationType)
	}

	function _createElement (
	  context,
	  tag,
	  data,
	  children,
	  normalizationType
	) {
	  if (data && data.__ob__) {
	    "development" !== 'production' && warn(
	      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
	      'Always create fresh vnode data objects in each render!',
	      context
	    );
	    return createEmptyVNode()
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return createEmptyVNode()
	  }
	  // support single function children as default scoped slot
	  if (Array.isArray(children) &&
	      typeof children[0] === 'function') {
	    data = data || {};
	    data.scopedSlots = { default: children[0] };
	    children.length = 0;
	  }
	  if (normalizationType === ALWAYS_NORMALIZE) {
	    children = normalizeChildren(children);
	  } else if (normalizationType === SIMPLE_NORMALIZE) {
	    children = simpleNormalizeChildren(children);
	  }
	  var vnode, ns;
	  if (typeof tag === 'string') {
	    var Ctor;
	    ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      vnode = new VNode(
	        config.parsePlatformTagName(tag), data, children,
	        undefined, undefined, context
	      );
	    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      vnode = createComponent(Ctor, data, context, children, tag);
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      vnode = new VNode(
	        tag, data, children,
	        undefined, undefined, context
	      );
	    }
	  } else {
	    // direct component options / constructor
	    vnode = createComponent(tag, data, context, children);
	  }
	  if (vnode) {
	    if (ns) { applyNS(vnode, ns); }
	    return vnode
	  } else {
	    return createEmptyVNode()
	  }
	}

	function applyNS (vnode, ns) {
	  vnode.ns = ns;
	  if (vnode.tag === 'foreignObject') {
	    // use default namespace inside foreignObject
	    return
	  }
	  if (vnode.children) {
	    for (var i = 0, l = vnode.children.length; i < l; i++) {
	      var child = vnode.children[i];
	      if (child.tag && !child.ns) {
	        applyNS(child, ns);
	      }
	    }
	  }
	}

	/*  */

	function initRender (vm) {
	  vm.$vnode = null; // the placeholder node in parent tree
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  var parentVnode = vm.$options._parentVnode;
	  var renderContext = parentVnode && parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
	  vm.$scopedSlots = {};
	  // bind the createElement fn to this instance
	  // so that we get proper render context inside it.
	  // args order: tag, data, children, normalizationType, alwaysNormalize
	  // internal version is used by render functions compiled from templates
	  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
	  // normalization is always applied for the public version, used in
	  // user-written render functions.
	  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
	  if (vm.$options.el) {
	    vm.$mount(vm.$options.el);
	  }
	}

	function renderMixin (Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    return nextTick(fn, this)
	  };

	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;

	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }

	    if (_parentVnode && _parentVnode.data.scopedSlots) {
	      vm.$scopedSlots = _parentVnode.data.scopedSlots;
	    }

	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      /* istanbul ignore else */
	      if (config.errorHandler) {
	        config.errorHandler.call(null, e, vm);
	      } else {
	        {
	          warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
	        }
	        throw e
	      }
	      // return previous vnode to prevent render error causing blank component
	      vnode = vm._vnode;
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if ("development" !== 'production' && Array.isArray(vnode)) {
	        warn(
	          'Multiple root nodes returned from render function. Render function ' +
	          'should return a single root node.',
	          vm
	        );
	      }
	      vnode = createEmptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode
	  };

	  // toString for mustaches
	  Vue.prototype._s = _toString;
	  // convert text to vnode
	  Vue.prototype._v = createTextVNode;
	  // number conversion
	  Vue.prototype._n = toNumber;
	  // empty vnode
	  Vue.prototype._e = createEmptyVNode;
	  // loose equal
	  Vue.prototype._q = looseEqual;
	  // loose indexOf
	  Vue.prototype._i = looseIndexOf;

	  // render static tree by index
	  Vue.prototype._m = function renderStatic (
	    index,
	    isInFor
	  ) {
	    var tree = this._staticTrees[index];
	    // if has already-rendered static tree and not inside v-for,
	    // we can reuse the same tree by doing a shallow clone.
	    if (tree && !isInFor) {
	      return Array.isArray(tree)
	        ? cloneVNodes(tree)
	        : cloneVNode(tree)
	    }
	    // otherwise, render a fresh tree.
	    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	    markStatic(tree, ("__static__" + index), false);
	    return tree
	  };

	  // mark node as static (v-once)
	  Vue.prototype._o = function markOnce (
	    tree,
	    index,
	    key
	  ) {
	    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
	    return tree
	  };

	  function markStatic (tree, key, isOnce) {
	    if (Array.isArray(tree)) {
	      for (var i = 0; i < tree.length; i++) {
	        if (tree[i] && typeof tree[i] !== 'string') {
	          markStaticNode(tree[i], (key + "_" + i), isOnce);
	        }
	      }
	    } else {
	      markStaticNode(tree, key, isOnce);
	    }
	  }

	  function markStaticNode (node, key, isOnce) {
	    node.isStatic = true;
	    node.key = key;
	    node.isOnce = isOnce;
	  }

	  // filter resolution helper
	  Vue.prototype._f = function resolveFilter (id) {
	    return resolveAsset(this.$options, 'filters', id, true) || identity
	  };

	  // render v-for
	  Vue.prototype._l = function renderList (
	    val,
	    render
	  ) {
	    var ret, i, l, keys, key;
	    if (Array.isArray(val) || typeof val === 'string') {
	      ret = new Array(val.length);
	      for (i = 0, l = val.length; i < l; i++) {
	        ret[i] = render(val[i], i);
	      }
	    } else if (typeof val === 'number') {
	      ret = new Array(val);
	      for (i = 0; i < val; i++) {
	        ret[i] = render(i + 1, i);
	      }
	    } else if (isObject(val)) {
	      keys = Object.keys(val);
	      ret = new Array(keys.length);
	      for (i = 0, l = keys.length; i < l; i++) {
	        key = keys[i];
	        ret[i] = render(val[key], key, i);
	      }
	    }
	    return ret
	  };

	  // renderSlot
	  Vue.prototype._t = function (
	    name,
	    fallback,
	    props,
	    bindObject
	  ) {
	    var scopedSlotFn = this.$scopedSlots[name];
	    if (scopedSlotFn) { // scoped slot
	      props = props || {};
	      if (bindObject) {
	        extend(props, bindObject);
	      }
	      return scopedSlotFn(props) || fallback
	    } else {
	      var slotNodes = this.$slots[name];
	      // warn duplicate slot usage
	      if (slotNodes && "development" !== 'production') {
	        slotNodes._rendered && warn(
	          "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
	          "- this will likely cause render errors.",
	          this
	        );
	        slotNodes._rendered = true;
	      }
	      return slotNodes || fallback
	    }
	  };

	  // apply v-bind object
	  Vue.prototype._b = function bindProps (
	    data,
	    tag,
	    value,
	    asProp
	  ) {
	    if (value) {
	      if (!isObject(value)) {
	        "development" !== 'production' && warn(
	          'v-bind without argument expects an Object or Array value',
	          this
	        );
	      } else {
	        if (Array.isArray(value)) {
	          value = toObject(value);
	        }
	        for (var key in value) {
	          if (key === 'class' || key === 'style') {
	            data[key] = value[key];
	          } else {
	            var hash = asProp || config.mustUseProp(tag, key)
	              ? data.domProps || (data.domProps = {})
	              : data.attrs || (data.attrs = {});
	            hash[key] = value[key];
	          }
	        }
	      }
	    }
	    return data
	  };

	  // check v-on keyCodes
	  Vue.prototype._k = function checkKeyCodes (
	    eventKeyCode,
	    key,
	    builtInAlias
	  ) {
	    var keyCodes = config.keyCodes[key] || builtInAlias;
	    if (Array.isArray(keyCodes)) {
	      return keyCodes.indexOf(eventKeyCode) === -1
	    } else {
	      return keyCodes !== eventKeyCode
	    }
	  };
	}

	function resolveSlots (
	  children,
	  context
	) {
	  var slots = {};
	  if (!children) {
	    return slots
	  }
	  var defaultSlot = [];
	  var name, child;
	  for (var i = 0, l = children.length; i < l; i++) {
	    child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) &&
	        child.data && (name = child.data.slot)) {
	      var slot = (slots[name] || (slots[name] = []));
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore single whitespace
	  if (defaultSlot.length && !(
	    defaultSlot.length === 1 &&
	    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
	  )) {
	    slots.default = defaultSlot;
	  }
	  return slots
	}

	/*  */

	var uid = 0;

	function initMixin (Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid++;
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(
	        resolveConstructorOptions(vm.constructor),
	        options || {},
	        vm
	      );
	    }
	    /* istanbul ignore else */
	    {
	      initProxy(vm);
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    callHook(vm, 'beforeCreate');
	    initState(vm);
	    callHook(vm, 'created');
	    initRender(vm);
	  };
	}

	function initInternalComponent (vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  opts._parentElm = options._parentElm;
	  opts._refElm = options._refElm;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}

	function resolveConstructorOptions (Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = Ctor.super.options;
	    var cachedSuperOptions = Ctor.superOptions;
	    var extendOptions = Ctor.extendOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed
	      Ctor.superOptions = superOptions;
	      extendOptions.render = options.render;
	      extendOptions.staticRenderFns = options.staticRenderFns;
	      extendOptions._scopeId = options._scopeId;
	      options = Ctor.options = mergeOptions(superOptions, extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options
	}

	function Vue$3 (options) {
	  if ("development" !== 'production' &&
	    !(this instanceof Vue$3)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}

	initMixin(Vue$3);
	stateMixin(Vue$3);
	eventsMixin(Vue$3);
	lifecycleMixin(Vue$3);
	renderMixin(Vue$3);

	/*  */

	function initUse (Vue) {
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this
	  };
	}

	/*  */

	function initMixin$1 (Vue) {
	  Vue.mixin = function (mixin) {
	    this.options = mergeOptions(this.options, mixin);
	  };
	}

	/*  */

	function initExtend (Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;

	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var SuperId = Super.cid;
	    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	    if (cachedCtors[SuperId]) {
	      return cachedCtors[SuperId]
	    }
	    var name = extendOptions.name || Super.options.name;
	    {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn(
	          'Invalid component name: "' + name + '". Component names ' +
	          'can only contain alphanumeric characters and the hyphen, ' +
	          'and must start with a letter.'
	        );
	      }
	    }
	    var Sub = function VueComponent (options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(
	      Super.options,
	      extendOptions
	    );
	    Sub['super'] = Super;
	    // allow further extension/mixin/plugin usage
	    Sub.extend = Super.extend;
	    Sub.mixin = Super.mixin;
	    Sub.use = Super.use;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    // cache constructor
	    cachedCtors[SuperId] = Sub;
	    return Sub
	  };
	}

	/*  */

	function initAssetRegisters (Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (
	      id,
	      definition
	    ) {
	      if (!definition) {
	        return this.options[type + 's'][id]
	      } else {
	        /* istanbul ignore if */
	        {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn(
	              'Do not use built-in or reserved HTML elements as component ' +
	              'id: ' + id
	            );
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = this.options._base.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition
	      }
	    };
	  });
	}

	/*  */

	var patternTypes = [String, RegExp];

	function matches (pattern, name) {
	  if (typeof pattern === 'string') {
	    return pattern.split(',').indexOf(name) > -1
	  } else {
	    return pattern.test(name)
	  }
	}

	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	  props: {
	    include: patternTypes,
	    exclude: patternTypes
	  },
	  created: function created () {
	    this.cache = Object.create(null);
	  },
	  render: function render () {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    if (vnode && vnode.componentOptions) {
	      var opts = vnode.componentOptions;
	      // check pattern
	      var name = opts.Ctor.options.name || opts.tag;
	      if (name && (
	        (this.include && !matches(this.include, name)) ||
	        (this.exclude && matches(this.exclude, name))
	      )) {
	        return vnode
	      }
	      var key = vnode.key == null
	        // same constructor may get registered as different local components
	        // so cid alone is not enough (#3269)
	        ? opts.Ctor.cid + (opts.tag ? ("::" + (opts.tag)) : '')
	        : vnode.key;
	      if (this.cache[key]) {
	        vnode.child = this.cache[key].child;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode
	  },
	  destroyed: function destroyed () {
	    var this$1 = this;

	    for (var key in this.cache) {
	      var vnode = this$1.cache[key];
	      callHook(vnode.child, 'deactivated');
	      vnode.child.$destroy();
	    }
	  }
	};

	var builtInComponents = {
	  KeepAlive: KeepAlive
	};

	/*  */

	function initGlobalAPI (Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () { return config; };
	  {
	    configDef.set = function () {
	      warn(
	        'Do not replace the Vue.config object, set individual fields instead.'
	      );
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	  Vue.util = util;
	  Vue.set = set$1;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;

	  Vue.options = Object.create(null);
	  config._assetTypes.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });

	  // this is used to identify the "base" constructor to extend all plain-object
	  // components with in Weex's multi-instance scenarios.
	  Vue.options._base = Vue;

	  extend(Vue.options.components, builtInComponents);

	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}

	initGlobalAPI(Vue$3);

	Object.defineProperty(Vue$3.prototype, '$isServer', {
	  get: isServerRendering
	});

	Vue$3.version = '2.1.8';

	/*  */

	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select');
	var mustUseProp = function (tag, attr) {
	  return (
	    (attr === 'value' && acceptValue(tag)) ||
	    (attr === 'selected' && tag === 'option') ||
	    (attr === 'checked' && tag === 'input') ||
	    (attr === 'muted' && tag === 'video')
	  )
	};

	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

	var isBooleanAttr = makeMap(
	  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
	  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
	  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
	  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
	  'required,reversed,scoped,seamless,selected,sortable,translate,' +
	  'truespeed,typemustmatch,visible'
	);

	var xlinkNS = 'http://www.w3.org/1999/xlink';

	var isXlink = function (name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
	};

	var getXlinkProp = function (name) {
	  return isXlink(name) ? name.slice(6, name.length) : ''
	};

	var isFalsyAttrValue = function (val) {
	  return val == null || val === false
	};

	/*  */

	function genClassForVnode (vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (childNode.child) {
	    childNode = childNode.child._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while ((parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return genClassFromData(data)
	}

	function mergeClassData (child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: child.class
	      ? [child.class, parent.class]
	      : parent.class
	  }
	}

	function genClassFromData (data) {
	  var dynamicClass = data.class;
	  var staticClass = data.staticClass;
	  if (staticClass || dynamicClass) {
	    return concat(staticClass, stringifyClass(dynamicClass))
	  }
	  /* istanbul ignore next */
	  return ''
	}

	function concat (a, b) {
	  return a ? b ? (a + ' ' + b) : a : (b || '')
	}

	function stringifyClass (value) {
	  var res = '';
	  if (!value) {
	    return res
	  }
	  if (typeof value === 'string') {
	    return value
	  }
	  if (Array.isArray(value)) {
	    var stringified;
	    for (var i = 0, l = value.length; i < l; i++) {
	      if (value[i]) {
	        if ((stringified = stringifyClass(value[i]))) {
	          res += stringified + ' ';
	        }
	      }
	    }
	    return res.slice(0, -1)
	  }
	  if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) { res += key + ' '; }
	    }
	    return res.slice(0, -1)
	  }
	  /* istanbul ignore next */
	  return res
	}

	/*  */

	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML'
	};

	var isHTMLTag = makeMap(
	  'html,body,base,head,link,meta,style,title,' +
	  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
	  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
	  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
	  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
	  'embed,object,param,source,canvas,script,noscript,del,ins,' +
	  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
	  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
	  'output,progress,select,textarea,' +
	  'details,dialog,menu,menuitem,summary,' +
	  'content,element,shadow,template'
	);

	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap(
	  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +
	  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
	  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
	  true
	);

	var isPreTag = function (tag) { return tag === 'pre'; };

	var isReservedTag = function (tag) {
	  return isHTMLTag(tag) || isSVG(tag)
	};

	function getTagNamespace (tag) {
	  if (isSVG(tag)) {
	    return 'svg'
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math'
	  }
	}

	var unknownElementCache = Object.create(null);
	function isUnknownElement (tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true
	  }
	  if (isReservedTag(tag)) {
	    return false
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag]
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return (unknownElementCache[tag] = (
	      el.constructor === window.HTMLUnknownElement ||
	      el.constructor === window.HTMLElement
	    ))
	  } else {
	    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
	  }
	}

	/*  */

	/**
	 * Query an element selector if it's not an element already.
	 */
	function query (el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      "development" !== 'production' && warn(
	        'Cannot find element: ' + selector
	      );
	      return document.createElement('div')
	    }
	  }
	  return el
	}

	/*  */

	function createElement$1 (tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm
	  }
	  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm
	}

	function createElementNS (namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName)
	}

	function createTextNode (text) {
	  return document.createTextNode(text)
	}

	function createComment (text) {
	  return document.createComment(text)
	}

	function insertBefore (parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}

	function removeChild (node, child) {
	  node.removeChild(child);
	}

	function appendChild (node, child) {
	  node.appendChild(child);
	}

	function parentNode (node) {
	  return node.parentNode
	}

	function nextSibling (node) {
	  return node.nextSibling
	}

	function tagName (node) {
	  return node.tagName
	}

	function setTextContent (node, text) {
	  node.textContent = text;
	}

	function setAttribute (node, key, val) {
	  node.setAttribute(key, val);
	}


	var nodeOps = Object.freeze({
		createElement: createElement$1,
		createElementNS: createElementNS,
		createTextNode: createTextNode,
		createComment: createComment,
		insertBefore: insertBefore,
		removeChild: removeChild,
		appendChild: appendChild,
		parentNode: parentNode,
		nextSibling: nextSibling,
		tagName: tagName,
		setTextContent: setTextContent,
		setAttribute: setAttribute
	});

	/*  */

	var ref = {
	  create: function create (_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update (oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy (vnode) {
	    registerRef(vnode, true);
	  }
	};

	function registerRef (vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) { return }

	  var vm = vnode.context;
	  var ref = vnode.child || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove$1(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
	        refs[key].push(ref);
	      } else {
	        refs[key] = [ref];
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}

	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *

	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */

	var emptyNode = new VNode('', {}, []);

	var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];

	function isUndef (s) {
	  return s == null
	}

	function isDef (s) {
	  return s != null
	}

	function sameVnode (vnode1, vnode2) {
	  return (
	    vnode1.key === vnode2.key &&
	    vnode1.tag === vnode2.tag &&
	    vnode1.isComment === vnode2.isComment &&
	    !vnode1.data === !vnode2.data
	  )
	}

	function createKeyToOldIdx (children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) { map[key] = i; }
	  }
	  return map
	}

	function createPatchFunction (backend) {
	  var i, j;
	  var cbs = {};

	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;

	  for (i = 0; i < hooks$1.length; ++i) {
	    cbs[hooks$1[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
	    }
	  }

	  function emptyNodeAt (elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
	  }

	  function createRmCb (childElm, listeners) {
	    function remove$$1 () {
	      if (--remove$$1.listeners === 0) {
	        removeNode(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1
	  }

	  function removeNode (el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html / v-text
	    if (parent) {
	      nodeOps.removeChild(parent, el);
	    }
	  }

	  var inPre = 0;
	  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
	    vnode.isRootInsert = !nested; // for transition enter check
	    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	      return
	    }

	    var data = vnode.data;
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      {
	        if (data && data.pre) {
	          inPre++;
	        }
	        if (
	          !inPre &&
	          !vnode.ns &&
	          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
	          config.isUnknownElement(tag)
	        ) {
	          warn(
	            'Unknown custom element: <' + tag + '> - did you ' +
	            'register the component correctly? For recursive components, ' +
	            'make sure to provide the "name" option.',
	            vnode.context
	          );
	        }
	      }
	      vnode.elm = vnode.ns
	        ? nodeOps.createElementNS(vnode.ns, tag)
	        : nodeOps.createElement(tag, vnode);
	      setScope(vnode);

	      /* istanbul ignore if */
	      {
	        createChildren(vnode, children, insertedVnodeQueue);
	        if (isDef(data)) {
	          invokeCreateHooks(vnode, insertedVnodeQueue);
	        }
	        insert(parentElm, vnode.elm, refElm);
	      }

	      if ("development" !== 'production' && data && data.pre) {
	        inPre--;
	      }
	    } else if (vnode.isComment) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    }
	  }

	  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i = vnode.data;
	    if (isDef(i)) {
	      var isReactivated = isDef(vnode.child) && i.keepAlive;
	      if (isDef(i = i.hook) && isDef(i = i.init)) {
	        i(vnode, false /* hydrating */, parentElm, refElm);
	      }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(vnode.child)) {
	        initComponent(vnode, insertedVnodeQueue);
	        if (isReactivated) {
	          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	        }
	        return true
	      }
	    }
	  }

	  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i;
	    // hack for #4339: a reactivated component with inner transition
	    // does not trigger because the inner node's created hooks are not called
	    // again. It's not ideal to involve module-specific logic in here but
	    // there doesn't seem to be a better way to do it.
	    var innerNode = vnode;
	    while (innerNode.child) {
	      innerNode = innerNode.child._vnode;
	      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
	        for (i = 0; i < cbs.activate.length; ++i) {
	          cbs.activate[i](emptyNode, innerNode);
	        }
	        insertedVnodeQueue.push(innerNode);
	        break
	      }
	    }
	    // unlike a newly created component,
	    // a reactivated keep-alive component doesn't insert itself
	    insert(parentElm, vnode.elm, refElm);
	  }

	  function insert (parent, elm, ref) {
	    if (parent) {
	      if (ref) {
	        nodeOps.insertBefore(parent, elm, ref);
	      } else {
	        nodeOps.appendChild(parent, elm);
	      }
	    }
	  }

	  function createChildren (vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }

	  function isPatchable (vnode) {
	    while (vnode.child) {
	      vnode = vnode.child._vnode;
	    }
	    return isDef(vnode.tag)
	  }

	  function invokeCreateHooks (vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (i.create) { i.create(emptyNode, vnode); }
	      if (i.insert) { insertedVnodeQueue.push(vnode); }
	    }
	  }

	  function initComponent (vnode, insertedVnodeQueue) {
	    if (vnode.data.pendingInsert) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	    }
	    vnode.elm = vnode.child.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }

	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope (vnode) {
	    var i;
	    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	    if (isDef(i = activeInstance) &&
	        i !== vnode.context &&
	        isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }

	  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
	    }
	  }

	  function invokeDestroyHook (vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
	      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }

	  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else { // Text node
	          removeNode(ch.elm);
	        }
	      }
	    }
	  }

	  function removeAndInvokeRemoveHook (vnode, rm) {
	    if (rm || isDef(vnode.data)) {
	      var listeners = cbs.remove.length + 1;
	      if (!rm) {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      } else {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeNode(vnode.elm);
	    }
	  }

	  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, refElm;

	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;

	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) { // New element
	          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if ("development" !== 'production' && !elmToMove) {
	            warn(
	              'It seems there are duplicate keys that is causing an update error. ' +
	              'Make sure each v-for item has a unique key.'
	            );
	          }
	          if (sameVnode(elmToMove, newStartVnode)) {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            // same key but different element. treat as new element
	            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }

	  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return
	    }
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (vnode.isStatic &&
	        oldVnode.isStatic &&
	        vnode.key === oldVnode.key &&
	        (vnode.isCloned || vnode.isOnce)) {
	      vnode.elm = oldVnode.elm;
	      vnode.child = oldVnode.child;
	      return
	    }
	    var i;
	    var data = vnode.data;
	    var hasData = isDef(data);
	    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	    var elm = vnode.elm = oldVnode.elm;
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (hasData && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
	      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (hasData) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
	    }
	  }

	  function invokeInsertHook (vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (initial && vnode.parent) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }

	  var bailed = false;
	  // list of modules that can skip create hook during hydration because they
	  // are already rendered on the client or has no need for initialization
	  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

	  // Note: this is a browser-only function so we can assume elms are DOM nodes.
	  function hydrate (elm, vnode, insertedVnodeQueue) {
	    {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
	      if (isDef(i = vnode.child)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        // empty element, allow client to pick up and populate children
	        if (!elm.hasChildNodes()) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          var childNode = elm.firstChild;
	          for (var i$1 = 0; i$1 < children.length; i$1++) {
	            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
	              childrenMatch = false;
	              break
	            }
	            childNode = childNode.nextSibling;
	          }
	          // if childNode is not null, it means the actual childNodes list is
	          // longer than the virtual children list.
	          if (!childrenMatch || childNode) {
	            if ("development" !== 'production' &&
	                typeof console !== 'undefined' &&
	                !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	            }
	            return false
	          }
	        }
	      }
	      if (isDef(data)) {
	        for (var key in data) {
	          if (!isRenderedModule(key)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            break
	          }
	        }
	      }
	    } else if (elm.data !== vnode.text) {
	      elm.data = vnode.text;
	    }
	    return true
	  }

	  function assertNodeMatch (node, vnode) {
	    if (vnode.tag) {
	      return (
	        vnode.tag.indexOf('vue-component') === 0 ||
	        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
	      )
	    } else {
	      return node.nodeType === (vnode.isComment ? 8 : 3)
	    }
	  }

	  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
	    if (!vnode) {
	      if (oldVnode) { invokeDestroyHook(oldVnode); }
	      return
	    }

	    var elm, parent;
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];

	    if (!oldVnode) {
	      // empty mount (likely as component), create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        // patch existing root node
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
	            oldVnode.removeAttribute('server-rendered');
	            hydrating = true;
	          }
	          if (hydrating) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode
	            } else {
	              warn(
	                'The client-side rendered virtual DOM tree is not matching ' +
	                'server-rendered content. This is likely caused by incorrect ' +
	                'HTML markup, for example nesting block-level elements inside ' +
	                '<p>, or missing <tbody>. Bailing hydration and performing ' +
	                'full client-side render.'
	              );
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        // replacing existing element
	        elm = oldVnode.elm;
	        parent = nodeOps.parentNode(elm);
	        createElm(vnode, insertedVnodeQueue, parent, nodeOps.nextSibling(elm));

	        if (vnode.parent) {
	          // component root element replaced.
	          // update parent placeholder node element, recursively
	          var ancestor = vnode.parent;
	          while (ancestor) {
	            ancestor.elm = vnode.elm;
	            ancestor = ancestor.parent;
	          }
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }

	        if (parent !== null) {
	          removeVnodes(parent, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }

	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm
	  }
	}

	/*  */

	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives (vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};

	function updateDirectives (oldVnode, vnode) {
	  if (oldVnode.data.directives || vnode.data.directives) {
	    _update(oldVnode, vnode);
	  }
	}

	function _update (oldVnode, vnode) {
	  var isCreate = oldVnode === emptyNode;
	  var isDestroy = vnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];

	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }

	  if (dirsWithInsert.length) {
	    var callInsert = function () {
	      for (var i = 0; i < dirsWithInsert.length; i++) {
	        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	      }
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
	    } else {
	      callInsert();
	    }
	  }

	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      for (var i = 0; i < dirsWithPostpatch.length; i++) {
	        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	      }
	    }, 'dir-postpatch');
	  }

	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	      }
	    }
	  }
	}

	var emptyModifiers = Object.create(null);

	function normalizeDirectives$1 (
	  dirs,
	  vm
	) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res
	}

	function getRawDirName (dir) {
	  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
	}

	function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	  }
	}

	var baseModules = [
	  ref,
	  directives
	];

	/*  */

	function updateAttrs (oldVnode, vnode) {
	  if (!oldVnode.data.attrs && !vnode.data.attrs) {
	    return
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (attrs.__ob__) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }

	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  // #4391: in IE9, setting type can reset value for input[type=radio]
	  /* istanbul ignore if */
	  if (isIE9 && attrs.value !== oldAttrs.value) {
	    setAttr(elm, 'value', attrs.value);
	  }
	  for (key in oldAttrs) {
	    if (attrs[key] == null) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}

	function setAttr (el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}

	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};

	/*  */

	function updateClass (oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (!data.staticClass && !data.class &&
	      (!oldData || (!oldData.staticClass && !oldData.class))) {
	    return
	  }

	  var cls = genClassForVnode(vnode);

	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (transitionClass) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }

	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}

	var klass = {
	  create: updateClass,
	  update: updateClass
	};

	/*  */

	var target$1;

	function add$2 (event, handler, once, capture) {
	  if (once) {
	    var oldHandler = handler;
	    handler = function (ev) {
	      remove$3(event, handler, capture);
	      arguments.length === 1
	        ? oldHandler(ev)
	        : oldHandler.apply(null, arguments);
	    };
	  }
	  target$1.addEventListener(event, handler, capture);
	}

	function remove$3 (event, handler, capture) {
	  target$1.removeEventListener(event, handler, capture);
	}

	function updateDOMListeners (oldVnode, vnode) {
	  if (!oldVnode.data.on && !vnode.data.on) {
	    return
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  target$1 = vnode.elm;
	  updateListeners(on, oldOn, add$2, remove$3, vnode.context);
	}

	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};

	/*  */

	function updateDOMProps (oldVnode, vnode) {
	  if (!oldVnode.data.domProps && !vnode.data.domProps) {
	    return
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (props.__ob__) {
	    props = vnode.data.domProps = extend({}, props);
	  }

	  for (key in oldProps) {
	    if (props[key] == null) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if (key === 'textContent' || key === 'innerHTML') {
	      if (vnode.children) { vnode.children.length = 0; }
	      if (cur === oldProps[key]) { continue }
	    }
	    // #4521: if a click event triggers update before the change event is
	    // dispatched on a checkbox/radio input, the input's checked state will
	    // be reset and fail to trigger another update.
	    /* istanbul ignore next */
	    if (key === 'checked' && !isDirty(elm, cur)) {
	      continue
	    }
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = cur == null ? '' : String(cur);
	      if (shouldUpdateValue(elm, vnode, strCur)) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}

	// check platforms/web/util/attrs.js acceptValue


	function shouldUpdateValue (
	  elm,
	  vnode,
	  checkVal
	) {
	  if (!elm.composing && (
	    vnode.tag === 'option' ||
	    isDirty(elm, checkVal) ||
	    isInputChanged(vnode, checkVal)
	  )) {
	    return true
	  }
	  return false
	}

	function isDirty (elm, checkVal) {
	  return document.activeElement !== elm && elm.value !== checkVal
	}

	function isInputChanged (vnode, newVal) {
	  var value = vnode.elm.value;
	  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime
	  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {
	    return toNumber(value) !== toNumber(newVal)
	  }
	  if (modifiers && modifiers.trim) {
	    return value.trim() !== newVal.trim()
	  }
	  return value !== newVal
	}

	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};

	/*  */

	var parseStyleText = cached(function (cssText) {
	  var res = {};
	  var listDelimiter = /;(?![^(]*\))/g;
	  var propertyDelimiter = /:(.+)/;
	  cssText.split(listDelimiter).forEach(function (item) {
	    if (item) {
	      var tmp = item.split(propertyDelimiter);
	      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	    }
	  });
	  return res
	});

	// merge static and dynamic style data on the same vnode
	function normalizeStyleData (data) {
	  var style = normalizeStyleBinding(data.style);
	  // static style is pre-processed into an object during compilation
	  // and is always a fresh object, so it's safe to merge into it
	  return data.staticStyle
	    ? extend(data.staticStyle, style)
	    : style
	}

	// normalize possible array / string values into Object
	function normalizeStyleBinding (bindingStyle) {
	  if (Array.isArray(bindingStyle)) {
	    return toObject(bindingStyle)
	  }
	  if (typeof bindingStyle === 'string') {
	    return parseStyleText(bindingStyle)
	  }
	  return bindingStyle
	}

	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle (vnode, checkChild) {
	  var res = {};
	  var styleData;

	  if (checkChild) {
	    var childNode = vnode;
	    while (childNode.child) {
	      childNode = childNode.child._vnode;
	      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
	        extend(res, styleData);
	      }
	    }
	  }

	  if ((styleData = normalizeStyleData(vnode.data))) {
	    extend(res, styleData);
	  }

	  var parentNode = vnode;
	  while ((parentNode = parentNode.parent)) {
	    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	      extend(res, styleData);
	    }
	  }
	  return res
	}

	/*  */

	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function (el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else if (importantRE.test(val)) {
	    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
	  } else {
	    el.style[normalize(name)] = val;
	  }
	};

	var prefixes = ['Webkit', 'Moz', 'ms'];

	var testEl;
	var normalize = cached(function (prop) {
	  testEl = testEl || document.createElement('div');
	  prop = camelize(prop);
	  if (prop !== 'filter' && (prop in testEl.style)) {
	    return prop
	  }
	  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefixed = prefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return prefixed
	    }
	  }
	});

	function updateStyle (oldVnode, vnode) {
	  var data = vnode.data;
	  var oldData = oldVnode.data;

	  if (!data.staticStyle && !data.style &&
	      !oldData.staticStyle && !oldData.style) {
	    return
	  }

	  var cur, name;
	  var el = vnode.elm;
	  var oldStaticStyle = oldVnode.data.staticStyle;
	  var oldStyleBinding = oldVnode.data.style || {};

	  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	  var oldStyle = oldStaticStyle || oldStyleBinding;

	  var style = normalizeStyleBinding(vnode.data.style) || {};

	  vnode.data.style = style.__ob__ ? extend({}, style) : style;

	  var newStyle = getStyle(vnode, true);

	  for (name in oldStyle) {
	    if (newStyle[name] == null) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in newStyle) {
	    cur = newStyle[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}

	var style = {
	  create: updateStyle,
	  update: updateStyle
	};

	/*  */

	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass (el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !cls.trim()) {
	    return
	  }

	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = ' ' + el.getAttribute('class') + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}

	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass (el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !cls.trim()) {
	    return
	  }

	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
	    } else {
	      el.classList.remove(cls);
	    }
	  } else {
	    var cur = ' ' + el.getAttribute('class') + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    el.setAttribute('class', cur.trim());
	  }
	}

	/*  */

	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';

	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined &&
	    window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined &&
	    window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}

	var raf = (inBrowser && window.requestAnimationFrame) || setTimeout;
	function nextFrame (fn) {
	  raf(function () {
	    raf(fn);
	  });
	}

	function addTransitionClass (el, cls) {
	  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
	  addClass(el, cls);
	}

	function removeTransitionClass (el, cls) {
	  if (el._transitionClasses) {
	    remove$1(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}

	function whenTransitionEnds (
	  el,
	  expectedType,
	  cb
	) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) { return cb() }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function () {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function (e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}

	var transformRE = /\b(transform|all)(,|$)/;

	function getTransitionInfo (el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);

	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0
	      ? transitionTimeout > animationTimeout
	        ? TRANSITION
	        : ANIMATION
	      : null;
	    propCount = type
	      ? type === TRANSITION
	        ? transitionDurations.length
	        : animationDurations.length
	      : 0;
	  }
	  var hasTransform =
	    type === TRANSITION &&
	    transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  }
	}

	function getTimeout (delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }

	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i])
	  }))
	}

	function toMs (s) {
	  return Number(s.slice(0, -1)) * 1000
	}

	/*  */

	function enter (vnode, toggleDisplay) {
	  var el = vnode.elm;

	  // call leave callback now
	  if (el._leaveCb) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }

	  var data = resolveTransition(vnode.data.transition);
	  if (!data) {
	    return
	  }

	  /* istanbul ignore if */
	  if (el._enterCb || el.nodeType !== 1) {
	    return
	  }

	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterToClass = data.enterToClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearToClass = data.appearToClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;

	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var context = activeInstance;
	  var transitionNode = activeInstance.$vnode;
	  while (transitionNode && transitionNode.parent) {
	    transitionNode = transitionNode.parent;
	    context = transitionNode.context;
	  }

	  var isAppear = !context._isMounted || !vnode.isRootInsert;

	  if (isAppear && !appear && appear !== '') {
	    return
	  }

	  var startClass = isAppear ? appearClass : enterClass;
	  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
	  var toClass = isAppear ? appearToClass : enterToClass;
	  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
	  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
	  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
	  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl =
	    enterHook &&
	    // enterHook may be a bound method which exposes
	    // the length of original fn as _length
	    (enterHook._length || enterHook.length) > 1;

	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, toClass);
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });

	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode &&
	          pendingNode.context === vnode.context &&
	          pendingNode.tag === vnode.tag &&
	          pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    }, 'transition-insert');
	  }

	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      addTransitionClass(el, toClass);
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        whenTransitionEnds(el, type, cb);
	      }
	    });
	  }

	  if (vnode.data.show) {
	    toggleDisplay && toggleDisplay();
	    enterHook && enterHook(el, cb);
	  }

	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}

	function leave (vnode, rm) {
	  var el = vnode.elm;

	  // call enter callback now
	  if (el._enterCb) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }

	  var data = resolveTransition(vnode.data.transition);
	  if (!data) {
	    return rm()
	  }

	  /* istanbul ignore if */
	  if (el._leaveCb || el.nodeType !== 1) {
	    return
	  }

	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveToClass = data.leaveToClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;

	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl =
	    leave &&
	    // leave hook may be a bound method which exposes
	    // the length of original fn as _length
	    (leave._length || leave.length) > 1;

	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveToClass);
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });

	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }

	  function performLeave () {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        addTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          whenTransitionEnds(el, type, cb);
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}

	function resolveTransition (def$$1) {
	  if (!def$$1) {
	    return
	  }
	  /* istanbul ignore else */
	  if (typeof def$$1 === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1)
	  }
	}

	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: (name + "-enter"),
	    leaveClass: (name + "-leave"),
	    appearClass: (name + "-enter"),
	    enterToClass: (name + "-enter-to"),
	    leaveToClass: (name + "-leave-to"),
	    appearToClass: (name + "-enter-to"),
	    enterActiveClass: (name + "-enter-active"),
	    leaveActiveClass: (name + "-leave-active"),
	    appearActiveClass: (name + "-enter-active")
	  }
	});

	function once (fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn();
	    }
	  }
	}

	function _enter (_, vnode) {
	  if (!vnode.data.show) {
	    enter(vnode);
	  }
	}

	var transition = inBrowser ? {
	  create: _enter,
	  activate: _enter,
	  remove: function remove (vnode, rm) {
	    /* istanbul ignore else */
	    if (!vnode.data.show) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};

	var platformModules = [
	  attrs,
	  klass,
	  events,
	  domProps,
	  style,
	  transition
	];

	/*  */

	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);

	var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */

	var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}

	var model = {
	  inserted: function inserted (el, binding, vnode) {
	    {
	      if (!modelableTagRE.test(vnode.tag)) {
	        warn(
	          "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
	          'If you are working with contenteditable, it\'s recommended to ' +
	          'wrap a library dedicated for that purpose inside a custom component.',
	          vnode.context
	        );
	      }
	    }
	    if (vnode.tag === 'select') {
	      var cb = function () {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	    } else if (vnode.tag === 'textarea' || el.type === 'text') {
	      el._vModifiers = binding.modifiers;
	      if (!binding.modifiers.lazy) {
	        if (!isAndroid) {
	          el.addEventListener('compositionstart', onCompositionStart);
	          el.addEventListener('compositionend', onCompositionEnd);
	        }
	        /* istanbul ignore if */
	        if (isIE9) {
	          el.vmodel = true;
	        }
	      }
	    }
	  },
	  componentUpdated: function componentUpdated (el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var needReset = el.multiple
	        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
	        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
	      if (needReset) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};

	function setSelected (el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    "development" !== 'production' && warn(
	      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
	      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
	      vm
	    );
	    return
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}

	function hasNoMatchingOption (value, options) {
	  for (var i = 0, l = options.length; i < l; i++) {
	    if (looseEqual(getValue(options[i]), value)) {
	      return false
	    }
	  }
	  return true
	}

	function getValue (option) {
	  return '_value' in option
	    ? option._value
	    : option.value
	}

	function onCompositionStart (e) {
	  e.target.composing = true;
	}

	function onCompositionEnd (e) {
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}

	function trigger (el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}

	/*  */

	// recursively search for possible transition defined inside the component root
	function locateNode (vnode) {
	  return vnode.child && (!vnode.data || !vnode.data.transition)
	    ? locateNode(vnode.child._vnode)
	    : vnode
	}

	var show = {
	  bind: function bind (el, ref, vnode) {
	    var value = ref.value;

	    vnode = locateNode(vnode);
	    var transition = vnode.data && vnode.data.transition;
	    var originalDisplay = el.__vOriginalDisplay =
	      el.style.display === 'none' ? '' : el.style.display;
	    if (value && transition && !isIE9) {
	      vnode.data.show = true;
	      enter(vnode, function () {
	        el.style.display = originalDisplay;
	      });
	    } else {
	      el.style.display = value ? originalDisplay : 'none';
	    }
	  },

	  update: function update (el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;

	    /* istanbul ignore if */
	    if (value === oldValue) { return }
	    vnode = locateNode(vnode);
	    var transition = vnode.data && vnode.data.transition;
	    if (transition && !isIE9) {
	      vnode.data.show = true;
	      if (value) {
	        enter(vnode, function () {
	          el.style.display = el.__vOriginalDisplay;
	        });
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  },

	  unbind: function unbind (
	    el,
	    binding,
	    vnode,
	    oldVnode,
	    isDestroy
	  ) {
	    if (!isDestroy) {
	      el.style.display = el.__vOriginalDisplay;
	    }
	  }
	};

	var platformDirectives = {
	  model: model,
	  show: show
	};

	/*  */

	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)

	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String
	};

	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild (vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children))
	  } else {
	    return vnode
	  }
	}

	function extractTransitionData (comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1].fn;
	  }
	  return data
	}

	function placeholder (h, rawChild) {
	  return /\d-keep-alive$/.test(rawChild.tag)
	    ? h('keep-alive')
	    : null
	}

	function hasParentTransition (vnode) {
	  while ((vnode = vnode.parent)) {
	    if (vnode.data.transition) {
	      return true
	    }
	  }
	}

	function isSameChild (child, oldChild) {
	  return oldChild.key === child.key && oldChild.tag === child.tag
	}

	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	  render: function render (h) {
	    var this$1 = this;

	    var children = this.$slots.default;
	    if (!children) {
	      return
	    }

	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) { return c.tag; });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return
	    }

	    // warn multiple elements
	    if ("development" !== 'production' && children.length > 1) {
	      warn(
	        '<transition> can only be used on a single element. Use ' +
	        '<transition-group> for lists.',
	        this.$parent
	      );
	    }

	    var mode = this.mode;

	    // warn invalid mode
	    if ("development" !== 'production' &&
	        mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn(
	        'invalid <transition> mode: ' + mode,
	        this.$parent
	      );
	    }

	    var rawChild = children[0];

	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild
	    }

	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild
	    }

	    if (this._leaving) {
	      return placeholder(h, rawChild)
	    }

	    var key = child.key = child.key == null || child.isStatic
	      ? ("__v" + (child.tag + this._uid) + "__")
	      : child.key;
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);

	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
	      child.data.show = true;
	    }

	    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        }, key);
	        return placeholder(h, rawChild)
	      } else if (mode === 'in-out') {
	        var delayedLeave;
	        var performLeave = function () { delayedLeave(); };
	        mergeVNodeHook(data, 'afterEnter', performLeave, key);
	        mergeVNodeHook(data, 'enterCancelled', performLeave, key);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        }, key);
	      }
	    }

	    return rawChild
	  }
	};

	/*  */

	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.

	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final disired state. This way in the second pass removed
	// nodes will remain where they should be.

	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);

	delete props.mode;

	var TransitionGroup = {
	  props: props,

	  render: function render (h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);

	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c
	          ;(c.data || (c.data = {})).transition = transitionData;
	        } else {
	          var opts = c.componentOptions;
	          var name = opts
	            ? (opts.Ctor.options.name || opts.tag)
	            : c.tag;
	          warn(("<transition-group> children must be keyed: <" + name + ">"));
	        }
	      }
	    }

	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }

	    return h(tag, null, children)
	  },

	  beforeUpdate: function beforeUpdate () {
	    // force removing pass
	    this.__patch__(
	      this._vnode,
	      this.kept,
	      false, // hydrating
	      true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },

	  updated: function updated () {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return
	    }

	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);

	    // force reflow to put everything in position
	    var f = document.body.offsetHeight; // eslint-disable-line

	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },

	  methods: {
	    hasMove: function hasMove (el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false
	      }
	      if (this._hasMove != null) {
	        return this._hasMove
	      }
	      addTransitionClass(el, moveClass);
	      var info = getTransitionInfo(el);
	      removeTransitionClass(el, moveClass);
	      return (this._hasMove = info.hasTransform)
	    }
	  }
	};

	function callPendingCbs (c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}

	function recordPosition (c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}

	function applyTranslation (c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}

	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};

	/*  */

	// install platform specific utils
	Vue$3.config.isUnknownElement = isUnknownElement;
	Vue$3.config.isReservedTag = isReservedTag;
	Vue$3.config.getTagNamespace = getTagNamespace;
	Vue$3.config.mustUseProp = mustUseProp;

	// install platform runtime directives & components
	extend(Vue$3.options.directives, platformDirectives);
	extend(Vue$3.options.components, platformComponents);

	// install platform patch function
	Vue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;

	// wrap mount
	Vue$3.prototype.$mount = function (
	  el,
	  hydrating
	) {
	  el = el && inBrowser ? query(el) : undefined;
	  return this._mount(el, hydrating)
	};

	if ("development" !== 'production' &&
	    inBrowser && typeof console !== 'undefined') {
	  console[console.info ? 'info' : 'log'](
	    "You are running Vue in development mode.\n" +
	    "Make sure to turn on production mode when deploying for production.\n" +
	    "See more tips at https://vuejs.org/guide/deployment.html"
	  );
	}

	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$3);
	    } else if (
	      "development" !== 'production' &&
	      inBrowser && !isEdge && /Chrome\/\d+/.test(window.navigator.userAgent)
	    ) {
	      console[console.info ? 'info' : 'log'](
	        'Download the Vue Devtools extension for a better development experience:\n' +
	        'https://github.com/vuejs/vue-devtools'
	      );
	    }
	  }
	}, 0);

	/*  */

	// check whether current browser encodes a char inside attribute values
	function shouldDecode (content, encoded) {
	  var div = document.createElement('div');
	  div.innerHTML = "<div a=\"" + content + "\">";
	  return div.innerHTML.indexOf(encoded) > 0
	}

	// #3663
	// IE encodes newlines inside attribute values while other browsers don't
	var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

	/*  */

	var decoder;

	function decode (html) {
	  decoder = decoder || document.createElement('div');
	  decoder.innerHTML = html;
	  return decoder.textContent
	}

	/*  */

	var isUnaryTag = makeMap(
	  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
	  'link,meta,param,source,track,wbr',
	  true
	);

	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap(
	  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
	  true
	);

	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap(
	  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
	  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
	  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
	  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
	  'title,tr,track',
	  true
	);

	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */

	/*!
	 * HTML Parser By John Resig (ejohn.org)
	 * Modified by Juriy "kangax" Zaytsev
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 */

	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/;
	var singleAttrAssign = /(?:=)/;
	var singleAttrValues = [
	  // attr value double quotes
	  /"([^"]*)"+/.source,
	  // attr value, single quotes
	  /'([^']*)'+/.source,
	  // attr value, no quotes
	  /([^\s"'=<>`]+)/.source
	];
	var attribute = new RegExp(
	  '^\\s*' + singleAttrIdentifier.source +
	  '(?:\\s*(' + singleAttrAssign.source + ')' +
	  '\\s*(?:' + singleAttrValues.join('|') + '))?'
	);

	// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	// but for Vue templates we can enforce a simple charset
	var ncname = '[a-zA-Z_][\\w\\-\\.]*';
	var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
	var startTagOpen = new RegExp('^<' + qnameCapture);
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
	var doctype = /^<!DOCTYPE [^>]+>/i;
	var comment = /^<!--/;
	var conditionalComment = /^<!\[/;

	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function (m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});

	// Special Elements (can contain anything)
	var isScriptOrStyle = makeMap('script,style', true);
	var hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };
	var isSpecialTag = function (tag, isSFC, stack) {
	  if (isScriptOrStyle(tag)) {
	    return true
	  }
	  if (isSFC && stack.length === 1) {
	    // top-level template that has no pre-processor
	    if (tag === 'template' && !stack[0].attrs.some(hasLang)) {
	      return false
	    } else {
	      return true
	    }
	  }
	  return false
	};

	var reCache = {};

	var ltRE = /&lt;/g;
	var gtRE = /&gt;/g;
	var nlRE = /&#10;/g;
	var ampRE = /&amp;/g;
	var quoteRE = /&quot;/g;

	function decodeAttr (value, shouldDecodeNewlines) {
	  if (shouldDecodeNewlines) {
	    value = value.replace(nlRE, '\n');
	  }
	  return value
	    .replace(ltRE, '<')
	    .replace(gtRE, '>')
	    .replace(ampRE, '&')
	    .replace(quoteRE, '"')
	}

	function parseHTML (html, options) {
	  var stack = [];
	  var expectHTML = options.expectHTML;
	  var isUnaryTag$$1 = options.isUnaryTag || no;
	  var index = 0;
	  var last, lastTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a script or style element
	    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (comment.test(html)) {
	          var commentEnd = html.indexOf('-->');

	          if (commentEnd >= 0) {
	            advance(commentEnd + 3);
	            continue
	          }
	        }

	        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (conditionalComment.test(html)) {
	          var conditionalEnd = html.indexOf(']>');

	          if (conditionalEnd >= 0) {
	            advance(conditionalEnd + 2);
	            continue
	          }
	        }

	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          advance(doctypeMatch[0].length);
	          continue
	        }

	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          var curIndex = index;
	          advance(endTagMatch[0].length);
	          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);
	          continue
	        }

	        // Start tag:
	        var startTagMatch = parseStartTag();
	        if (startTagMatch) {
	          handleStartTag(startTagMatch);
	          continue
	        }
	      }

	      var text = (void 0), rest$1 = (void 0), next = (void 0);
	      if (textEnd > 0) {
	        rest$1 = html.slice(textEnd);
	        while (
	          !endTag.test(rest$1) &&
	          !startTagOpen.test(rest$1) &&
	          !comment.test(rest$1) &&
	          !conditionalComment.test(rest$1)
	        ) {
	          // < in plain text, be forgiving and treat it as text
	          next = rest$1.indexOf('<', 1);
	          if (next < 0) { break }
	          textEnd += next;
	          rest$1 = html.slice(textEnd);
	        }
	        text = html.substring(0, textEnd);
	        advance(textEnd);
	      }

	      if (textEnd < 0) {
	        text = html;
	        html = '';
	      }

	      if (options.chars && text) {
	        options.chars(text);
	      }
	    } else {
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
	      var endTagLength = 0;
	      var rest = html.replace(reStackedTag, function (all, text, endTag) {
	        endTagLength = endTag.length;
	        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
	          text = text
	            .replace(/<!--([\s\S]*?)-->/g, '$1')
	            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }
	        if (options.chars) {
	          options.chars(text);
	        }
	        return ''
	      });
	      index += html.length - rest.length;
	      html = rest;
	      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);
	    }

	    if (html === last && options.chars) {
	      options.chars(html);
	      break
	    }
	  }

	  // Clean up any remaining tags
	  parseEndTag();

	  function advance (n) {
	    index += n;
	    html = html.substring(n);
	  }

	  function parseStartTag () {
	    var start = html.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: [],
	        start: index
	      };
	      advance(start[0].length);
	      var end, attr;
	      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	        advance(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        advance(end[0].length);
	        match.end = index;
	        return match
	      }
	    }
	  }

	  function handleStartTag (match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;

	    if (expectHTML) {
	      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	        parseEndTag('', lastTag);
	      }
	      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
	        parseEndTag('', tagName);
	      }
	    }

	    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

	    var l = match.attrs.length;
	    var attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      var args = match.attrs[i];
	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') { delete args[3]; }
	        if (args[4] === '') { delete args[4]; }
	        if (args[5] === '') { delete args[5]; }
	      }
	      var value = args[3] || args[4] || args[5] || '';
	      attrs[i] = {
	        name: args[1],
	        value: decodeAttr(
	          value,
	          options.shouldDecodeNewlines
	        )
	      };
	    }

	    if (!unary) {
	      stack.push({ tag: tagName, attrs: attrs });
	      lastTag = tagName;
	      unarySlash = '';
	    }

	    if (options.start) {
	      options.start(tagName, attrs, unary, match.start, match.end);
	    }
	  }

	  function parseEndTag (tag, tagName, start, end) {
	    var pos;
	    if (start == null) { start = index; }
	    if (end == null) { end = index; }

	    // Find the closest opened tag of the same type
	    if (tagName) {
	      var needle = tagName.toLowerCase();
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].tag.toLowerCase() === needle) {
	          break
	        }
	      }
	    } else {
	      // If no tag name is provided, clean shop
	      pos = 0;
	    }

	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (options.end) {
	          options.end(stack[i].tag, start, end);
	        }
	      }

	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    } else if (tagName.toLowerCase() === 'br') {
	      if (options.start) {
	        options.start(tagName, [], true, start, end);
	      }
	    } else if (tagName.toLowerCase() === 'p') {
	      if (options.start) {
	        options.start(tagName, [], false, start, end);
	      }
	      if (options.end) {
	        options.end(tagName, start, end);
	      }
	    }
	  }
	}

	/*  */

	function parseFilters (exp) {
	  var inSingle = false;
	  var inDouble = false;
	  var inTemplateString = false;
	  var inRegex = false;
	  var curly = 0;
	  var square = 0;
	  var paren = 0;
	  var lastFilterIndex = 0;
	  var c, prev, i, expression, filters;

	  for (i = 0; i < exp.length; i++) {
	    prev = c;
	    c = exp.charCodeAt(i);
	    if (inSingle) {
	      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
	    } else if (inDouble) {
	      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
	    } else if (inTemplateString) {
	      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
	    } else if (inRegex) {
	      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
	    } else if (
	      c === 0x7C && // pipe
	      exp.charCodeAt(i + 1) !== 0x7C &&
	      exp.charCodeAt(i - 1) !== 0x7C &&
	      !curly && !square && !paren
	    ) {
	      if (expression === undefined) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        expression = exp.slice(0, i).trim();
	      } else {
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22: inDouble = true; break         // "
	        case 0x27: inSingle = true; break         // '
	        case 0x60: inTemplateString = true; break // `
	        case 0x28: paren++; break                 // (
	        case 0x29: paren--; break                 // )
	        case 0x5B: square++; break                // [
	        case 0x5D: square--; break                // ]
	        case 0x7B: curly++; break                 // {
	        case 0x7D: curly--; break                 // }
	      }
	      if (c === 0x2f) { // /
	        var j = i - 1;
	        var p = (void 0);
	        // find first non-whitespace prev char
	        for (; j >= 0; j--) {
	          p = exp.charAt(j);
	          if (p !== ' ') { break }
	        }
	        if (!p || !/[\w$]/.test(p)) {
	          inRegex = true;
	        }
	      }
	    }
	  }

	  if (expression === undefined) {
	    expression = exp.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }

	  function pushFilter () {
	    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
	    lastFilterIndex = i + 1;
	  }

	  if (filters) {
	    for (i = 0; i < filters.length; i++) {
	      expression = wrapFilter(expression, filters[i]);
	    }
	  }

	  return expression
	}

	function wrapFilter (exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return ("_f(\"" + filter + "\")(" + exp + ")")
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return ("_f(\"" + name + "\")(" + exp + "," + args)
	  }
	}

	/*  */

	var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
	var regexEscapeRE = /[-.*+?^${}()|[\]/\\]/g;

	var buildRegex = cached(function (delimiters) {
	  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
	  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
	  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
	});

	function parseText (
	  text,
	  delimiters
	) {
	  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	  if (!tagRE.test(text)) {
	    return
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index;
	  while ((match = tagRE.exec(text))) {
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	    }
	    // tag token
	    var exp = parseFilters(match[1].trim());
	    tokens.push(("_s(" + exp + ")"));
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push(JSON.stringify(text.slice(lastIndex)));
	  }
	  return tokens.join('+')
	}

	/*  */

	function baseWarn (msg) {
	  console.error(("[Vue parser]: " + msg));
	}

	function pluckModuleFunction (
	  modules,
	  key
	) {
	  return modules
	    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
	    : []
	}

	function addProp (el, name, value) {
	  (el.props || (el.props = [])).push({ name: name, value: value });
	}

	function addAttr (el, name, value) {
	  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
	}

	function addDirective (
	  el,
	  name,
	  rawName,
	  value,
	  arg,
	  modifiers
	) {
	  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
	}

	function addHandler (
	  el,
	  name,
	  value,
	  modifiers,
	  important
	) {
	  // check capture modifier
	  if (modifiers && modifiers.capture) {
	    delete modifiers.capture;
	    name = '!' + name; // mark the event as captured
	  }
	  if (modifiers && modifiers.once) {
	    delete modifiers.once;
	    name = '~' + name; // mark the event as once
	  }
	  var events;
	  if (modifiers && modifiers.native) {
	    delete modifiers.native;
	    events = el.nativeEvents || (el.nativeEvents = {});
	  } else {
	    events = el.events || (el.events = {});
	  }
	  var newHandler = { value: value, modifiers: modifiers };
	  var handlers = events[name];
	  /* istanbul ignore if */
	  if (Array.isArray(handlers)) {
	    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
	  } else if (handlers) {
	    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
	  } else {
	    events[name] = newHandler;
	  }
	}

	function getBindingAttr (
	  el,
	  name,
	  getStatic
	) {
	  var dynamicValue =
	    getAndRemoveAttr(el, ':' + name) ||
	    getAndRemoveAttr(el, 'v-bind:' + name);
	  if (dynamicValue != null) {
	    return parseFilters(dynamicValue)
	  } else if (getStatic !== false) {
	    var staticValue = getAndRemoveAttr(el, name);
	    if (staticValue != null) {
	      return JSON.stringify(staticValue)
	    }
	  }
	}

	function getAndRemoveAttr (el, name) {
	  var val;
	  if ((val = el.attrsMap[name]) != null) {
	    var list = el.attrsList;
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].name === name) {
	        list.splice(i, 1);
	        break
	      }
	    }
	  }
	  return val
	}

	var len;
	var str;
	var chr;
	var index$1;
	var expressionPos;
	var expressionEndPos;

	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */

	function parseModel (val) {
	  str = val;
	  len = str.length;
	  index$1 = expressionPos = expressionEndPos = 0;

	  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
	    return {
	      exp: val,
	      idx: null
	    }
	  }

	  while (!eof()) {
	    chr = next();
	    /* istanbul ignore if */
	    if (isStringStart(chr)) {
	      parseString(chr);
	    } else if (chr === 0x5B) {
	      parseBracket(chr);
	    }
	  }

	  return {
	    exp: val.substring(0, expressionPos),
	    idx: val.substring(expressionPos + 1, expressionEndPos)
	  }
	}

	function next () {
	  return str.charCodeAt(++index$1)
	}

	function eof () {
	  return index$1 >= len
	}

	function isStringStart (chr) {
	  return chr === 0x22 || chr === 0x27
	}

	function parseBracket (chr) {
	  var inBracket = 1;
	  expressionPos = index$1;
	  while (!eof()) {
	    chr = next();
	    if (isStringStart(chr)) {
	      parseString(chr);
	      continue
	    }
	    if (chr === 0x5B) { inBracket++; }
	    if (chr === 0x5D) { inBracket--; }
	    if (inBracket === 0) {
	      expressionEndPos = index$1;
	      break
	    }
	  }
	}

	function parseString (chr) {
	  var stringQuote = chr;
	  while (!eof()) {
	    chr = next();
	    if (chr === stringQuote) {
	      break
	    }
	  }
	}

	/*  */

	var dirRE = /^v-|^@|^:/;
	var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
	var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
	var bindRE = /^:|^v-bind:/;
	var onRE = /^@|^v-on:/;
	var argRE = /:(.*)$/;
	var modifierRE = /\.[^.]+/g;

	var decodeHTMLCached = cached(decode);

	// configurable state
	var warn$1;
	var platformGetTagNamespace;
	var platformMustUseProp;
	var platformIsPreTag;
	var preTransforms;
	var transforms;
	var postTransforms;
	var delimiters;

	/**
	 * Convert HTML string to AST.
	 */
	function parse (
	  template,
	  options
	) {
	  warn$1 = options.warn || baseWarn;
	  platformGetTagNamespace = options.getTagNamespace || no;
	  platformMustUseProp = options.mustUseProp || no;
	  platformIsPreTag = options.isPreTag || no;
	  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
	  transforms = pluckModuleFunction(options.modules, 'transformNode');
	  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
	  delimiters = options.delimiters;
	  var stack = [];
	  var preserveWhitespace = options.preserveWhitespace !== false;
	  var root;
	  var currentParent;
	  var inVPre = false;
	  var inPre = false;
	  var warned = false;
	  parseHTML(template, {
	    expectHTML: options.expectHTML,
	    isUnaryTag: options.isUnaryTag,
	    shouldDecodeNewlines: options.shouldDecodeNewlines,
	    start: function start (tag, attrs, unary) {
	      // check namespace.
	      // inherit parent ns if there is one
	      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

	      // handle IE svg bug
	      /* istanbul ignore if */
	      if (isIE && ns === 'svg') {
	        attrs = guardIESVGBug(attrs);
	      }

	      var element = {
	        type: 1,
	        tag: tag,
	        attrsList: attrs,
	        attrsMap: makeAttrsMap(attrs),
	        parent: currentParent,
	        children: []
	      };
	      if (ns) {
	        element.ns = ns;
	      }

	      if (isForbiddenTag(element) && !isServerRendering()) {
	        element.forbidden = true;
	        "development" !== 'production' && warn$1(
	          'Templates should only be responsible for mapping the state to the ' +
	          'UI. Avoid placing tags with side-effects in your templates, such as ' +
	          "<" + tag + ">" + ', as they will not be parsed.'
	        );
	      }

	      // apply pre-transforms
	      for (var i = 0; i < preTransforms.length; i++) {
	        preTransforms[i](element, options);
	      }

	      if (!inVPre) {
	        processPre(element);
	        if (element.pre) {
	          inVPre = true;
	        }
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = true;
	      }
	      if (inVPre) {
	        processRawAttrs(element);
	      } else {
	        processFor(element);
	        processIf(element);
	        processOnce(element);
	        processKey(element);

	        // determine whether this is a plain element after
	        // removing structural attributes
	        element.plain = !element.key && !attrs.length;

	        processRef(element);
	        processSlot(element);
	        processComponent(element);
	        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
	          transforms[i$1](element, options);
	        }
	        processAttrs(element);
	      }

	      function checkRootConstraints (el) {
	        if ("development" !== 'production' && !warned) {
	          if (el.tag === 'slot' || el.tag === 'template') {
	            warned = true;
	            warn$1(
	              "Cannot use <" + (el.tag) + "> as component root element because it may " +
	              'contain multiple nodes:\n' + template
	            );
	          }
	          if (el.attrsMap.hasOwnProperty('v-for')) {
	            warned = true;
	            warn$1(
	              'Cannot use v-for on stateful component root element because ' +
	              'it renders multiple elements:\n' + template
	            );
	          }
	        }
	      }

	      // tree management
	      if (!root) {
	        root = element;
	        checkRootConstraints(root);
	      } else if (!stack.length) {
	        // allow root elements with v-if, v-else-if and v-else
	        if (root.if && (element.elseif || element.else)) {
	          checkRootConstraints(element);
	          addIfCondition(root, {
	            exp: element.elseif,
	            block: element
	          });
	        } else if ("development" !== 'production' && !warned) {
	          warned = true;
	          warn$1(
	            "Component template should contain exactly one root element:" +
	            "\n\n" + template + "\n\n" +
	            "If you are using v-if on multiple elements, " +
	            "use v-else-if to chain them instead."
	          );
	        }
	      }
	      if (currentParent && !element.forbidden) {
	        if (element.elseif || element.else) {
	          processIfConditions(element, currentParent);
	        } else if (element.slotScope) { // scoped slot
	          currentParent.plain = false;
	          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	        } else {
	          currentParent.children.push(element);
	          element.parent = currentParent;
	        }
	      }
	      if (!unary) {
	        currentParent = element;
	        stack.push(element);
	      }
	      // apply post-transforms
	      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
	        postTransforms[i$2](element, options);
	      }
	    },

	    end: function end () {
	      // remove trailing whitespace
	      var element = stack[stack.length - 1];
	      var lastNode = element.children[element.children.length - 1];
	      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
	        element.children.pop();
	      }
	      // pop stack
	      stack.length -= 1;
	      currentParent = stack[stack.length - 1];
	      // check pre state
	      if (element.pre) {
	        inVPre = false;
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = false;
	      }
	    },

	    chars: function chars (text) {
	      if (!currentParent) {
	        if ("development" !== 'production' && !warned && text === template) {
	          warned = true;
	          warn$1(
	            'Component template requires a root element, rather than just text:\n\n' + template
	          );
	        }
	        return
	      }
	      // IE textarea placeholder bug
	      /* istanbul ignore if */
	      if (isIE &&
	          currentParent.tag === 'textarea' &&
	          currentParent.attrsMap.placeholder === text) {
	        return
	      }
	      var children = currentParent.children;
	      text = inPre || text.trim()
	        ? decodeHTMLCached(text)
	        // only preserve whitespace if its not right after a starting tag
	        : preserveWhitespace && children.length ? ' ' : '';
	      if (text) {
	        var expression;
	        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
	          children.push({
	            type: 2,
	            expression: expression,
	            text: text
	          });
	        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {
	          currentParent.children.push({
	            type: 3,
	            text: text
	          });
	        }
	      }
	    }
	  });
	  return root
	}

	function processPre (el) {
	  if (getAndRemoveAttr(el, 'v-pre') != null) {
	    el.pre = true;
	  }
	}

	function processRawAttrs (el) {
	  var l = el.attrsList.length;
	  if (l) {
	    var attrs = el.attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      attrs[i] = {
	        name: el.attrsList[i].name,
	        value: JSON.stringify(el.attrsList[i].value)
	      };
	    }
	  } else if (!el.pre) {
	    // non root node in pre blocks with no attributes
	    el.plain = true;
	  }
	}

	function processKey (el) {
	  var exp = getBindingAttr(el, 'key');
	  if (exp) {
	    if ("development" !== 'production' && el.tag === 'template') {
	      warn$1("<template> cannot be keyed. Place the key on real elements instead.");
	    }
	    el.key = exp;
	  }
	}

	function processRef (el) {
	  var ref = getBindingAttr(el, 'ref');
	  if (ref) {
	    el.ref = ref;
	    el.refInFor = checkInFor(el);
	  }
	}

	function processFor (el) {
	  var exp;
	  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
	    var inMatch = exp.match(forAliasRE);
	    if (!inMatch) {
	      "development" !== 'production' && warn$1(
	        ("Invalid v-for expression: " + exp)
	      );
	      return
	    }
	    el.for = inMatch[2].trim();
	    var alias = inMatch[1].trim();
	    var iteratorMatch = alias.match(forIteratorRE);
	    if (iteratorMatch) {
	      el.alias = iteratorMatch[1].trim();
	      el.iterator1 = iteratorMatch[2].trim();
	      if (iteratorMatch[3]) {
	        el.iterator2 = iteratorMatch[3].trim();
	      }
	    } else {
	      el.alias = alias;
	    }
	  }
	}

	function processIf (el) {
	  var exp = getAndRemoveAttr(el, 'v-if');
	  if (exp) {
	    el.if = exp;
	    addIfCondition(el, {
	      exp: exp,
	      block: el
	    });
	  } else {
	    if (getAndRemoveAttr(el, 'v-else') != null) {
	      el.else = true;
	    }
	    var elseif = getAndRemoveAttr(el, 'v-else-if');
	    if (elseif) {
	      el.elseif = elseif;
	    }
	  }
	}

	function processIfConditions (el, parent) {
	  var prev = findPrevElement(parent.children);
	  if (prev && prev.if) {
	    addIfCondition(prev, {
	      exp: el.elseif,
	      block: el
	    });
	  } else {
	    warn$1(
	      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
	      "used on element <" + (el.tag) + "> without corresponding v-if."
	    );
	  }
	}

	function findPrevElement (children) {
	  var i = children.length;
	  while (i--) {
	    if (children[i].type === 1) {
	      return children[i]
	    } else {
	      if ("development" !== 'production' && children[i].text !== ' ') {
	        warn$1(
	          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
	          "will be ignored."
	        );
	      }
	      children.pop();
	    }
	  }
	}

	function addIfCondition (el, condition) {
	  if (!el.ifConditions) {
	    el.ifConditions = [];
	  }
	  el.ifConditions.push(condition);
	}

	function processOnce (el) {
	  var once = getAndRemoveAttr(el, 'v-once');
	  if (once != null) {
	    el.once = true;
	  }
	}

	function processSlot (el) {
	  if (el.tag === 'slot') {
	    el.slotName = getBindingAttr(el, 'name');
	    if ("development" !== 'production' && el.key) {
	      warn$1(
	        "`key` does not work on <slot> because slots are abstract outlets " +
	        "and can possibly expand into multiple elements. " +
	        "Use the key on a wrapping element instead."
	      );
	    }
	  } else {
	    var slotTarget = getBindingAttr(el, 'slot');
	    if (slotTarget) {
	      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
	    }
	    if (el.tag === 'template') {
	      el.slotScope = getAndRemoveAttr(el, 'scope');
	    }
	  }
	}

	function processComponent (el) {
	  var binding;
	  if ((binding = getBindingAttr(el, 'is'))) {
	    el.component = binding;
	  }
	  if (getAndRemoveAttr(el, 'inline-template') != null) {
	    el.inlineTemplate = true;
	  }
	}

	function processAttrs (el) {
	  var list = el.attrsList;
	  var i, l, name, rawName, value, arg, modifiers, isProp;
	  for (i = 0, l = list.length; i < l; i++) {
	    name = rawName = list[i].name;
	    value = list[i].value;
	    if (dirRE.test(name)) {
	      // mark element as dynamic
	      el.hasBindings = true;
	      // modifiers
	      modifiers = parseModifiers(name);
	      if (modifiers) {
	        name = name.replace(modifierRE, '');
	      }
	      if (bindRE.test(name)) { // v-bind
	        name = name.replace(bindRE, '');
	        value = parseFilters(value);
	        isProp = false;
	        if (modifiers) {
	          if (modifiers.prop) {
	            isProp = true;
	            name = camelize(name);
	            if (name === 'innerHtml') { name = 'innerHTML'; }
	          }
	          if (modifiers.camel) {
	            name = camelize(name);
	          }
	        }
	        if (isProp || platformMustUseProp(el.tag, name)) {
	          addProp(el, name, value);
	        } else {
	          addAttr(el, name, value);
	        }
	      } else if (onRE.test(name)) { // v-on
	        name = name.replace(onRE, '');
	        addHandler(el, name, value, modifiers);
	      } else { // normal directives
	        name = name.replace(dirRE, '');
	        // parse arg
	        var argMatch = name.match(argRE);
	        if (argMatch && (arg = argMatch[1])) {
	          name = name.slice(0, -(arg.length + 1));
	        }
	        addDirective(el, name, rawName, value, arg, modifiers);
	        if ("development" !== 'production' && name === 'model') {
	          checkForAliasModel(el, value);
	        }
	      }
	    } else {
	      // literal attribute
	      {
	        var expression = parseText(value, delimiters);
	        if (expression) {
	          warn$1(
	            name + "=\"" + value + "\": " +
	            'Interpolation inside attributes has been removed. ' +
	            'Use v-bind or the colon shorthand instead. For example, ' +
	            'instead of <div id="{{ val }}">, use <div :id="val">.'
	          );
	        }
	      }
	      addAttr(el, name, JSON.stringify(value));
	      // #4530 also bind special attributes as props even if they are static
	      // so that patches between dynamic/static are consistent
	      if (platformMustUseProp(el.tag, name)) {
	        if (name === 'value') {
	          addProp(el, name, JSON.stringify(value));
	        } else {
	          addProp(el, name, 'true');
	        }
	      }
	    }
	  }
	}

	function checkInFor (el) {
	  var parent = el;
	  while (parent) {
	    if (parent.for !== undefined) {
	      return true
	    }
	    parent = parent.parent;
	  }
	  return false
	}

	function parseModifiers (name) {
	  var match = name.match(modifierRE);
	  if (match) {
	    var ret = {};
	    match.forEach(function (m) { ret[m.slice(1)] = true; });
	    return ret
	  }
	}

	function makeAttrsMap (attrs) {
	  var map = {};
	  for (var i = 0, l = attrs.length; i < l; i++) {
	    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
	      warn$1('duplicate attribute: ' + attrs[i].name);
	    }
	    map[attrs[i].name] = attrs[i].value;
	  }
	  return map
	}

	function isForbiddenTag (el) {
	  return (
	    el.tag === 'style' ||
	    (el.tag === 'script' && (
	      !el.attrsMap.type ||
	      el.attrsMap.type === 'text/javascript'
	    ))
	  )
	}

	var ieNSBug = /^xmlns:NS\d+/;
	var ieNSPrefix = /^NS\d+:/;

	/* istanbul ignore next */
	function guardIESVGBug (attrs) {
	  var res = [];
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (!ieNSBug.test(attr.name)) {
	      attr.name = attr.name.replace(ieNSPrefix, '');
	      res.push(attr);
	    }
	  }
	  return res
	}

	function checkForAliasModel (el, value) {
	  var _el = el;
	  while (_el) {
	    if (_el.for && _el.alias === value) {
	      warn$1(
	        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
	        "You are binding v-model directly to a v-for iteration alias. " +
	        "This will not be able to modify the v-for source array because " +
	        "writing to the alias is like modifying a function local variable. " +
	        "Consider using an array of objects and use v-model on an object property instead."
	      );
	    }
	    _el = _el.parent;
	  }
	}

	/*  */

	var isStaticKey;
	var isPlatformReservedTag;

	var genStaticKeysCached = cached(genStaticKeys$1);

	/**
	 * Goal of the optimizer: walk the generated template AST tree
	 * and detect sub-trees that are purely static, i.e. parts of
	 * the DOM that never needs to change.
	 *
	 * Once we detect these sub-trees, we can:
	 *
	 * 1. Hoist them into constants, so that we no longer need to
	 *    create fresh nodes for them on each re-render;
	 * 2. Completely skip them in the patching process.
	 */
	function optimize (root, options) {
	  if (!root) { return }
	  isStaticKey = genStaticKeysCached(options.staticKeys || '');
	  isPlatformReservedTag = options.isReservedTag || no;
	  // first pass: mark all non-static nodes.
	  markStatic(root);
	  // second pass: mark static roots.
	  markStaticRoots(root, false);
	}

	function genStaticKeys$1 (keys) {
	  return makeMap(
	    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
	    (keys ? ',' + keys : '')
	  )
	}

	function markStatic (node) {
	  node.static = isStatic(node);
	  if (node.type === 1) {
	    // do not make component slot content static. this avoids
	    // 1. components not able to mutate slot nodes
	    // 2. static slot content fails for hot-reloading
	    if (
	      !isPlatformReservedTag(node.tag) &&
	      node.tag !== 'slot' &&
	      node.attrsMap['inline-template'] == null
	    ) {
	      return
	    }
	    for (var i = 0, l = node.children.length; i < l; i++) {
	      var child = node.children[i];
	      markStatic(child);
	      if (!child.static) {
	        node.static = false;
	      }
	    }
	  }
	}

	function markStaticRoots (node, isInFor) {
	  if (node.type === 1) {
	    if (node.static || node.once) {
	      node.staticInFor = isInFor;
	    }
	    // For a node to qualify as a static root, it should have children that
	    // are not just static text. Otherwise the cost of hoisting out will
	    // outweigh the benefits and it's better off to just always render it fresh.
	    if (node.static && node.children.length && !(
	      node.children.length === 1 &&
	      node.children[0].type === 3
	    )) {
	      node.staticRoot = true;
	      return
	    } else {
	      node.staticRoot = false;
	    }
	    if (node.children) {
	      for (var i = 0, l = node.children.length; i < l; i++) {
	        markStaticRoots(node.children[i], isInFor || !!node.for);
	      }
	    }
	    if (node.ifConditions) {
	      walkThroughConditionsBlocks(node.ifConditions, isInFor);
	    }
	  }
	}

	function walkThroughConditionsBlocks (conditionBlocks, isInFor) {
	  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
	    markStaticRoots(conditionBlocks[i].block, isInFor);
	  }
	}

	function isStatic (node) {
	  if (node.type === 2) { // expression
	    return false
	  }
	  if (node.type === 3) { // text
	    return true
	  }
	  return !!(node.pre || (
	    !node.hasBindings && // no dynamic bindings
	    !node.if && !node.for && // not v-if or v-for or v-else
	    !isBuiltInTag(node.tag) && // not a built-in
	    isPlatformReservedTag(node.tag) && // not a component
	    !isDirectChildOfTemplateFor(node) &&
	    Object.keys(node).every(isStaticKey)
	  ))
	}

	function isDirectChildOfTemplateFor (node) {
	  while (node.parent) {
	    node = node.parent;
	    if (node.tag !== 'template') {
	      return false
	    }
	    if (node.for) {
	      return true
	    }
	  }
	  return false
	}

	/*  */

	var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
	var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  'delete': [8, 46]
	};

	var modifierCode = {
	  stop: '$event.stopPropagation();',
	  prevent: '$event.preventDefault();',
	  self: 'if($event.target !== $event.currentTarget)return;',
	  ctrl: 'if(!$event.ctrlKey)return;',
	  shift: 'if(!$event.shiftKey)return;',
	  alt: 'if(!$event.altKey)return;',
	  meta: 'if(!$event.metaKey)return;'
	};

	function genHandlers (events, native) {
	  var res = native ? 'nativeOn:{' : 'on:{';
	  for (var name in events) {
	    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
	  }
	  return res.slice(0, -1) + '}'
	}

	function genHandler (
	  name,
	  handler
	) {
	  if (!handler) {
	    return 'function(){}'
	  } else if (Array.isArray(handler)) {
	    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
	  } else if (!handler.modifiers) {
	    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)
	      ? handler.value
	      : ("function($event){" + (handler.value) + "}")
	  } else {
	    var code = '';
	    var keys = [];
	    for (var key in handler.modifiers) {
	      if (modifierCode[key]) {
	        code += modifierCode[key];
	      } else {
	        keys.push(key);
	      }
	    }
	    if (keys.length) {
	      code = genKeyFilter(keys) + code;
	    }
	    var handlerCode = simplePathRE.test(handler.value)
	      ? handler.value + '($event)'
	      : handler.value;
	    return 'function($event){' + code + handlerCode + '}'
	  }
	}

	function genKeyFilter (keys) {
	  return ("if(" + (keys.map(genFilterCode).join('&&')) + ")return;")
	}

	function genFilterCode (key) {
	  var keyVal = parseInt(key, 10);
	  if (keyVal) {
	    return ("$event.keyCode!==" + keyVal)
	  }
	  var alias = keyCodes[key];
	  return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
	}

	/*  */

	function bind$2 (el, dir) {
	  el.wrapData = function (code) {
	    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
	  };
	}

	/*  */

	var baseDirectives = {
	  bind: bind$2,
	  cloak: noop
	};

	/*  */

	// configurable state
	var warn$2;
	var transforms$1;
	var dataGenFns;
	var platformDirectives$1;
	var isPlatformReservedTag$1;
	var staticRenderFns;
	var onceCount;
	var currentOptions;

	function generate (
	  ast,
	  options
	) {
	  // save previous staticRenderFns so generate calls can be nested
	  var prevStaticRenderFns = staticRenderFns;
	  var currentStaticRenderFns = staticRenderFns = [];
	  var prevOnceCount = onceCount;
	  onceCount = 0;
	  currentOptions = options;
	  warn$2 = options.warn || baseWarn;
	  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
	  dataGenFns = pluckModuleFunction(options.modules, 'genData');
	  platformDirectives$1 = options.directives || {};
	  isPlatformReservedTag$1 = options.isReservedTag || no;
	  var code = ast ? genElement(ast) : '_c("div")';
	  staticRenderFns = prevStaticRenderFns;
	  onceCount = prevOnceCount;
	  return {
	    render: ("with(this){return " + code + "}"),
	    staticRenderFns: currentStaticRenderFns
	  }
	}

	function genElement (el) {
	  if (el.staticRoot && !el.staticProcessed) {
	    return genStatic(el)
	  } else if (el.once && !el.onceProcessed) {
	    return genOnce(el)
	  } else if (el.for && !el.forProcessed) {
	    return genFor(el)
	  } else if (el.if && !el.ifProcessed) {
	    return genIf(el)
	  } else if (el.tag === 'template' && !el.slotTarget) {
	    return genChildren(el) || 'void 0'
	  } else if (el.tag === 'slot') {
	    return genSlot(el)
	  } else {
	    // component or element
	    var code;
	    if (el.component) {
	      code = genComponent(el.component, el);
	    } else {
	      var data = el.plain ? undefined : genData(el);

	      var children = el.inlineTemplate ? null : genChildren(el, true);
	      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
	    }
	    // module transforms
	    for (var i = 0; i < transforms$1.length; i++) {
	      code = transforms$1[i](el, code);
	    }
	    return code
	  }
	}

	// hoist static sub-trees out
	function genStatic (el) {
	  el.staticProcessed = true;
	  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
	  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
	}

	// v-once
	function genOnce (el) {
	  el.onceProcessed = true;
	  if (el.if && !el.ifProcessed) {
	    return genIf(el)
	  } else if (el.staticInFor) {
	    var key = '';
	    var parent = el.parent;
	    while (parent) {
	      if (parent.for) {
	        key = parent.key;
	        break
	      }
	      parent = parent.parent;
	    }
	    if (!key) {
	      "development" !== 'production' && warn$2(
	        "v-once can only be used inside v-for that is keyed. "
	      );
	      return genElement(el)
	    }
	    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
	  } else {
	    return genStatic(el)
	  }
	}

	function genIf (el) {
	  el.ifProcessed = true; // avoid recursion
	  return genIfConditions(el.ifConditions.slice())
	}

	function genIfConditions (conditions) {
	  if (!conditions.length) {
	    return '_e()'
	  }

	  var condition = conditions.shift();
	  if (condition.exp) {
	    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions)))
	  } else {
	    return ("" + (genTernaryExp(condition.block)))
	  }

	  // v-if with v-once should generate code like (a)?_m(0):_m(1)
	  function genTernaryExp (el) {
	    return el.once ? genOnce(el) : genElement(el)
	  }
	}

	function genFor (el) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
	  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
	  el.forProcessed = true; // avoid recursion
	  return "_l((" + exp + ")," +
	    "function(" + alias + iterator1 + iterator2 + "){" +
	      "return " + (genElement(el)) +
	    '})'
	}

	function genData (el) {
	  var data = '{';

	  // directives first.
	  // directives may mutate the el's other properties before they are generated.
	  var dirs = genDirectives(el);
	  if (dirs) { data += dirs + ','; }

	  // key
	  if (el.key) {
	    data += "key:" + (el.key) + ",";
	  }
	  // ref
	  if (el.ref) {
	    data += "ref:" + (el.ref) + ",";
	  }
	  if (el.refInFor) {
	    data += "refInFor:true,";
	  }
	  // pre
	  if (el.pre) {
	    data += "pre:true,";
	  }
	  // record original tag name for components using "is" attribute
	  if (el.component) {
	    data += "tag:\"" + (el.tag) + "\",";
	  }
	  // module data generation functions
	  for (var i = 0; i < dataGenFns.length; i++) {
	    data += dataGenFns[i](el);
	  }
	  // attributes
	  if (el.attrs) {
	    data += "attrs:{" + (genProps(el.attrs)) + "},";
	  }
	  // DOM props
	  if (el.props) {
	    data += "domProps:{" + (genProps(el.props)) + "},";
	  }
	  // event handlers
	  if (el.events) {
	    data += (genHandlers(el.events)) + ",";
	  }
	  if (el.nativeEvents) {
	    data += (genHandlers(el.nativeEvents, true)) + ",";
	  }
	  // slot target
	  if (el.slotTarget) {
	    data += "slot:" + (el.slotTarget) + ",";
	  }
	  // scoped slots
	  if (el.scopedSlots) {
	    data += (genScopedSlots(el.scopedSlots)) + ",";
	  }
	  // inline-template
	  if (el.inlineTemplate) {
	    var inlineTemplate = genInlineTemplate(el);
	    if (inlineTemplate) {
	      data += inlineTemplate + ",";
	    }
	  }
	  data = data.replace(/,$/, '') + '}';
	  // v-bind data wrap
	  if (el.wrapData) {
	    data = el.wrapData(data);
	  }
	  return data
	}

	function genDirectives (el) {
	  var dirs = el.directives;
	  if (!dirs) { return }
	  var res = 'directives:[';
	  var hasRuntime = false;
	  var i, l, dir, needRuntime;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    dir = dirs[i];
	    needRuntime = true;
	    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
	    if (gen) {
	      // compile-time directive that manipulates AST.
	      // returns true if it also needs a runtime counterpart.
	      needRuntime = !!gen(el, dir, warn$2);
	    }
	    if (needRuntime) {
	      hasRuntime = true;
	      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
	    }
	  }
	  if (hasRuntime) {
	    return res.slice(0, -1) + ']'
	  }
	}

	function genInlineTemplate (el) {
	  var ast = el.children[0];
	  if ("development" !== 'production' && (
	    el.children.length > 1 || ast.type !== 1
	  )) {
	    warn$2('Inline-template components must have exactly one child element.');
	  }
	  if (ast.type === 1) {
	    var inlineRenderFns = generate(ast, currentOptions);
	    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
	  }
	}

	function genScopedSlots (slots) {
	  return ("scopedSlots:{" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + "}")
	}

	function genScopedSlot (key, el) {
	  return key + ":function(" + (String(el.attrsMap.scope)) + "){" +
	    "return " + (el.tag === 'template'
	      ? genChildren(el) || 'void 0'
	      : genElement(el)) + "}"
	}

	function genChildren (el, checkSkip) {
	  var children = el.children;
	  if (children.length) {
	    var el$1 = children[0];
	    // optimize single v-for
	    if (children.length === 1 &&
	        el$1.for &&
	        el$1.tag !== 'template' &&
	        el$1.tag !== 'slot') {
	      return genElement(el$1)
	    }
	    var normalizationType = getNormalizationType(children);
	    return ("[" + (children.map(genNode).join(',')) + "]" + (checkSkip
	        ? normalizationType ? ("," + normalizationType) : ''
	        : ''))
	  }
	}

	// determine the normalization needed for the children array.
	// 0: no normalization needed
	// 1: simple normalization needed (possible 1-level deep nested array)
	// 2: full normalization needed
	function getNormalizationType (children) {
	  var res = 0;
	  for (var i = 0; i < children.length; i++) {
	    var el = children[i];
	    if (needsNormalization(el) ||
	        (el.if && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
	      res = 2;
	      break
	    }
	    if (maybeComponent(el) ||
	        (el.if && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
	      res = 1;
	    }
	  }
	  return res
	}

	function needsNormalization (el) {
	  return el.for || el.tag === 'template' || el.tag === 'slot'
	}

	function maybeComponent (el) {
	  return el.type === 1 && !isPlatformReservedTag$1(el.tag)
	}

	function genNode (node) {
	  if (node.type === 1) {
	    return genElement(node)
	  } else {
	    return genText(node)
	  }
	}

	function genText (text) {
	  return ("_v(" + (text.type === 2
	    ? text.expression // no need for () because already wrapped in _s()
	    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
	}

	function genSlot (el) {
	  var slotName = el.slotName || '"default"';
	  var children = genChildren(el);
	  var res = "_t(" + slotName + (children ? ("," + children) : '');
	  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
	  var bind$$1 = el.attrsMap['v-bind'];
	  if ((attrs || bind$$1) && !children) {
	    res += ",null";
	  }
	  if (attrs) {
	    res += "," + attrs;
	  }
	  if (bind$$1) {
	    res += (attrs ? '' : ',null') + "," + bind$$1;
	  }
	  return res + ')'
	}

	// componentName is el.component, take it as argument to shun flow's pessimistic refinement
	function genComponent (componentName, el) {
	  var children = el.inlineTemplate ? null : genChildren(el, true);
	  return ("_c(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
	}

	function genProps (props) {
	  var res = '';
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
	  }
	  return res.slice(0, -1)
	}

	// #3895, #4268
	function transformSpecialNewlines (text) {
	  return text
	    .replace(/\u2028/g, '\\u2028')
	    .replace(/\u2029/g, '\\u2029')
	}

	/*  */

	/**
	 * Compile a template.
	 */
	function compile$1 (
	  template,
	  options
	) {
	  var ast = parse(template.trim(), options);
	  optimize(ast, options);
	  var code = generate(ast, options);
	  return {
	    ast: ast,
	    render: code.render,
	    staticRenderFns: code.staticRenderFns
	  }
	}

	/*  */

	// operators like typeof, instanceof and in are allowed
	var prohibitedKeywordRE = new RegExp('\\b' + (
	  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
	  'super,throw,while,yield,delete,export,import,return,switch,default,' +
	  'extends,finally,continue,debugger,function,arguments'
	).split(',').join('\\b|\\b') + '\\b');
	// check valid identifier for v-for
	var identRE = /[A-Za-z_$][\w$]*/;
	// strip strings in expressions
	var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

	// detect problematic expressions in a template
	function detectErrors (ast) {
	  var errors = [];
	  if (ast) {
	    checkNode(ast, errors);
	  }
	  return errors
	}

	function checkNode (node, errors) {
	  if (node.type === 1) {
	    for (var name in node.attrsMap) {
	      if (dirRE.test(name)) {
	        var value = node.attrsMap[name];
	        if (value) {
	          if (name === 'v-for') {
	            checkFor(node, ("v-for=\"" + value + "\""), errors);
	          } else {
	            checkExpression(value, (name + "=\"" + value + "\""), errors);
	          }
	        }
	      }
	    }
	    if (node.children) {
	      for (var i = 0; i < node.children.length; i++) {
	        checkNode(node.children[i], errors);
	      }
	    }
	  } else if (node.type === 2) {
	    checkExpression(node.expression, node.text, errors);
	  }
	}

	function checkFor (node, text, errors) {
	  checkExpression(node.for || '', text, errors);
	  checkIdentifier(node.alias, 'v-for alias', text, errors);
	  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
	  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
	}

	function checkIdentifier (ident, type, text, errors) {
	  if (typeof ident === 'string' && !identRE.test(ident)) {
	    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
	  }
	}

	function checkExpression (exp, text, errors) {
	  try {
	    new Function(("return " + exp));
	  } catch (e) {
	    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
	    if (keywordMatch) {
	      errors.push(
	        "- avoid using JavaScript keyword as property name: " +
	        "\"" + (keywordMatch[0]) + "\" in expression " + text
	      );
	    } else {
	      errors.push(("- invalid expression: " + text));
	    }
	  }
	}

	/*  */

	function transformNode (el, options) {
	  var warn = options.warn || baseWarn;
	  var staticClass = getAndRemoveAttr(el, 'class');
	  if ("development" !== 'production' && staticClass) {
	    var expression = parseText(staticClass, options.delimiters);
	    if (expression) {
	      warn(
	        "class=\"" + staticClass + "\": " +
	        'Interpolation inside attributes has been removed. ' +
	        'Use v-bind or the colon shorthand instead. For example, ' +
	        'instead of <div class="{{ val }}">, use <div :class="val">.'
	      );
	    }
	  }
	  if (staticClass) {
	    el.staticClass = JSON.stringify(staticClass);
	  }
	  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
	  if (classBinding) {
	    el.classBinding = classBinding;
	  }
	}

	function genData$1 (el) {
	  var data = '';
	  if (el.staticClass) {
	    data += "staticClass:" + (el.staticClass) + ",";
	  }
	  if (el.classBinding) {
	    data += "class:" + (el.classBinding) + ",";
	  }
	  return data
	}

	var klass$1 = {
	  staticKeys: ['staticClass'],
	  transformNode: transformNode,
	  genData: genData$1
	};

	/*  */

	function transformNode$1 (el, options) {
	  var warn = options.warn || baseWarn;
	  var staticStyle = getAndRemoveAttr(el, 'style');
	  if (staticStyle) {
	    /* istanbul ignore if */
	    {
	      var expression = parseText(staticStyle, options.delimiters);
	      if (expression) {
	        warn(
	          "style=\"" + staticStyle + "\": " +
	          'Interpolation inside attributes has been removed. ' +
	          'Use v-bind or the colon shorthand instead. For example, ' +
	          'instead of <div style="{{ val }}">, use <div :style="val">.'
	        );
	      }
	    }
	    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
	  }

	  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
	  if (styleBinding) {
	    el.styleBinding = styleBinding;
	  }
	}

	function genData$2 (el) {
	  var data = '';
	  if (el.staticStyle) {
	    data += "staticStyle:" + (el.staticStyle) + ",";
	  }
	  if (el.styleBinding) {
	    data += "style:(" + (el.styleBinding) + "),";
	  }
	  return data
	}

	var style$1 = {
	  staticKeys: ['staticStyle'],
	  transformNode: transformNode$1,
	  genData: genData$2
	};

	var modules$1 = [
	  klass$1,
	  style$1
	];

	/*  */

	var warn$3;

	function model$1 (
	  el,
	  dir,
	  _warn
	) {
	  warn$3 = _warn;
	  var value = dir.value;
	  var modifiers = dir.modifiers;
	  var tag = el.tag;
	  var type = el.attrsMap.type;
	  {
	    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
	    if (tag === 'input' && dynamicType) {
	      warn$3(
	        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
	        "v-model does not support dynamic input types. Use v-if branches instead."
	      );
	    }
	  }
	  if (tag === 'select') {
	    genSelect(el, value, modifiers);
	  } else if (tag === 'input' && type === 'checkbox') {
	    genCheckboxModel(el, value, modifiers);
	  } else if (tag === 'input' && type === 'radio') {
	    genRadioModel(el, value, modifiers);
	  } else {
	    genDefaultModel(el, value, modifiers);
	  }
	  // ensure runtime directive metadata
	  return true
	}

	function genCheckboxModel (
	  el,
	  value,
	  modifiers
	) {
	  if ("development" !== 'production' &&
	    el.attrsMap.checked != null) {
	    warn$3(
	      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
	      "inline checked attributes will be ignored when using v-model. " +
	      'Declare initial values in the component\'s data option instead.'
	    );
	  }
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
	  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
	  addProp(el, 'checked',
	    "Array.isArray(" + value + ")" +
	      "?_i(" + value + "," + valueBinding + ")>-1" + (
	        trueValueBinding === 'true'
	          ? (":(" + value + ")")
	          : (":_q(" + value + "," + trueValueBinding + ")")
	      )
	  );
	  addHandler(el, 'change',
	    "var $$a=" + value + "," +
	        '$$el=$event.target,' +
	        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
	    'if(Array.isArray($$a)){' +
	      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
	          '$$i=_i($$a,$$v);' +
	      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
	      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
	    "}else{" + value + "=$$c}",
	    null, true
	  );
	}

	function genRadioModel (
	    el,
	    value,
	    modifiers
	) {
	  if ("development" !== 'production' &&
	    el.attrsMap.checked != null) {
	    warn$3(
	      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
	      "inline checked attributes will be ignored when using v-model. " +
	      'Declare initial values in the component\'s data option instead.'
	    );
	  }
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
	  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
	  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
	}

	function genDefaultModel (
	  el,
	  value,
	  modifiers
	) {
	  {
	    if (el.tag === 'input' && el.attrsMap.value) {
	      warn$3(
	        "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
	        'inline value attributes will be ignored when using v-model. ' +
	        'Declare initial values in the component\'s data option instead.'
	      );
	    }
	    if (el.tag === 'textarea' && el.children.length) {
	      warn$3(
	        "<textarea v-model=\"" + value + "\">:\n" +
	        'inline content inside <textarea> will be ignored when using v-model. ' +
	        'Declare initial values in the component\'s data option instead.'
	      );
	    }
	  }

	  var type = el.attrsMap.type;
	  var ref = modifiers || {};
	  var lazy = ref.lazy;
	  var number = ref.number;
	  var trim = ref.trim;
	  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
	  var needCompositionGuard = !lazy && type !== 'range';
	  var isNative = el.tag === 'input' || el.tag === 'textarea';

	  var valueExpression = isNative
	    ? ("$event.target.value" + (trim ? '.trim()' : ''))
	    : trim ? "(typeof $event === 'string' ? $event.trim() : $event)" : "$event";
	  valueExpression = number || type === 'number'
	    ? ("_n(" + valueExpression + ")")
	    : valueExpression;

	  var code = genAssignmentCode(value, valueExpression);
	  if (isNative && needCompositionGuard) {
	    code = "if($event.target.composing)return;" + code;
	  }

	  // inputs with type="file" are read only and setting the input's
	  // value will throw an error.
	  if ("development" !== 'production' &&
	      type === 'file') {
	    warn$3(
	      "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
	      "File inputs are read only. Use a v-on:change listener instead."
	    );
	  }

	  addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
	  addHandler(el, event, code, null, true);
	  if (trim || number || type === 'number') {
	    addHandler(el, 'blur', '$forceUpdate()');
	  }
	}

	function genSelect (
	    el,
	    value,
	    modifiers
	) {
	  {
	    el.children.some(checkOptionWarning);
	  }

	  var number = modifiers && modifiers.number;
	  var assignment = "Array.prototype.filter" +
	    ".call($event.target.options,function(o){return o.selected})" +
	    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
	    "return " + (number ? '_n(val)' : 'val') + "})" +
	    (el.attrsMap.multiple == null ? '[0]' : '');

	  var code = genAssignmentCode(value, assignment);
	  addHandler(el, 'change', code, null, true);
	}

	function checkOptionWarning (option) {
	  if (option.type === 1 &&
	    option.tag === 'option' &&
	    option.attrsMap.selected != null) {
	    warn$3(
	      "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
	      'inline selected attributes on <option> will be ignored when using v-model. ' +
	      'Declare initial values in the component\'s data option instead.'
	    );
	    return true
	  }
	  return false
	}

	function genAssignmentCode (value, assignment) {
	  var modelRs = parseModel(value);
	  if (modelRs.idx === null) {
	    return (value + "=" + assignment)
	  } else {
	    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
	      "if (!Array.isArray($$exp)){" +
	        value + "=" + assignment + "}" +
	      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
	  }
	}

	/*  */

	function text (el, dir) {
	  if (dir.value) {
	    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
	  }
	}

	/*  */

	function html (el, dir) {
	  if (dir.value) {
	    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
	  }
	}

	var directives$1 = {
	  model: model$1,
	  text: text,
	  html: html
	};

	/*  */

	var cache = Object.create(null);

	var baseOptions = {
	  expectHTML: true,
	  modules: modules$1,
	  staticKeys: genStaticKeys(modules$1),
	  directives: directives$1,
	  isReservedTag: isReservedTag,
	  isUnaryTag: isUnaryTag,
	  mustUseProp: mustUseProp,
	  getTagNamespace: getTagNamespace,
	  isPreTag: isPreTag
	};

	function compile$$1 (
	  template,
	  options
	) {
	  options = options
	    ? extend(extend({}, baseOptions), options)
	    : baseOptions;
	  return compile$1(template, options)
	}

	function compileToFunctions (
	  template,
	  options,
	  vm
	) {
	  var _warn = (options && options.warn) || warn;
	  // detect possible CSP restriction
	  /* istanbul ignore if */
	  {
	    try {
	      new Function('return 1');
	    } catch (e) {
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        _warn(
	          'It seems you are using the standalone build of Vue.js in an ' +
	          'environment with Content Security Policy that prohibits unsafe-eval. ' +
	          'The template compiler cannot work in this environment. Consider ' +
	          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
	          'templates into render functions.'
	        );
	      }
	    }
	  }
	  var key = options && options.delimiters
	    ? String(options.delimiters) + template
	    : template;
	  if (cache[key]) {
	    return cache[key]
	  }
	  var res = {};
	  var compiled = compile$$1(template, options);
	  res.render = makeFunction(compiled.render);
	  var l = compiled.staticRenderFns.length;
	  res.staticRenderFns = new Array(l);
	  for (var i = 0; i < l; i++) {
	    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
	  }
	  {
	    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
	      _warn(
	        "failed to compile template:\n\n" + template + "\n\n" +
	        detectErrors(compiled.ast).join('\n') +
	        '\n\n',
	        vm
	      );
	    }
	  }
	  return (cache[key] = res)
	}

	function makeFunction (code) {
	  try {
	    return new Function(code)
	  } catch (e) {
	    return noop
	  }
	}

	/*  */

	var idToTemplate = cached(function (id) {
	  var el = query(id);
	  return el && el.innerHTML
	});

	var mount = Vue$3.prototype.$mount;
	Vue$3.prototype.$mount = function (
	  el,
	  hydrating
	) {
	  el = el && query(el);

	  /* istanbul ignore if */
	  if (el === document.body || el === document.documentElement) {
	    "development" !== 'production' && warn(
	      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
	    );
	    return this
	  }

	  var options = this.$options;
	  // resolve template/el and convert to render function
	  if (!options.render) {
	    var template = options.template;
	    if (template) {
	      if (typeof template === 'string') {
	        if (template.charAt(0) === '#') {
	          template = idToTemplate(template);
	          /* istanbul ignore if */
	          if ("development" !== 'production' && !template) {
	            warn(
	              ("Template element not found or is empty: " + (options.template)),
	              this
	            );
	          }
	        }
	      } else if (template.nodeType) {
	        template = template.innerHTML;
	      } else {
	        {
	          warn('invalid template option:' + template, this);
	        }
	        return this
	      }
	    } else if (el) {
	      template = getOuterHTML(el);
	    }
	    if (template) {
	      var ref = compileToFunctions(template, {
	        warn: warn,
	        shouldDecodeNewlines: shouldDecodeNewlines,
	        delimiters: options.delimiters
	      }, this);
	      var render = ref.render;
	      var staticRenderFns = ref.staticRenderFns;
	      options.render = render;
	      options.staticRenderFns = staticRenderFns;
	    }
	  }
	  return mount.call(this, el, hydrating)
	};

	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 */
	function getOuterHTML (el) {
	  if (el.outerHTML) {
	    return el.outerHTML
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML
	  }
	}

	Vue$3.compile = compileToFunctions;

	return Vue$3;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	  * vue-router v2.1.1
	  * (c) 2016 Evan You
	  * @license MIT
	  */
	'use strict';

	var View = {
	  name: 'router-view',
	  functional: true,
	  props: {
	    name: {
	      type: String,
	      default: 'default'
	    }
	  },
	  render: function render (h, ref) {
	    var props = ref.props;
	    var children = ref.children;
	    var parent = ref.parent;
	    var data = ref.data;

	    data.routerView = true

	    var route = parent.$route
	    var cache = parent._routerViewCache || (parent._routerViewCache = {})
	    var depth = 0
	    var inactive = false

	    while (parent) {
	      if (parent.$vnode && parent.$vnode.data.routerView) {
	        depth++
	      }
	      if (parent._inactive) {
	        inactive = true
	      }
	      parent = parent.$parent
	    }

	    data.routerViewDepth = depth
	    var matched = route.matched[depth]
	    if (!matched) {
	      return h()
	    }

	    var name = props.name
	    var component = inactive
	      ? cache[name]
	      : (cache[name] = matched.components[name])

	    if (!inactive) {
	      var hooks = data.hook || (data.hook = {})
	      hooks.init = function (vnode) {
	        matched.instances[name] = vnode.child
	      }
	      hooks.prepatch = function (oldVnode, vnode) {
	        matched.instances[name] = vnode.child
	      }
	      hooks.destroy = function (vnode) {
	        if (matched.instances[name] === vnode.child) {
	          matched.instances[name] = undefined
	        }
	      }
	    }

	    return h(component, data, children)
	  }
	}

	/*  */

	function assert (condition, message) {
	  if (!condition) {
	    throw new Error(("[vue-router] " + message))
	  }
	}

	function warn (condition, message) {
	  if (!condition) {
	    typeof console !== 'undefined' && console.warn(("[vue-router] " + message))
	  }
	}

	/*  */

	var encode = encodeURIComponent
	var decode = decodeURIComponent

	function resolveQuery (
	  query,
	  extraQuery
	) {
	  if ( extraQuery === void 0 ) extraQuery = {};

	  if (query) {
	    var parsedQuery
	    try {
	      parsedQuery = parseQuery(query)
	    } catch (e) {
	      process.env.NODE_ENV !== 'production' && warn(false, e.message)
	      parsedQuery = {}
	    }
	    for (var key in extraQuery) {
	      parsedQuery[key] = extraQuery[key]
	    }
	    return parsedQuery
	  } else {
	    return extraQuery
	  }
	}

	function parseQuery (query) {
	  var res = {}

	  query = query.trim().replace(/^(\?|#|&)/, '')

	  if (!query) {
	    return res
	  }

	  query.split('&').forEach(function (param) {
	    var parts = param.replace(/\+/g, ' ').split('=')
	    var key = decode(parts.shift())
	    var val = parts.length > 0
	      ? decode(parts.join('='))
	      : null

	    if (res[key] === undefined) {
	      res[key] = val
	    } else if (Array.isArray(res[key])) {
	      res[key].push(val)
	    } else {
	      res[key] = [res[key], val]
	    }
	  })

	  return res
	}

	function stringifyQuery (obj) {
	  var res = obj ? Object.keys(obj).map(function (key) {
	    var val = obj[key]

	    if (val === undefined) {
	      return ''
	    }

	    if (val === null) {
	      return encode(key)
	    }

	    if (Array.isArray(val)) {
	      var result = []
	      val.slice().forEach(function (val2) {
	        if (val2 === undefined) {
	          return
	        }
	        if (val2 === null) {
	          result.push(encode(key))
	        } else {
	          result.push(encode(key) + '=' + encode(val2))
	        }
	      })
	      return result.join('&')
	    }

	    return encode(key) + '=' + encode(val)
	  }).filter(function (x) { return x.length > 0; }).join('&') : null
	  return res ? ("?" + res) : ''
	}

	/*  */

	function createRoute (
	  record,
	  location,
	  redirectedFrom
	) {
	  var route = {
	    name: location.name || (record && record.name),
	    meta: (record && record.meta) || {},
	    path: location.path || '/',
	    hash: location.hash || '',
	    query: location.query || {},
	    params: location.params || {},
	    fullPath: getFullPath(location),
	    matched: record ? formatMatch(record) : []
	  }
	  if (redirectedFrom) {
	    route.redirectedFrom = getFullPath(redirectedFrom)
	  }
	  return Object.freeze(route)
	}

	// the starting route that represents the initial state
	var START = createRoute(null, {
	  path: '/'
	})

	function formatMatch (record) {
	  var res = []
	  while (record) {
	    res.unshift(record)
	    record = record.parent
	  }
	  return res
	}

	function getFullPath (ref) {
	  var path = ref.path;
	  var query = ref.query; if ( query === void 0 ) query = {};
	  var hash = ref.hash; if ( hash === void 0 ) hash = '';

	  return (path || '/') + stringifyQuery(query) + hash
	}

	var trailingSlashRE = /\/$/
	function isSameRoute (a, b) {
	  if (b === START) {
	    return a === b
	  } else if (!b) {
	    return false
	  } else if (a.path && b.path) {
	    return (
	      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
	      a.hash === b.hash &&
	      isObjectEqual(a.query, b.query)
	    )
	  } else if (a.name && b.name) {
	    return (
	      a.name === b.name &&
	      a.hash === b.hash &&
	      isObjectEqual(a.query, b.query) &&
	      isObjectEqual(a.params, b.params)
	    )
	  } else {
	    return false
	  }
	}

	function isObjectEqual (a, b) {
	  if ( a === void 0 ) a = {};
	  if ( b === void 0 ) b = {};

	  var aKeys = Object.keys(a)
	  var bKeys = Object.keys(b)
	  if (aKeys.length !== bKeys.length) {
	    return false
	  }
	  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })
	}

	function isIncludedRoute (current, target) {
	  return (
	    current.path.indexOf(target.path.replace(/\/$/, '')) === 0 &&
	    (!target.hash || current.hash === target.hash) &&
	    queryIncludes(current.query, target.query)
	  )
	}

	function queryIncludes (current, target) {
	  for (var key in target) {
	    if (!(key in current)) {
	      return false
	    }
	  }
	  return true
	}

	/*  */

	// work around weird flow bug
	var toTypes = [String, Object]

	var Link = {
	  name: 'router-link',
	  props: {
	    to: {
	      type: toTypes,
	      required: true
	    },
	    tag: {
	      type: String,
	      default: 'a'
	    },
	    exact: Boolean,
	    append: Boolean,
	    replace: Boolean,
	    activeClass: String,
	    event: {
	      type: [String, Array],
	      default: 'click'
	    }
	  },
	  render: function render (h) {
	    var this$1 = this;

	    var router = this.$router
	    var current = this.$route
	    var ref = router.resolve(this.to, current, this.append);
	    var normalizedTo = ref.normalizedTo;
	    var resolved = ref.resolved;
	    var href = ref.href;
	    var classes = {}
	    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active'
	    var compareTarget = normalizedTo.path ? createRoute(null, normalizedTo) : resolved
	    classes[activeClass] = this.exact
	      ? isSameRoute(current, compareTarget)
	      : isIncludedRoute(current, compareTarget)

	    var handler = function (e) {
	      if (guardEvent(e)) {
	        if (this$1.replace) {
	          router.replace(normalizedTo)
	        } else {
	          router.push(normalizedTo)
	        }
	      }
	    }

	    var on = { click: guardEvent }
	    if (Array.isArray(this.event)) {
	      this.event.forEach(function (e) { on[e] = handler })
	    } else {
	      on[this.event] = handler
	    }

	    var data = {
	      class: classes
	    }

	    if (this.tag === 'a') {
	      data.on = on
	      data.attrs = { href: href }
	    } else {
	      // find the first <a> child and apply listener and href
	      var a = findAnchor(this.$slots.default)
	      if (a) {
	        // in case the <a> is a static node
	        a.isStatic = false
	        var extend = _Vue.util.extend
	        var aData = a.data = extend({}, a.data)
	        aData.on = on
	        var aAttrs = a.data.attrs = extend({}, a.data.attrs)
	        aAttrs.href = href
	      } else {
	        // doesn't have <a> child, apply listener to self
	        data.on = on
	      }
	    }

	    return h(this.tag, data, this.$slots.default)
	  }
	}

	function guardEvent (e) {
	  // don't redirect with control keys
	  /* istanbul ignore if */
	  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }
	  // don't redirect when preventDefault called
	  /* istanbul ignore if */
	  if (e.defaultPrevented) { return }
	  // don't redirect on right click
	  /* istanbul ignore if */
	  if (e.button !== 0) { return }
	  // don't redirect if `target="_blank"`
	  /* istanbul ignore if */
	  var target = e.target.getAttribute('target')
	  if (/\b_blank\b/i.test(target)) { return }

	  e.preventDefault()
	  return true
	}

	function findAnchor (children) {
	  if (children) {
	    var child
	    for (var i = 0; i < children.length; i++) {
	      child = children[i]
	      if (child.tag === 'a') {
	        return child
	      }
	      if (child.children && (child = findAnchor(child.children))) {
	        return child
	      }
	    }
	  }
	}

	var _Vue

	function install (Vue) {
	  if (install.installed) { return }
	  install.installed = true

	  _Vue = Vue

	  Object.defineProperty(Vue.prototype, '$router', {
	    get: function get () { return this.$root._router }
	  })

	  Object.defineProperty(Vue.prototype, '$route', {
	    get: function get$1 () { return this.$root._route }
	  })

	  Vue.mixin({
	    beforeCreate: function beforeCreate () {
	      if (this.$options.router) {
	        this._router = this.$options.router
	        this._router.init(this)
	        Vue.util.defineReactive(this, '_route', this._router.history.current)
	      }
	    }
	  })

	  Vue.component('router-view', View)
	  Vue.component('router-link', Link)

	  var strats = Vue.config.optionMergeStrategies
	  // use the same hook merging strategy for route hooks
	  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created
	}

	/*  */

	function resolvePath (
	  relative,
	  base,
	  append
	) {
	  if (relative.charAt(0) === '/') {
	    return relative
	  }

	  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {
	    return base + relative
	  }

	  var stack = base.split('/')

	  // remove trailing segment if:
	  // - not appending
	  // - appending to trailing slash (last segment is empty)
	  if (!append || !stack[stack.length - 1]) {
	    stack.pop()
	  }

	  // resolve relative path
	  var segments = relative.replace(/^\//, '').split('/')
	  for (var i = 0; i < segments.length; i++) {
	    var segment = segments[i]
	    if (segment === '.') {
	      continue
	    } else if (segment === '..') {
	      stack.pop()
	    } else {
	      stack.push(segment)
	    }
	  }

	  // ensure leading slash
	  if (stack[0] !== '') {
	    stack.unshift('')
	  }

	  return stack.join('/')
	}

	function parsePath (path) {
	  var hash = ''
	  var query = ''

	  var hashIndex = path.indexOf('#')
	  if (hashIndex >= 0) {
	    hash = path.slice(hashIndex)
	    path = path.slice(0, hashIndex)
	  }

	  var queryIndex = path.indexOf('?')
	  if (queryIndex >= 0) {
	    query = path.slice(queryIndex + 1)
	    path = path.slice(0, queryIndex)
	  }

	  return {
	    path: path,
	    query: query,
	    hash: hash
	  }
	}

	function cleanPath (path) {
	  return path.replace(/\/\//g, '/')
	}

	/*  */

	function createRouteMap (routes) {
	  var pathMap = Object.create(null)
	  var nameMap = Object.create(null)

	  routes.forEach(function (route) {
	    addRouteRecord(pathMap, nameMap, route)
	  })

	  return {
	    pathMap: pathMap,
	    nameMap: nameMap
	  }
	}

	function addRouteRecord (
	  pathMap,
	  nameMap,
	  route,
	  parent,
	  matchAs
	) {
	  var path = route.path;
	  var name = route.name;
	  if (process.env.NODE_ENV !== 'production') {
	    assert(path != null, "\"path\" is required in a route configuration.")
	    assert(
	      typeof route.component !== 'string',
	      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
	      "string id. Use an actual component instead."
	    )
	  }

	  var record = {
	    path: normalizePath(path, parent),
	    components: route.components || { default: route.component },
	    instances: {},
	    name: name,
	    parent: parent,
	    matchAs: matchAs,
	    redirect: route.redirect,
	    beforeEnter: route.beforeEnter,
	    meta: route.meta || {}
	  }

	  if (route.children) {
	    // Warn if route is named and has a default child route.
	    // If users navigate to this route by name, the default child will
	    // not be rendered (GH Issue #629)
	    if (process.env.NODE_ENV !== 'production') {
	      if (route.name && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
	        warn(false, ("Named Route '" + (route.name) + "' has a default child route.\n          When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), the default child route will not be rendered.\n          Remove the name from this route and use the name of the default child route for named links instead.")
	        )
	      }
	    }
	    route.children.forEach(function (child) {
	      addRouteRecord(pathMap, nameMap, child, record)
	    })
	  }

	  if (route.alias !== undefined) {
	    if (Array.isArray(route.alias)) {
	      route.alias.forEach(function (alias) {
	        addRouteRecord(pathMap, nameMap, { path: alias }, parent, record.path)
	      })
	    } else {
	      addRouteRecord(pathMap, nameMap, { path: route.alias }, parent, record.path)
	    }
	  }

	  if (!pathMap[record.path]) {
	    pathMap[record.path] = record
	  }
	  if (name) {
	    if (!nameMap[name]) {
	      nameMap[name] = record
	    } else if (process.env.NODE_ENV !== 'production') {
	      warn(false, ("Duplicate named routes definition: { name: \"" + name + "\", path: \"" + (record.path) + "\" }"))
	    }
	  }
	}

	function normalizePath (path, parent) {
	  path = path.replace(/\/$/, '')
	  if (path[0] === '/') { return path }
	  if (parent == null) { return path }
	  return cleanPath(((parent.path) + "/" + path))
	}

	var __moduleExports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};

	var isarray = __moduleExports

	/**
	 * Expose `pathToRegexp`.
	 */
	var index = pathToRegexp
	var parse_1 = parse
	var compile_1 = compile
	var tokensToFunction_1 = tokensToFunction
	var tokensToRegExp_1 = tokensToRegExp

	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
	  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
	  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
	].join('|'), 'g')

	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
	function parse (str, options) {
	  var tokens = []
	  var key = 0
	  var index = 0
	  var path = ''
	  var defaultDelimiter = options && options.delimiter || '/'
	  var res

	  while ((res = PATH_REGEXP.exec(str)) != null) {
	    var m = res[0]
	    var escaped = res[1]
	    var offset = res.index
	    path += str.slice(index, offset)
	    index = offset + m.length

	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1]
	      continue
	    }

	    var next = str[index]
	    var prefix = res[2]
	    var name = res[3]
	    var capture = res[4]
	    var group = res[5]
	    var modifier = res[6]
	    var asterisk = res[7]

	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path)
	      path = ''
	    }

	    var partial = prefix != null && next != null && next !== prefix
	    var repeat = modifier === '+' || modifier === '*'
	    var optional = modifier === '?' || modifier === '*'
	    var delimiter = res[2] || defaultDelimiter
	    var pattern = capture || group

	    tokens.push({
	      name: name || key++,
	      prefix: prefix || '',
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      partial: partial,
	      asterisk: !!asterisk,
	      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
	    })
	  }

	  // Match any characters still remaining.
	  if (index < str.length) {
	    path += str.substr(index)
	  }

	  // If the path exists, push it onto the end.
	  if (path) {
	    tokens.push(path)
	  }

	  return tokens
	}

	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
	function compile (str, options) {
	  return tokensToFunction(parse(str, options))
	}

	/**
	 * Prettier encoding of URI path segments.
	 *
	 * @param  {string}
	 * @return {string}
	 */
	function encodeURIComponentPretty (str) {
	  return encodeURI(str).replace(/[\/?#]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}

	/**
	 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
	 *
	 * @param  {string}
	 * @return {string}
	 */
	function encodeAsterisk (str) {
	  return encodeURI(str).replace(/[?#]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}

	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length)

	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
	    }
	  }

	  return function (obj, opts) {
	    var path = ''
	    var data = obj || {}
	    var options = opts || {}
	    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i]

	      if (typeof token === 'string') {
	        path += token

	        continue
	      }

	      var value = data[token.name]
	      var segment

	      if (value == null) {
	        if (token.optional) {
	          // Prepend partial segment prefixes.
	          if (token.partial) {
	            path += token.prefix
	          }

	          continue
	        } else {
	          throw new TypeError('Expected "' + token.name + '" to be defined')
	        }
	      }

	      if (isarray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
	        }

	        if (value.length === 0) {
	          if (token.optional) {
	            continue
	          } else {
	            throw new TypeError('Expected "' + token.name + '" to not be empty')
	          }
	        }

	        for (var j = 0; j < value.length; j++) {
	          segment = encode(value[j])

	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
	          }

	          path += (j === 0 ? token.prefix : token.delimiter) + segment
	        }

	        continue
	      }

	      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

	      if (!matches[i].test(segment)) {
	        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	      }

	      path += token.prefix + segment
	    }

	    return path
	  }
	}

	/**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
	}

	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$\/()])/g, '\\$1')
	}

	/**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {!RegExp} re
	 * @param  {Array}   keys
	 * @return {!RegExp}
	 */
	function attachKeys (re, keys) {
	  re.keys = keys
	  return re
	}

	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
	function flags (options) {
	  return options.sensitive ? '' : 'i'
	}

	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {!Array}  keys
	 * @return {!RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g)

	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        partial: false,
	        asterisk: false,
	        pattern: null
	      })
	    }
	  }

	  return attachKeys(path, keys)
	}

	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array}   keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = []

	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source)
	  }

	  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

	  return attachKeys(regexp, keys)
	}

	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {!Array}  keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  return tokensToRegExp(parse(path, options), keys, options)
	}

	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}          tokens
	 * @param  {(Array|Object)=} keys
	 * @param  {Object=}         options
	 * @return {!RegExp}
	 */
	function tokensToRegExp (tokens, keys, options) {
	  if (!isarray(keys)) {
	    options = /** @type {!Object} */ (keys || options)
	    keys = []
	  }

	  options = options || {}

	  var strict = options.strict
	  var end = options.end !== false
	  var route = ''

	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i]

	    if (typeof token === 'string') {
	      route += escapeString(token)
	    } else {
	      var prefix = escapeString(token.prefix)
	      var capture = '(?:' + token.pattern + ')'

	      keys.push(token)

	      if (token.repeat) {
	        capture += '(?:' + prefix + capture + ')*'
	      }

	      if (token.optional) {
	        if (!token.partial) {
	          capture = '(?:' + prefix + '(' + capture + '))?'
	        } else {
	          capture = prefix + '(' + capture + ')?'
	        }
	      } else {
	        capture = prefix + '(' + capture + ')'
	      }

	      route += capture
	    }
	  }

	  var delimiter = escapeString(options.delimiter || '/')
	  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

	  // In non-strict mode we allow a slash at the end of match. If the path to
	  // match already ends with a slash, we remove it for consistency. The slash
	  // is valid at the end of a path match, not in the middle. This is important
	  // in non-ending mode, where "/test/" shouldn't match "/test//route".
	  if (!strict) {
	    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
	  }

	  if (end) {
	    route += '$'
	  } else {
	    // In non-ending mode, we need the capturing groups to match as much as
	    // possible by using a positive lookahead to the end or next path segment.
	    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
	  }

	  return attachKeys(new RegExp('^' + route, flags(options)), keys)
	}

	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {(Array|Object)=}       keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  if (!isarray(keys)) {
	    options = /** @type {!Object} */ (keys || options)
	    keys = []
	  }

	  options = options || {}

	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, /** @type {!Array} */ (keys))
	  }

	  if (isarray(path)) {
	    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
	  }

	  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
	}

	index.parse = parse_1;
	index.compile = compile_1;
	index.tokensToFunction = tokensToFunction_1;
	index.tokensToRegExp = tokensToRegExp_1;

	/*  */

	var regexpCache = Object.create(null)

	function getRouteRegex (path) {
	  var hit = regexpCache[path]
	  var keys, regexp

	  if (hit) {
	    keys = hit.keys
	    regexp = hit.regexp
	  } else {
	    keys = []
	    regexp = index(path, keys)
	    regexpCache[path] = { keys: keys, regexp: regexp }
	  }

	  return { keys: keys, regexp: regexp }
	}

	var regexpCompileCache = Object.create(null)

	function fillParams (
	  path,
	  params,
	  routeMsg
	) {
	  try {
	    var filler =
	      regexpCompileCache[path] ||
	      (regexpCompileCache[path] = index.compile(path))
	    return filler(params || {}, { pretty: true })
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn(false, ("missing param for " + routeMsg + ": " + (e.message)))
	    }
	    return ''
	  }
	}

	/*  */

	function normalizeLocation (
	  raw,
	  current,
	  append
	) {
	  var next = typeof raw === 'string' ? { path: raw } : raw
	  // named target
	  if (next.name || next._normalized) {
	    return next
	  }

	  // relative params
	  if (!next.path && next.params && current) {
	    next = assign({}, next)
	    next._normalized = true
	    var params = assign(assign({}, current.params), next.params)
	    if (current.name) {
	      next.name = current.name
	      next.params = params
	    } else if (current.matched) {
	      var rawPath = current.matched[current.matched.length - 1].path
	      next.path = fillParams(rawPath, params, ("path " + (current.path)))
	    } else if (process.env.NODE_ENV !== 'production') {
	      warn(false, "relative params navigation requires a current route.")
	    }
	    return next
	  }

	  var parsedPath = parsePath(next.path || '')
	  var basePath = (current && current.path) || '/'
	  var path = parsedPath.path
	    ? resolvePath(parsedPath.path, basePath, append || next.append)
	    : (current && current.path) || '/'
	  var query = resolveQuery(parsedPath.query, next.query)
	  var hash = next.hash || parsedPath.hash
	  if (hash && hash.charAt(0) !== '#') {
	    hash = "#" + hash
	  }

	  return {
	    _normalized: true,
	    path: path,
	    query: query,
	    hash: hash
	  }
	}

	function assign (a, b) {
	  for (var key in b) {
	    a[key] = b[key]
	  }
	  return a
	}

	/*  */

	function createMatcher (routes) {
	  var ref = createRouteMap(routes);
	  var pathMap = ref.pathMap;
	  var nameMap = ref.nameMap;

	  function match (
	    raw,
	    currentRoute,
	    redirectedFrom
	  ) {
	    var location = normalizeLocation(raw, currentRoute)
	    var name = location.name;

	    if (name) {
	      var record = nameMap[name]
	      var paramNames = getRouteRegex(record.path).keys
	        .filter(function (key) { return !key.optional; })
	        .map(function (key) { return key.name; })

	      if (typeof location.params !== 'object') {
	        location.params = {}
	      }

	      if (currentRoute && typeof currentRoute.params === 'object') {
	        for (var key in currentRoute.params) {
	          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
	            location.params[key] = currentRoute.params[key]
	          }
	        }
	      }

	      if (record) {
	        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""))
	        return _createRoute(record, location, redirectedFrom)
	      }
	    } else if (location.path) {
	      location.params = {}
	      for (var path in pathMap) {
	        if (matchRoute(path, location.params, location.path)) {
	          return _createRoute(pathMap[path], location, redirectedFrom)
	        }
	      }
	    }
	    // no match
	    return _createRoute(null, location)
	  }

	  function redirect (
	    record,
	    location
	  ) {
	    var originalRedirect = record.redirect
	    var redirect = typeof originalRedirect === 'function'
	        ? originalRedirect(createRoute(record, location))
	        : originalRedirect

	    if (typeof redirect === 'string') {
	      redirect = { path: redirect }
	    }

	    if (!redirect || typeof redirect !== 'object') {
	      process.env.NODE_ENV !== 'production' && warn(
	        false, ("invalid redirect option: " + (JSON.stringify(redirect)))
	      )
	      return _createRoute(null, location)
	    }

	    var re = redirect
	    var name = re.name;
	    var path = re.path;
	    var query = location.query;
	    var hash = location.hash;
	    var params = location.params;
	    query = re.hasOwnProperty('query') ? re.query : query
	    hash = re.hasOwnProperty('hash') ? re.hash : hash
	    params = re.hasOwnProperty('params') ? re.params : params

	    if (name) {
	      // resolved named direct
	      var targetRecord = nameMap[name]
	      if (process.env.NODE_ENV !== 'production') {
	        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."))
	      }
	      return match({
	        _normalized: true,
	        name: name,
	        query: query,
	        hash: hash,
	        params: params
	      }, undefined, location)
	    } else if (path) {
	      // 1. resolve relative redirect
	      var rawPath = resolveRecordPath(path, record)
	      // 2. resolve params
	      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""))
	      // 3. rematch with existing query and hash
	      return match({
	        _normalized: true,
	        path: resolvedPath,
	        query: query,
	        hash: hash
	      }, undefined, location)
	    } else {
	      warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))))
	      return _createRoute(null, location)
	    }
	  }

	  function alias (
	    record,
	    location,
	    matchAs
	  ) {
	    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""))
	    var aliasedMatch = match({
	      _normalized: true,
	      path: aliasedPath
	    })
	    if (aliasedMatch) {
	      var matched = aliasedMatch.matched
	      var aliasedRecord = matched[matched.length - 1]
	      location.params = aliasedMatch.params
	      return _createRoute(aliasedRecord, location)
	    }
	    return _createRoute(null, location)
	  }

	  function _createRoute (
	    record,
	    location,
	    redirectedFrom
	  ) {
	    if (record && record.redirect) {
	      return redirect(record, redirectedFrom || location)
	    }
	    if (record && record.matchAs) {
	      return alias(record, location, record.matchAs)
	    }
	    return createRoute(record, location, redirectedFrom)
	  }

	  return match
	}

	function matchRoute (
	  path,
	  params,
	  pathname
	) {
	  var ref = getRouteRegex(path);
	  var regexp = ref.regexp;
	  var keys = ref.keys;
	  var m = pathname.match(regexp)

	  if (!m) {
	    return false
	  } else if (!params) {
	    return true
	  }

	  for (var i = 1, len = m.length; i < len; ++i) {
	    var key = keys[i - 1]
	    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i]
	    if (key) { params[key.name] = val }
	  }

	  return true
	}

	function resolveRecordPath (path, record) {
	  return resolvePath(path, record.parent ? record.parent.path : '/', true)
	}

	/*  */

	var inBrowser = typeof window !== 'undefined'

	var supportsHistory = inBrowser && (function () {
	  var ua = window.navigator.userAgent

	  if (
	    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
	    ua.indexOf('Mobile Safari') !== -1 &&
	    ua.indexOf('Chrome') === -1 &&
	    ua.indexOf('Windows Phone') === -1
	  ) {
	    return false
	  }

	  return window.history && 'pushState' in window.history
	})()

	/*  */

	function runQueue (queue, fn, cb) {
	  var step = function (index) {
	    if (index >= queue.length) {
	      cb()
	    } else {
	      if (queue[index]) {
	        fn(queue[index], function () {
	          step(index + 1)
	        })
	      } else {
	        step(index + 1)
	      }
	    }
	  }
	  step(0)
	}

	/*  */


	var History = function History (router, base) {
	  this.router = router
	  this.base = normalizeBase(base)
	  // start with a route object that stands for "nowhere"
	  this.current = START
	  this.pending = null
	};

	History.prototype.listen = function listen (cb) {
	  this.cb = cb
	};

	History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
	    var this$1 = this;

	  var route = this.router.match(location, this.current)
	  this.confirmTransition(route, function () {
	    this$1.updateRoute(route)
	    onComplete && onComplete(route)
	    this$1.ensureURL()
	  }, onAbort)
	};

	History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
	    var this$1 = this;

	  var current = this.current
	  var abort = function () { onAbort && onAbort() }
	  if (isSameRoute(route, current)) {
	    this.ensureURL()
	    return abort()
	  }

	  var ref = resolveQueue(this.current.matched, route.matched);
	    var deactivated = ref.deactivated;
	    var activated = ref.activated;

	  var queue = [].concat(
	    // in-component leave guards
	    extractLeaveGuards(deactivated),
	    // global before hooks
	    this.router.beforeHooks,
	    // enter guards
	    activated.map(function (m) { return m.beforeEnter; }),
	    // async components
	    resolveAsyncComponents(activated)
	  )

	  this.pending = route
	  var iterator = function (hook, next) {
	    if (this$1.pending !== route) {
	      return abort()
	    }
	    hook(route, current, function (to) {
	      if (to === false) {
	        // next(false) -> abort navigation, ensure current URL
	        this$1.ensureURL(true)
	        abort()
	      } else if (typeof to === 'string' || typeof to === 'object') {
	        // next('/') or next({ path: '/' }) -> redirect
	        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to)
	        abort()
	      } else {
	        // confirm transition and pass on the value
	        next(to)
	      }
	    })
	  }

	  runQueue(queue, iterator, function () {
	    var postEnterCbs = []
	    var enterGuards = extractEnterGuards(activated, postEnterCbs, function () {
	      return this$1.current === route
	    })
	    // wait until async components are resolved before
	    // extracting in-component enter guards
	    runQueue(enterGuards, iterator, function () {
	      if (this$1.pending !== route) {
	        return abort()
	      }
	      this$1.pending = null
	      onComplete(route)
	      if (this$1.router.app) {
	        this$1.router.app.$nextTick(function () {
	          postEnterCbs.forEach(function (cb) { return cb(); })
	        })
	      }
	    })
	  })
	};

	History.prototype.updateRoute = function updateRoute (route) {
	  var prev = this.current
	  this.current = route
	  this.cb && this.cb(route)
	  this.router.afterHooks.forEach(function (hook) {
	    hook && hook(route, prev)
	  })
	};

	function normalizeBase (base) {
	  if (!base) {
	    if (inBrowser) {
	      // respect <base> tag
	      var baseEl = document.querySelector('base')
	      base = baseEl ? baseEl.getAttribute('href') : '/'
	    } else {
	      base = '/'
	    }
	  }
	  // make sure there's the starting slash
	  if (base.charAt(0) !== '/') {
	    base = '/' + base
	  }
	  // remove trailing slash
	  return base.replace(/\/$/, '')
	}

	function resolveQueue (
	  current,
	  next
	) {
	  var i
	  var max = Math.max(current.length, next.length)
	  for (i = 0; i < max; i++) {
	    if (current[i] !== next[i]) {
	      break
	    }
	  }
	  return {
	    activated: next.slice(i),
	    deactivated: current.slice(i)
	  }
	}

	function extractGuard (
	  def,
	  key
	) {
	  if (typeof def !== 'function') {
	    // extend now so that global mixins are applied.
	    def = _Vue.extend(def)
	  }
	  return def.options[key]
	}

	function extractLeaveGuards (matched) {
	  return flatten(flatMapComponents(matched, function (def, instance) {
	    var guard = extractGuard(def, 'beforeRouteLeave')
	    if (guard) {
	      return Array.isArray(guard)
	        ? guard.map(function (guard) { return wrapLeaveGuard(guard, instance); })
	        : wrapLeaveGuard(guard, instance)
	    }
	  }).reverse())
	}

	function wrapLeaveGuard (
	  guard,
	  instance
	) {
	  return function routeLeaveGuard () {
	    return guard.apply(instance, arguments)
	  }
	}

	function extractEnterGuards (
	  matched,
	  cbs,
	  isValid
	) {
	  return flatten(flatMapComponents(matched, function (def, _, match, key) {
	    var guard = extractGuard(def, 'beforeRouteEnter')
	    if (guard) {
	      return Array.isArray(guard)
	        ? guard.map(function (guard) { return wrapEnterGuard(guard, cbs, match, key, isValid); })
	        : wrapEnterGuard(guard, cbs, match, key, isValid)
	    }
	  }))
	}

	function wrapEnterGuard (
	  guard,
	  cbs,
	  match,
	  key,
	  isValid
	) {
	  return function routeEnterGuard (to, from, next) {
	    return guard(to, from, function (cb) {
	      next(cb)
	      if (typeof cb === 'function') {
	        cbs.push(function () {
	          // #750
	          // if a router-view is wrapped with an out-in transition,
	          // the instance may not have been registered at this time.
	          // we will need to poll for registration until current route
	          // is no longer valid.
	          poll(cb, match.instances, key, isValid)
	        })
	      }
	    })
	  }
	}

	function poll (
	  cb, // somehow flow cannot infer this is a function
	  instances,
	  key,
	  isValid
	) {
	  if (instances[key]) {
	    cb(instances[key])
	  } else if (isValid()) {
	    setTimeout(function () {
	      poll(cb, instances, key, isValid)
	    }, 16)
	  }
	}

	function resolveAsyncComponents (matched) {
	  return flatMapComponents(matched, function (def, _, match, key) {
	    // if it's a function and doesn't have Vue options attached,
	    // assume it's an async component resolve function.
	    // we are not using Vue's default async resolving mechanism because
	    // we want to halt the navigation until the incoming component has been
	    // resolved.
	    if (typeof def === 'function' && !def.options) {
	      return function (to, from, next) {
	        var resolve = function (resolvedDef) {
	          match.components[key] = resolvedDef
	          next()
	        }

	        var reject = function (reason) {
	          warn(false, ("Failed to resolve async component " + key + ": " + reason))
	          next(false)
	        }

	        var res = def(resolve, reject)
	        if (res && typeof res.then === 'function') {
	          res.then(resolve, reject)
	        }
	      }
	    }
	  })
	}

	function flatMapComponents (
	  matched,
	  fn
	) {
	  return flatten(matched.map(function (m) {
	    return Object.keys(m.components).map(function (key) { return fn(
	      m.components[key],
	      m.instances[key],
	      m, key
	    ); })
	  }))
	}

	function flatten (arr) {
	  return Array.prototype.concat.apply([], arr)
	}

	/*  */

	var positionStore = Object.create(null)

	function saveScrollPosition (key) {
	  if (!key) { return }
	  positionStore[key] = {
	    x: window.pageXOffset,
	    y: window.pageYOffset
	  }
	}

	function getScrollPosition (key) {
	  if (!key) { return }
	  return positionStore[key]
	}

	function getElementPosition (el) {
	  var docRect = document.documentElement.getBoundingClientRect()
	  var elRect = el.getBoundingClientRect()
	  return {
	    x: elRect.left - docRect.left,
	    y: elRect.top - docRect.top
	  }
	}

	function isValidPosition (obj) {
	  return isNumber(obj.x) || isNumber(obj.y)
	}

	function normalizePosition (obj) {
	  return {
	    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
	    y: isNumber(obj.y) ? obj.y : window.pageYOffset
	  }
	}

	function isNumber (v) {
	  return typeof v === 'number'
	}

	/*  */


	var genKey = function () { return String(Date.now()); }
	var _key = genKey()

	var HTML5History = (function (History) {
	  function HTML5History (router, base) {
	    var this$1 = this;

	    History.call(this, router, base)

	    var expectScroll = router.options.scrollBehavior
	    window.addEventListener('popstate', function (e) {
	      _key = e.state && e.state.key
	      var current = this$1.current
	      this$1.transitionTo(getLocation(this$1.base), function (next) {
	        if (expectScroll) {
	          this$1.handleScroll(next, current, true)
	        }
	      })
	    })

	    if (expectScroll) {
	      window.addEventListener('scroll', function () {
	        saveScrollPosition(_key)
	      })
	    }
	  }

	  if ( History ) HTML5History.__proto__ = History;
	  HTML5History.prototype = Object.create( History && History.prototype );
	  HTML5History.prototype.constructor = HTML5History;

	  HTML5History.prototype.go = function go (n) {
	    window.history.go(n)
	  };

	  HTML5History.prototype.push = function push (location) {
	    var this$1 = this;

	    var current = this.current
	    this.transitionTo(location, function (route) {
	      pushState(cleanPath(this$1.base + route.fullPath))
	      this$1.handleScroll(route, current, false)
	    })
	  };

	  HTML5History.prototype.replace = function replace (location) {
	    var this$1 = this;

	    var current = this.current
	    this.transitionTo(location, function (route) {
	      replaceState(cleanPath(this$1.base + route.fullPath))
	      this$1.handleScroll(route, current, false)
	    })
	  };

	  HTML5History.prototype.ensureURL = function ensureURL (push) {
	    if (getLocation(this.base) !== this.current.fullPath) {
	      var current = cleanPath(this.base + this.current.fullPath)
	      push ? pushState(current) : replaceState(current)
	    }
	  };

	  HTML5History.prototype.handleScroll = function handleScroll (to, from, isPop) {
	    var router = this.router
	    if (!router.app) {
	      return
	    }

	    var behavior = router.options.scrollBehavior
	    if (!behavior) {
	      return
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      assert(typeof behavior === 'function', "scrollBehavior must be a function")
	    }

	    // wait until re-render finishes before scrolling
	    router.app.$nextTick(function () {
	      var position = getScrollPosition(_key)
	      var shouldScroll = behavior(to, from, isPop ? position : null)
	      if (!shouldScroll) {
	        return
	      }
	      var isObject = typeof shouldScroll === 'object'
	      if (isObject && typeof shouldScroll.selector === 'string') {
	        var el = document.querySelector(shouldScroll.selector)
	        if (el) {
	          position = getElementPosition(el)
	        } else if (isValidPosition(shouldScroll)) {
	          position = normalizePosition(shouldScroll)
	        }
	      } else if (isObject && isValidPosition(shouldScroll)) {
	        position = normalizePosition(shouldScroll)
	      }

	      if (position) {
	        window.scrollTo(position.x, position.y)
	      }
	    })
	  };

	  return HTML5History;
	}(History));

	function getLocation (base) {
	  var path = window.location.pathname
	  if (base && path.indexOf(base) === 0) {
	    path = path.slice(base.length)
	  }
	  return (path || '/') + window.location.search + window.location.hash
	}

	function pushState (url, replace) {
	  // try...catch the pushState call to get around Safari
	  // DOM Exception 18 where it limits to 100 pushState calls
	  var history = window.history
	  try {
	    if (replace) {
	      history.replaceState({ key: _key }, '', url)
	    } else {
	      _key = genKey()
	      history.pushState({ key: _key }, '', url)
	    }
	    saveScrollPosition(_key)
	  } catch (e) {
	    window.location[replace ? 'assign' : 'replace'](url)
	  }
	}

	function replaceState (url) {
	  pushState(url, true)
	}

	/*  */


	var HashHistory = (function (History) {
	  function HashHistory (router, base, fallback) {
	    History.call(this, router, base)
	    // check history fallback deeplinking
	    if (fallback && this.checkFallback()) {
	      return
	    }
	    ensureSlash()
	  }

	  if ( History ) HashHistory.__proto__ = History;
	  HashHistory.prototype = Object.create( History && History.prototype );
	  HashHistory.prototype.constructor = HashHistory;

	  HashHistory.prototype.checkFallback = function checkFallback () {
	    var location = getLocation(this.base)
	    if (!/^\/#/.test(location)) {
	      window.location.replace(
	        cleanPath(this.base + '/#' + location)
	      )
	      return true
	    }
	  };

	  HashHistory.prototype.onHashChange = function onHashChange () {
	    if (!ensureSlash()) {
	      return
	    }
	    this.transitionTo(getHash(), function (route) {
	      replaceHash(route.fullPath)
	    })
	  };

	  HashHistory.prototype.push = function push (location) {
	    this.transitionTo(location, function (route) {
	      pushHash(route.fullPath)
	    })
	  };

	  HashHistory.prototype.replace = function replace (location) {
	    this.transitionTo(location, function (route) {
	      replaceHash(route.fullPath)
	    })
	  };

	  HashHistory.prototype.go = function go (n) {
	    window.history.go(n)
	  };

	  HashHistory.prototype.ensureURL = function ensureURL (push) {
	    var current = this.current.fullPath
	    if (getHash() !== current) {
	      push ? pushHash(current) : replaceHash(current)
	    }
	  };

	  return HashHistory;
	}(History));

	function ensureSlash () {
	  var path = getHash()
	  if (path.charAt(0) === '/') {
	    return true
	  }
	  replaceHash('/' + path)
	  return false
	}

	function getHash () {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  var href = window.location.href
	  var index = href.indexOf('#')
	  return index === -1 ? '' : href.slice(index + 1)
	}

	function pushHash (path) {
	  window.location.hash = path
	}

	function replaceHash (path) {
	  var i = window.location.href.indexOf('#')
	  window.location.replace(
	    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path
	  )
	}

	/*  */


	var AbstractHistory = (function (History) {
	  function AbstractHistory (router) {
	    History.call(this, router)
	    this.stack = []
	    this.index = -1
	  }

	  if ( History ) AbstractHistory.__proto__ = History;
	  AbstractHistory.prototype = Object.create( History && History.prototype );
	  AbstractHistory.prototype.constructor = AbstractHistory;

	  AbstractHistory.prototype.push = function push (location) {
	    var this$1 = this;

	    this.transitionTo(location, function (route) {
	      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route)
	      this$1.index++
	    })
	  };

	  AbstractHistory.prototype.replace = function replace (location) {
	    var this$1 = this;

	    this.transitionTo(location, function (route) {
	      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route)
	    })
	  };

	  AbstractHistory.prototype.go = function go (n) {
	    var this$1 = this;

	    var targetIndex = this.index + n
	    if (targetIndex < 0 || targetIndex >= this.stack.length) {
	      return
	    }
	    var route = this.stack[targetIndex]
	    this.confirmTransition(route, function () {
	      this$1.index = targetIndex
	      this$1.updateRoute(route)
	    })
	  };

	  AbstractHistory.prototype.ensureURL = function ensureURL () {
	    // noop
	  };

	  return AbstractHistory;
	}(History));

	/*  */

	var VueRouter = function VueRouter (options) {
	  if ( options === void 0 ) options = {};

	  this.app = null
	  this.options = options
	  this.beforeHooks = []
	  this.afterHooks = []
	  this.match = createMatcher(options.routes || [])

	  var mode = options.mode || 'hash'
	  this.fallback = mode === 'history' && !supportsHistory
	  if (this.fallback) {
	    mode = 'hash'
	  }
	  if (!inBrowser) {
	    mode = 'abstract'
	  }
	  this.mode = mode

	  switch (mode) {
	    case 'history':
	      this.history = new HTML5History(this, options.base)
	      break
	    case 'hash':
	      this.history = new HashHistory(this, options.base, this.fallback)
	      break
	    case 'abstract':
	      this.history = new AbstractHistory(this)
	      break
	    default:
	      process.env.NODE_ENV !== 'production' && assert(false, ("invalid mode: " + mode))
	  }
	};

	var prototypeAccessors = { currentRoute: {} };

	prototypeAccessors.currentRoute.get = function () {
	  return this.history && this.history.current
	};

	VueRouter.prototype.init = function init (app /* Vue component instance */) {
	    var this$1 = this;

	  process.env.NODE_ENV !== 'production' && assert(
	    install.installed,
	    "not installed. Make sure to call `Vue.use(VueRouter)` " +
	    "before creating root instance."
	  )

	  this.app = app

	  var history = this.history

	  if (history instanceof HTML5History) {
	    history.transitionTo(getLocation(history.base))
	  } else if (history instanceof HashHistory) {
	    var setupHashListener = function () {
	      window.addEventListener('hashchange', function () {
	        history.onHashChange()
	      })
	    }
	    history.transitionTo(getHash(), setupHashListener, setupHashListener)
	  }

	  history.listen(function (route) {
	    this$1.app._route = route
	  })
	};

	VueRouter.prototype.beforeEach = function beforeEach (fn) {
	  this.beforeHooks.push(fn)
	};

	VueRouter.prototype.afterEach = function afterEach (fn) {
	  this.afterHooks.push(fn)
	};

	VueRouter.prototype.push = function push (location) {
	  this.history.push(location)
	};

	VueRouter.prototype.replace = function replace (location) {
	  this.history.replace(location)
	};

	VueRouter.prototype.go = function go (n) {
	  this.history.go(n)
	};

	VueRouter.prototype.back = function back () {
	  this.go(-1)
	};

	VueRouter.prototype.forward = function forward () {
	  this.go(1)
	};

	VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
	  var route = to
	    ? this.resolve(to).resolved
	    : this.currentRoute
	  if (!route) {
	    return []
	  }
	  return [].concat.apply([], route.matched.map(function (m) {
	    return Object.keys(m.components).map(function (key) {
	      return m.components[key]
	    })
	  }))
	};

	VueRouter.prototype.resolve = function resolve (
	  to,
	  current,
	  append
	) {
	  var normalizedTo = normalizeLocation(to, current || this.history.current, append)
	  var resolved = this.match(normalizedTo, current)
	  var fullPath = resolved.redirectedFrom || resolved.fullPath
	  var base = this.history.base
	  var href = createHref(base, fullPath, this.mode)
	  return {
	    normalizedTo: normalizedTo,
	    resolved: resolved,
	    href: href
	  }
	};

	Object.defineProperties( VueRouter.prototype, prototypeAccessors );

	function createHref (base, fullPath, mode) {
	  var path = mode === 'hash' ? '#' + fullPath : fullPath
	  return base ? cleanPath(base + '/' + path) : path
	}

	VueRouter.install = install

	if (inBrowser && window.Vue) {
	  window.Vue.use(VueRouter)
	}

	module.exports = VueRouter;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(5)

	/* script */
	__vue_exports__ = __webpack_require__(15)

	/* template */
	var __vue_template__ = __webpack_require__(21)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\App.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-402668e5", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-402668e5", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] App.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(14)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-402668e5!./../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-402668e5!./../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	exports.i(__webpack_require__(8), "");
	exports.i(__webpack_require__(9), "");
	exports.i(__webpack_require__(13), "");

	// module
	exports.push([module.id, "\n", ""]);

	// exports


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, "html {\n  font-family: sans-serif;\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n}\n\nbody {\n  margin: 0;\n}\n\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nmain,\nmenu,\nnav,\nsection,\nsummary {\n  display: block;\n}\n\naudio,\ncanvas,\nprogress,\nvideo {\n  display: inline-block;\n}\n\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\n\nprogress {\n  vertical-align: baseline;\n}\n\ntemplate,\n[hidden] {\n  display: none;\n}\n\na {\n  background-color: transparent;\n}\n\na:active,\na:hover {\n  outline-width: 0;\n}\n\nabbr[title] {\n  border-bottom: none;\n  text-decoration: underline;\n  text-decoration: underline dotted;\n}\n\nb,\nstrong {\n  font-weight: inherit;\n}\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\ndfn {\n  font-style: italic;\n}\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\nmark {\n  background-color: #ff0;\n  color: #000;\n}\n\nsmall {\n  font-size: 80%;\n}\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\nimg {\n  border-style: none;\n}\n\nsvg:not(:root) {\n  overflow: hidden;\n}\n\ncode,\nkbd,\npre,\nsamp {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\nfigure {\n  margin: 1em 40px;\n}\n\nhr {\n  -webkit-box-sizing: content-box;\n          box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\nbutton,\ninput,\nselect,\ntextarea {\n  font: inherit;\n}\n\noptgroup {\n  font-weight: bold;\n}\n\nbutton,\ninput,\nselect {\n  overflow: visible;\n}\n\nbutton,\ninput,\nselect,\ntextarea {\n  margin: 0;\n}\n\nbutton,\nselect {\n  text-transform: none;\n}\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  cursor: pointer;\n}\n\n[disabled] {\n  cursor: default;\n}\n\nbutton,\nhtml [type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n}\n\nbutton::-moz-focus-inner,\ninput::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n\nbutton:-moz-focusring,\ninput:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\nfieldset {\n  border: 1px solid #c0c0c0;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\n\nlegend {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: inherit;\n  display: table;\n  max-width: 100%;\n  padding: 0;\n  white-space: normal;\n}\n\ntextarea {\n  overflow: auto;\n}\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  padding: 0;\n}\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n[type=\"search\"] {\n  -webkit-appearance: textfield;\n}\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n@media print {\n  *,\n  *::before,\n  *::after,\n  *::first-letter,\n  *::first-line {\n    text-shadow: none !important;\n    -webkit-box-shadow: none !important;\n            box-shadow: none !important;\n  }\n  a,\n  a:visited {\n    text-decoration: underline;\n  }\n  abbr[title]::after {\n    content: \" (\" attr(title) \")\";\n  }\n  pre,\n  blockquote {\n    border: 1px solid #999;\n    page-break-inside: avoid;\n  }\n  thead {\n    display: table-header-group;\n  }\n  tr,\n  img {\n    page-break-inside: avoid;\n  }\n  p,\n  h2,\n  h3 {\n    orphans: 3;\n    widows: 3;\n  }\n  h2,\n  h3 {\n    page-break-after: avoid;\n  }\n  .navbar {\n    display: none;\n  }\n  .btn > .caret,\n  .dropup > .btn > .caret {\n    border-top-color: #000 !important;\n  }\n  .tag {\n    border: 1px solid #000;\n  }\n  .table {\n    border-collapse: collapse !important;\n  }\n  .table td,\n  .table th {\n    background-color: #fff !important;\n  }\n  .table-bordered th,\n  .table-bordered td {\n    border: 1px solid #ddd !important;\n  }\n}\n\nhtml {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n\n*,\n*::before,\n*::after {\n  -webkit-box-sizing: inherit;\n          box-sizing: inherit;\n}\n\n@-ms-viewport {\n  width: device-width;\n}\n\nhtml {\n  font-size: 16px;\n  -ms-overflow-style: scrollbar;\n  -webkit-tap-highlight-color: transparent;\n}\n\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n  font-size: 1rem;\n  line-height: 1.5;\n  color: #373a3c;\n  background-color: #fff;\n}\n\n[tabindex=\"-1\"]:focus {\n  outline: none !important;\n}\n\nh1, h2, h3, h4, h5, h6 {\n  margin-top: 0;\n  margin-bottom: .5rem;\n}\n\np {\n  margin-top: 0;\n  margin-bottom: 1rem;\n}\n\nabbr[title],\nabbr[data-original-title] {\n  cursor: help;\n  border-bottom: 1px dotted #818a91;\n}\n\naddress {\n  margin-bottom: 1rem;\n  font-style: normal;\n  line-height: inherit;\n}\n\nol,\nul,\ndl {\n  margin-top: 0;\n  margin-bottom: 1rem;\n}\n\nol ol,\nul ul,\nol ul,\nul ol {\n  margin-bottom: 0;\n}\n\ndt {\n  font-weight: bold;\n}\n\ndd {\n  margin-bottom: .5rem;\n  margin-left: 0;\n}\n\nblockquote {\n  margin: 0 0 1rem;\n}\n\na {\n  color: #0275d8;\n  text-decoration: none;\n}\n\na:focus, a:hover {\n  color: #014c8c;\n  text-decoration: underline;\n}\n\na:focus {\n  outline: 5px auto -webkit-focus-ring-color;\n  outline-offset: -2px;\n}\n\na:not([href]):not([tabindex]) {\n  color: inherit;\n  text-decoration: none;\n}\n\na:not([href]):not([tabindex]):focus, a:not([href]):not([tabindex]):hover {\n  color: inherit;\n  text-decoration: none;\n}\n\na:not([href]):not([tabindex]):focus {\n  outline: none;\n}\n\npre {\n  margin-top: 0;\n  margin-bottom: 1rem;\n  overflow: auto;\n}\n\nfigure {\n  margin: 0 0 1rem;\n}\n\nimg {\n  vertical-align: middle;\n}\n\n[role=\"button\"] {\n  cursor: pointer;\n}\n\na,\narea,\nbutton,\n[role=\"button\"],\ninput,\nlabel,\nselect,\nsummary,\ntextarea {\n  -ms-touch-action: manipulation;\n      touch-action: manipulation;\n}\n\ntable {\n  border-collapse: collapse;\n  background-color: transparent;\n}\n\ncaption {\n  padding-top: 0.75rem;\n  padding-bottom: 0.75rem;\n  color: #818a91;\n  text-align: left;\n  caption-side: bottom;\n}\n\nth {\n  text-align: left;\n}\n\nlabel {\n  display: inline-block;\n  margin-bottom: .1rem;\n}\n\nbutton:focus {\n  outline: 1px dotted;\n  outline: 5px auto -webkit-focus-ring-color;\n}\n\ninput,\nbutton,\nselect,\ntextarea {\n  margin: 0;\n  line-height: inherit;\n  border-radius: 0;\n}\n\ninput[type=\"radio\"]:disabled,\ninput[type=\"checkbox\"]:disabled {\n  cursor: not-allowed;\n}\n\ninput[type=\"date\"],\ninput[type=\"time\"],\ninput[type=\"datetime-local\"],\ninput[type=\"month\"] {\n  -webkit-appearance: listbox;\n}\n\ntextarea {\n  resize: vertical;\n}\n\nfieldset {\n  min-width: 0;\n  padding: 0;\n  margin: 0;\n  border: 0;\n}\n\nlegend {\n  display: block;\n  width: 100%;\n  padding: 0;\n  margin-bottom: .5rem;\n  font-size: 1.5rem;\n  line-height: inherit;\n}\n\ninput[type=\"search\"] {\n  -webkit-appearance: none;\n}\n\noutput {\n  display: inline-block;\n}\n\n[hidden] {\n  display: none !important;\n}\n\nh1, h2, h3, h4, h5, h6,\n.h1, .h2, .h3, .h4, .h5, .h6 {\n  margin-bottom: 0.5rem;\n  font-family: inherit;\n  font-weight: 500;\n  line-height: 1.1;\n  color: inherit;\n}\n\nh1, .h1 {\n  font-size: 2.5rem;\n}\n\nh2, .h2 {\n  font-size: 2rem;\n}\n\nh3, .h3 {\n  font-size: 1.75rem;\n}\n\nh4, .h4 {\n  font-size: 1.5rem;\n}\n\nh5, .h5 {\n  font-size: 1.25rem;\n}\n\nh6, .h6 {\n  font-size: 1rem;\n}\n\n.lead {\n  font-size: 1.25rem;\n  font-weight: 300;\n}\n\n.display-1 {\n  font-size: 6rem;\n  font-weight: 300;\n}\n\n.display-2 {\n  font-size: 5.5rem;\n  font-weight: 300;\n}\n\n.display-3 {\n  font-size: 4.5rem;\n  font-weight: 300;\n}\n\n.display-4 {\n  font-size: 3.5rem;\n  font-weight: 300;\n}\n\nhr {\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n  border: 0;\n  border-top: 1px solid rgba(0, 0, 0, 0.1);\n}\n\nsmall,\n.small {\n  font-size: 80%;\n  font-weight: normal;\n}\n\nmark,\n.mark {\n  padding: 0.2em;\n  background-color: #fcf8e3;\n}\n\n.list-unstyled {\n  padding-left: 0;\n  list-style: none;\n}\n\n.list-inline {\n  padding-left: 0;\n  list-style: none;\n}\n\n.list-inline-item {\n  display: inline-block;\n}\n\n.list-inline-item:not(:last-child) {\n  margin-right: 5px;\n}\n\n.initialism {\n  font-size: 90%;\n  text-transform: uppercase;\n}\n\n.blockquote {\n  padding: 0.5rem 1rem;\n  margin-bottom: 1rem;\n  font-size: 1.25rem;\n  border-left: 0.25rem solid #eceeef;\n}\n\n.blockquote-footer {\n  display: block;\n  font-size: 80%;\n  color: #818a91;\n}\n\n.blockquote-footer::before {\n  content: \"\\2014   \\A0\";\n}\n\n.blockquote-reverse {\n  padding-right: 1rem;\n  padding-left: 0;\n  text-align: right;\n  border-right: 0.25rem solid #eceeef;\n  border-left: 0;\n}\n\n.blockquote-reverse .blockquote-footer::before {\n  content: \"\";\n}\n\n.blockquote-reverse .blockquote-footer::after {\n  content: \"\\A0   \\2014\";\n}\n\ndl.row > dd + dt {\n  clear: left;\n}\n\n.img-fluid, .carousel-inner > .carousel-item > img,\n.carousel-inner > .carousel-item > a > img {\n  display: block;\n  max-width: 100%;\n  height: auto;\n}\n\n.img-rounded {\n  border-radius: 0.3rem;\n}\n\n.img-thumbnail {\n  padding: 0.25rem;\n  background-color: #fff;\n  border: 1px solid #ddd;\n  border-radius: 0.25rem;\n  -webkit-transition: all .2s ease-in-out;\n  -o-transition: all .2s ease-in-out;\n  transition: all .2s ease-in-out;\n  display: inline-block;\n  max-width: 100%;\n  height: auto;\n}\n\n.img-circle {\n  border-radius: 50%;\n}\n\n.figure {\n  display: inline-block;\n}\n\n.figure-img {\n  margin-bottom: 0.5rem;\n  line-height: 1;\n}\n\n.figure-caption {\n  font-size: 90%;\n  color: #818a91;\n}\n\ncode,\nkbd,\npre,\nsamp {\n  font-family: Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n}\n\ncode {\n  padding: 0.2rem 0.4rem;\n  font-size: 90%;\n  color: #bd4147;\n  background-color: #f7f7f9;\n  border-radius: 0.25rem;\n}\n\nkbd {\n  padding: 0.2rem 0.4rem;\n  font-size: 90%;\n  color: #fff;\n  background-color: #333;\n  border-radius: 0.2rem;\n}\n\nkbd kbd {\n  padding: 0;\n  font-size: 100%;\n  font-weight: bold;\n}\n\npre {\n  display: block;\n  margin-top: 0;\n  margin-bottom: 1rem;\n  font-size: 90%;\n  color: #373a3c;\n}\n\npre code {\n  padding: 0;\n  font-size: inherit;\n  color: inherit;\n  background-color: transparent;\n  border-radius: 0;\n}\n\n.pre-scrollable {\n  max-height: 340px;\n  overflow-y: scroll;\n}\n\n.container {\n  margin-left: auto;\n  margin-right: auto;\n  padding-left: 15px;\n  padding-right: 15px;\n}\n\n.container::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n/*@media (min-width: 544px) {*/\n  /*.container {*/\n    /*max-width: 576px;*/\n  /*}*/\n/*}*/\n\n/*@media (min-width: 768px) {*/\n  /*.container {*/\n    /*max-width: 720px;*/\n  /*}*/\n/*}*/\n\n/*@media (min-width: 992px) {*/\n  /*.container {*/\n    /*max-width: 940px;*/\n  /*}*/\n/*}*/\n\n/*@media (min-width: 1200px) {*/\n  /*.container {*/\n    /*max-width: 1140px;*/\n  /*}*/\n/*}*/\n\n.container-fluid {\n  margin-left: auto;\n  margin-right: auto;\n  padding-left: 15px;\n  padding-right: 15px;\n}\n\n.container-fluid::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.row {\n  /*margin-left: -15px;*/\n  /*margin-right: -15px;*/\n}\n\n.row::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12, .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12, .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12, .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12, .col-xl-1, .col-xl-2, .col-xl-3, .col-xl-4, .col-xl-5, .col-xl-6, .col-xl-7, .col-xl-8, .col-xl-9, .col-xl-10, .col-xl-11, .col-xl-12 {\n  position: relative;\n  min-height: 1px;\n  /*padding-right: 15px;*/\n  /*padding-left: 15px;*/\n}\n\n.col-xs-1 {\n  float: left;\n  width: 8.333333%;\n}\n\n.col-xs-2 {\n  float: left;\n  width: 16.666667%;\n}\n\n.col-xs-3 {\n  float: left;\n  width: 25%;\n}\n\n.col-xs-4 {\n  float: left;\n  width: 33.333333%;\n}\n\n.col-xs-5 {\n  float: left;\n  width: 41.666667%;\n}\n\n.col-xs-6 {\n  float: left;\n  width: 50%;\n}\n\n.col-xs-7 {\n  float: left;\n  width: 58.333333%;\n}\n\n.col-xs-8 {\n  float: left;\n  width: 66.666667%;\n}\n\n.col-xs-9 {\n  float: left;\n  width: 75%;\n}\n\n.col-xs-10 {\n  float: left;\n  width: 83.333333%;\n}\n\n.col-xs-11 {\n  float: left;\n  width: 91.666667%;\n}\n\n.col-xs-12 {\n  float: left;\n  width: 100%;\n}\n\n.pull-xs-0 {\n  right: auto;\n}\n\n.pull-xs-1 {\n  right: 8.333333%;\n}\n\n.pull-xs-2 {\n  right: 16.666667%;\n}\n\n.pull-xs-3 {\n  right: 25%;\n}\n\n.pull-xs-4 {\n  right: 33.333333%;\n}\n\n.pull-xs-5 {\n  right: 41.666667%;\n}\n\n.pull-xs-6 {\n  right: 50%;\n}\n\n.pull-xs-7 {\n  right: 58.333333%;\n}\n\n.pull-xs-8 {\n  right: 66.666667%;\n}\n\n.pull-xs-9 {\n  right: 75%;\n}\n\n.pull-xs-10 {\n  right: 83.333333%;\n}\n\n.pull-xs-11 {\n  right: 91.666667%;\n}\n\n.pull-xs-12 {\n  right: 100%;\n}\n\n.push-xs-0 {\n  left: auto;\n}\n\n.push-xs-1 {\n  left: 8.333333%;\n}\n\n.push-xs-2 {\n  left: 16.666667%;\n}\n\n.push-xs-3 {\n  left: 25%;\n}\n\n.push-xs-4 {\n  left: 33.333333%;\n}\n\n.push-xs-5 {\n  left: 41.666667%;\n}\n\n.push-xs-6 {\n  left: 50%;\n}\n\n.push-xs-7 {\n  left: 58.333333%;\n}\n\n.push-xs-8 {\n  left: 66.666667%;\n}\n\n.push-xs-9 {\n  left: 75%;\n}\n\n.push-xs-10 {\n  left: 83.333333%;\n}\n\n.push-xs-11 {\n  left: 91.666667%;\n}\n\n.push-xs-12 {\n  left: 100%;\n}\n\n.offset-xs-1 {\n  margin-left: 8.333333%;\n}\n\n.offset-xs-2 {\n  margin-left: 16.666667%;\n}\n\n.offset-xs-3 {\n  margin-left: 25%;\n}\n\n.offset-xs-4 {\n  margin-left: 33.333333%;\n}\n\n.offset-xs-5 {\n  margin-left: 41.666667%;\n}\n\n.offset-xs-6 {\n  margin-left: 50%;\n}\n\n.offset-xs-7 {\n  margin-left: 58.333333%;\n}\n\n.offset-xs-8 {\n  margin-left: 66.666667%;\n}\n\n.offset-xs-9 {\n  margin-left: 75%;\n}\n\n.offset-xs-10 {\n  margin-left: 83.333333%;\n}\n\n.offset-xs-11 {\n  margin-left: 91.666667%;\n}\n\n@media (min-width: 544px) {\n  .col-sm-1 {\n    float: left;\n    width: 8.333333%;\n  }\n  .col-sm-2 {\n    float: left;\n    width: 16.666667%;\n  }\n  .col-sm-3 {\n    float: left;\n    width: 25%;\n  }\n  .col-sm-4 {\n    float: left;\n    width: 33.333333%;\n  }\n  .col-sm-5 {\n    float: left;\n    width: 41.666667%;\n  }\n  .col-sm-6 {\n    float: left;\n    width: 50%;\n  }\n  .col-sm-7 {\n    float: left;\n    width: 58.333333%;\n  }\n  .col-sm-8 {\n    float: left;\n    width: 66.666667%;\n  }\n  .col-sm-9 {\n    float: left;\n    width: 75%;\n  }\n  .col-sm-10 {\n    float: left;\n    width: 83.333333%;\n  }\n  .col-sm-11 {\n    float: left;\n    width: 91.666667%;\n  }\n  .col-sm-12 {\n    float: left;\n    width: 100%;\n  }\n  .pull-sm-0 {\n    right: auto;\n  }\n  .pull-sm-1 {\n    right: 8.333333%;\n  }\n  .pull-sm-2 {\n    right: 16.666667%;\n  }\n  .pull-sm-3 {\n    right: 25%;\n  }\n  .pull-sm-4 {\n    right: 33.333333%;\n  }\n  .pull-sm-5 {\n    right: 41.666667%;\n  }\n  .pull-sm-6 {\n    right: 50%;\n  }\n  .pull-sm-7 {\n    right: 58.333333%;\n  }\n  .pull-sm-8 {\n    right: 66.666667%;\n  }\n  .pull-sm-9 {\n    right: 75%;\n  }\n  .pull-sm-10 {\n    right: 83.333333%;\n  }\n  .pull-sm-11 {\n    right: 91.666667%;\n  }\n  .pull-sm-12 {\n    right: 100%;\n  }\n  .push-sm-0 {\n    left: auto;\n  }\n  .push-sm-1 {\n    left: 8.333333%;\n  }\n  .push-sm-2 {\n    left: 16.666667%;\n  }\n  .push-sm-3 {\n    left: 25%;\n  }\n  .push-sm-4 {\n    left: 33.333333%;\n  }\n  .push-sm-5 {\n    left: 41.666667%;\n  }\n  .push-sm-6 {\n    left: 50%;\n  }\n  .push-sm-7 {\n    left: 58.333333%;\n  }\n  .push-sm-8 {\n    left: 66.666667%;\n  }\n  .push-sm-9 {\n    left: 75%;\n  }\n  .push-sm-10 {\n    left: 83.333333%;\n  }\n  .push-sm-11 {\n    left: 91.666667%;\n  }\n  .push-sm-12 {\n    left: 100%;\n  }\n  .offset-sm-0 {\n    margin-left: 0%;\n  }\n  .offset-sm-1 {\n    margin-left: 8.333333%;\n  }\n  .offset-sm-2 {\n    margin-left: 16.666667%;\n  }\n  .offset-sm-3 {\n    margin-left: 25%;\n  }\n  .offset-sm-4 {\n    margin-left: 33.333333%;\n  }\n  .offset-sm-5 {\n    margin-left: 41.666667%;\n  }\n  .offset-sm-6 {\n    margin-left: 50%;\n  }\n  .offset-sm-7 {\n    margin-left: 58.333333%;\n  }\n  .offset-sm-8 {\n    margin-left: 66.666667%;\n  }\n  .offset-sm-9 {\n    margin-left: 75%;\n  }\n  .offset-sm-10 {\n    margin-left: 83.333333%;\n  }\n  .offset-sm-11 {\n    margin-left: 91.666667%;\n  }\n}\n\n@media (min-width: 768px) {\n  .col-md-1 {\n    float: left;\n    width: 8.333333%;\n  }\n  .col-md-2 {\n    float: left;\n    width: 16.666667%;\n  }\n  .col-md-3 {\n    float: left;\n    width: 25%;\n  }\n  .col-md-4 {\n    float: left;\n    width: 33.333333%;\n  }\n  .col-md-5 {\n    float: left;\n    width: 41.666667%;\n  }\n  .col-md-6 {\n    float: left;\n    width: 50%;\n  }\n  .col-md-7 {\n    float: left;\n    width: 58.333333%;\n  }\n  .col-md-8 {\n    float: left;\n    width: 66.666667%;\n  }\n  .col-md-9 {\n    float: left;\n    width: 75%;\n  }\n  .col-md-10 {\n    float: left;\n    width: 83.333333%;\n  }\n  .col-md-11 {\n    float: left;\n    width: 91.666667%;\n  }\n  .col-md-12 {\n    float: left;\n    width: 100%;\n  }\n  .pull-md-0 {\n    right: auto;\n  }\n  .pull-md-1 {\n    right: 8.333333%;\n  }\n  .pull-md-2 {\n    right: 16.666667%;\n  }\n  .pull-md-3 {\n    right: 25%;\n  }\n  .pull-md-4 {\n    right: 33.333333%;\n  }\n  .pull-md-5 {\n    right: 41.666667%;\n  }\n  .pull-md-6 {\n    right: 50%;\n  }\n  .pull-md-7 {\n    right: 58.333333%;\n  }\n  .pull-md-8 {\n    right: 66.666667%;\n  }\n  .pull-md-9 {\n    right: 75%;\n  }\n  .pull-md-10 {\n    right: 83.333333%;\n  }\n  .pull-md-11 {\n    right: 91.666667%;\n  }\n  .pull-md-12 {\n    right: 100%;\n  }\n  .push-md-0 {\n    left: auto;\n  }\n  .push-md-1 {\n    left: 8.333333%;\n  }\n  .push-md-2 {\n    left: 16.666667%;\n  }\n  .push-md-3 {\n    left: 25%;\n  }\n  .push-md-4 {\n    left: 33.333333%;\n  }\n  .push-md-5 {\n    left: 41.666667%;\n  }\n  .push-md-6 {\n    left: 50%;\n  }\n  .push-md-7 {\n    left: 58.333333%;\n  }\n  .push-md-8 {\n    left: 66.666667%;\n  }\n  .push-md-9 {\n    left: 75%;\n  }\n  .push-md-10 {\n    left: 83.333333%;\n  }\n  .push-md-11 {\n    left: 91.666667%;\n  }\n  .push-md-12 {\n    left: 100%;\n  }\n  .offset-md-0 {\n    margin-left: 0%;\n  }\n  .offset-md-1 {\n    margin-left: 8.333333%;\n  }\n  .offset-md-2 {\n    margin-left: 16.666667%;\n  }\n  .offset-md-3 {\n    margin-left: 25%;\n  }\n  .offset-md-4 {\n    margin-left: 33.333333%;\n  }\n  .offset-md-5 {\n    margin-left: 41.666667%;\n  }\n  .offset-md-6 {\n    margin-left: 50%;\n  }\n  .offset-md-7 {\n    margin-left: 58.333333%;\n  }\n  .offset-md-8 {\n    margin-left: 66.666667%;\n  }\n  .offset-md-9 {\n    margin-left: 75%;\n  }\n  .offset-md-10 {\n    margin-left: 83.333333%;\n  }\n  .offset-md-11 {\n    margin-left: 91.666667%;\n  }\n}\n\n@media (min-width: 992px) {\n  .col-lg-1 {\n    float: left;\n    width: 8.333333%;\n  }\n  .col-lg-2 {\n    float: left;\n    width: 16.666667%;\n  }\n  .col-lg-3 {\n    float: left;\n    width: 25%;\n  }\n  .col-lg-4 {\n    float: left;\n    width: 33.333333%;\n  }\n  .col-lg-5 {\n    float: left;\n    width: 41.666667%;\n  }\n  .col-lg-6 {\n    float: left;\n    width: 50%;\n  }\n  .col-lg-7 {\n    float: left;\n    width: 58.333333%;\n  }\n  .col-lg-8 {\n    float: left;\n    width: 66.666667%;\n  }\n  .col-lg-9 {\n    float: left;\n    width: 75%;\n  }\n  .col-lg-10 {\n    float: left;\n    width: 83.333333%;\n  }\n  .col-lg-11 {\n    float: left;\n    width: 91.666667%;\n  }\n  .col-lg-12 {\n    float: left;\n    width: 100%;\n  }\n  .pull-lg-0 {\n    right: auto;\n  }\n  .pull-lg-1 {\n    right: 8.333333%;\n  }\n  .pull-lg-2 {\n    right: 16.666667%;\n  }\n  .pull-lg-3 {\n    right: 25%;\n  }\n  .pull-lg-4 {\n    right: 33.333333%;\n  }\n  .pull-lg-5 {\n    right: 41.666667%;\n  }\n  .pull-lg-6 {\n    right: 50%;\n  }\n  .pull-lg-7 {\n    right: 58.333333%;\n  }\n  .pull-lg-8 {\n    right: 66.666667%;\n  }\n  .pull-lg-9 {\n    right: 75%;\n  }\n  .pull-lg-10 {\n    right: 83.333333%;\n  }\n  .pull-lg-11 {\n    right: 91.666667%;\n  }\n  .pull-lg-12 {\n    right: 100%;\n  }\n  .push-lg-0 {\n    left: auto;\n  }\n  .push-lg-1 {\n    left: 8.333333%;\n  }\n  .push-lg-2 {\n    left: 16.666667%;\n  }\n  .push-lg-3 {\n    left: 25%;\n  }\n  .push-lg-4 {\n    left: 33.333333%;\n  }\n  .push-lg-5 {\n    left: 41.666667%;\n  }\n  .push-lg-6 {\n    left: 50%;\n  }\n  .push-lg-7 {\n    left: 58.333333%;\n  }\n  .push-lg-8 {\n    left: 66.666667%;\n  }\n  .push-lg-9 {\n    left: 75%;\n  }\n  .push-lg-10 {\n    left: 83.333333%;\n  }\n  .push-lg-11 {\n    left: 91.666667%;\n  }\n  .push-lg-12 {\n    left: 100%;\n  }\n  .offset-lg-0 {\n    margin-left: 0%;\n  }\n  .offset-lg-1 {\n    margin-left: 8.333333%;\n  }\n  .offset-lg-2 {\n    margin-left: 16.666667%;\n  }\n  .offset-lg-3 {\n    margin-left: 25%;\n  }\n  .offset-lg-4 {\n    margin-left: 33.333333%;\n  }\n  .offset-lg-5 {\n    margin-left: 41.666667%;\n  }\n  .offset-lg-6 {\n    margin-left: 50%;\n  }\n  .offset-lg-7 {\n    margin-left: 58.333333%;\n  }\n  .offset-lg-8 {\n    margin-left: 66.666667%;\n  }\n  .offset-lg-9 {\n    margin-left: 75%;\n  }\n  .offset-lg-10 {\n    margin-left: 83.333333%;\n  }\n  .offset-lg-11 {\n    margin-left: 91.666667%;\n  }\n}\n\n@media (min-width: 1200px) {\n  .col-xl-1 {\n    float: left;\n    width: 8.333333%;\n  }\n  .col-xl-2 {\n    float: left;\n    width: 16.666667%;\n  }\n  .col-xl-3 {\n    float: left;\n    width: 25%;\n  }\n  .col-xl-4 {\n    float: left;\n    width: 33.333333%;\n  }\n  .col-xl-5 {\n    float: left;\n    width: 41.666667%;\n  }\n  .col-xl-6 {\n    float: left;\n    width: 50%;\n  }\n  .col-xl-7 {\n    float: left;\n    width: 58.333333%;\n  }\n  .col-xl-8 {\n    float: left;\n    width: 66.666667%;\n  }\n  .col-xl-9 {\n    float: left;\n    width: 75%;\n  }\n  .col-xl-10 {\n    float: left;\n    width: 83.333333%;\n  }\n  .col-xl-11 {\n    float: left;\n    width: 91.666667%;\n  }\n  .col-xl-12 {\n    float: left;\n    width: 100%;\n  }\n  .pull-xl-0 {\n    right: auto;\n  }\n  .pull-xl-1 {\n    right: 8.333333%;\n  }\n  .pull-xl-2 {\n    right: 16.666667%;\n  }\n  .pull-xl-3 {\n    right: 25%;\n  }\n  .pull-xl-4 {\n    right: 33.333333%;\n  }\n  .pull-xl-5 {\n    right: 41.666667%;\n  }\n  .pull-xl-6 {\n    right: 50%;\n  }\n  .pull-xl-7 {\n    right: 58.333333%;\n  }\n  .pull-xl-8 {\n    right: 66.666667%;\n  }\n  .pull-xl-9 {\n    right: 75%;\n  }\n  .pull-xl-10 {\n    right: 83.333333%;\n  }\n  .pull-xl-11 {\n    right: 91.666667%;\n  }\n  .pull-xl-12 {\n    right: 100%;\n  }\n  .push-xl-0 {\n    left: auto;\n  }\n  .push-xl-1 {\n    left: 8.333333%;\n  }\n  .push-xl-2 {\n    left: 16.666667%;\n  }\n  .push-xl-3 {\n    left: 25%;\n  }\n  .push-xl-4 {\n    left: 33.333333%;\n  }\n  .push-xl-5 {\n    left: 41.666667%;\n  }\n  .push-xl-6 {\n    left: 50%;\n  }\n  .push-xl-7 {\n    left: 58.333333%;\n  }\n  .push-xl-8 {\n    left: 66.666667%;\n  }\n  .push-xl-9 {\n    left: 75%;\n  }\n  .push-xl-10 {\n    left: 83.333333%;\n  }\n  .push-xl-11 {\n    left: 91.666667%;\n  }\n  .push-xl-12 {\n    left: 100%;\n  }\n  .offset-xl-0 {\n    margin-left: 0%;\n  }\n  .offset-xl-1 {\n    margin-left: 8.333333%;\n  }\n  .offset-xl-2 {\n    margin-left: 16.666667%;\n  }\n  .offset-xl-3 {\n    margin-left: 25%;\n  }\n  .offset-xl-4 {\n    margin-left: 33.333333%;\n  }\n  .offset-xl-5 {\n    margin-left: 41.666667%;\n  }\n  .offset-xl-6 {\n    margin-left: 50%;\n  }\n  .offset-xl-7 {\n    margin-left: 58.333333%;\n  }\n  .offset-xl-8 {\n    margin-left: 66.666667%;\n  }\n  .offset-xl-9 {\n    margin-left: 75%;\n  }\n  .offset-xl-10 {\n    margin-left: 83.333333%;\n  }\n  .offset-xl-11 {\n    margin-left: 91.666667%;\n  }\n}\n\n.table {\n  width: 100%;\n  max-width: 100%;\n  margin-bottom: 1rem;\n}\n\n.table th,\n.table td {\n  padding: 0.75rem;\n  vertical-align: top;\n  border-top: 1px solid #eceeef;\n}\n\n.table thead th {\n  vertical-align: bottom;\n  border-bottom: 2px solid #eceeef;\n}\n\n.table tbody + tbody {\n  border-top: 2px solid #eceeef;\n}\n\n.table .table {\n  background-color: #fff;\n}\n\n.table-sm th,\n.table-sm td {\n  padding: 0.3rem;\n}\n\n.table-bordered {\n  border: 1px solid #eceeef;\n}\n\n.table-bordered th,\n.table-bordered td {\n  border: 1px solid #eceeef;\n}\n\n.table-bordered thead th,\n.table-bordered thead td {\n  border-bottom-width: 2px;\n}\n\n.table-striped tbody tr:nth-of-type(odd) {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.table-hover tbody tr:hover {\n  background-color: rgba(0, 0, 0, 0.075);\n}\n\n.table-active,\n.table-active > th,\n.table-active > td {\n  background-color: rgba(0, 0, 0, 0.075);\n}\n\n.table-hover .table-active:hover {\n  background-color: rgba(0, 0, 0, 0.075);\n}\n\n.table-hover .table-active:hover > td,\n.table-hover .table-active:hover > th {\n  background-color: rgba(0, 0, 0, 0.075);\n}\n\n.table-success,\n.table-success > th,\n.table-success > td {\n  background-color: #dff0d8;\n}\n\n.table-hover .table-success:hover {\n  background-color: #d0e9c6;\n}\n\n.table-hover .table-success:hover > td,\n.table-hover .table-success:hover > th {\n  background-color: #d0e9c6;\n}\n\n.table-info,\n.table-info > th,\n.table-info > td {\n  background-color: #d9edf7;\n}\n\n.table-hover .table-info:hover {\n  background-color: #c4e3f3;\n}\n\n.table-hover .table-info:hover > td,\n.table-hover .table-info:hover > th {\n  background-color: #c4e3f3;\n}\n\n.table-warning,\n.table-warning > th,\n.table-warning > td {\n  background-color: #fcf8e3;\n}\n\n.table-hover .table-warning:hover {\n  background-color: #faf2cc;\n}\n\n.table-hover .table-warning:hover > td,\n.table-hover .table-warning:hover > th {\n  background-color: #faf2cc;\n}\n\n.table-danger,\n.table-danger > th,\n.table-danger > td {\n  background-color: #f2dede;\n}\n\n.table-hover .table-danger:hover {\n  background-color: #ebcccc;\n}\n\n.table-hover .table-danger:hover > td,\n.table-hover .table-danger:hover > th {\n  background-color: #ebcccc;\n}\n\n.thead-inverse th {\n  color: #fff;\n  background-color: #373a3c;\n}\n\n.thead-default th {\n  color: #55595c;\n  background-color: #eceeef;\n}\n\n.table-inverse {\n  color: #eceeef;\n  background-color: #373a3c;\n}\n\n.table-inverse th,\n.table-inverse td,\n.table-inverse thead th {\n  border-color: #55595c;\n}\n\n.table-inverse.table-bordered {\n  border: 0;\n}\n\n.table-responsive {\n  display: block;\n  width: 100%;\n  min-height: .01%;\n  overflow-x: auto;\n}\n\n.table-reflow thead {\n  float: left;\n}\n\n.table-reflow tbody {\n  display: block;\n  white-space: nowrap;\n}\n\n.table-reflow th,\n.table-reflow td {\n  border-top: 1px solid #eceeef;\n  border-left: 1px solid #eceeef;\n}\n\n.table-reflow th:last-child,\n.table-reflow td:last-child {\n  border-right: 1px solid #eceeef;\n}\n\n.table-reflow thead:last-child tr:last-child th,\n.table-reflow thead:last-child tr:last-child td,\n.table-reflow tbody:last-child tr:last-child th,\n.table-reflow tbody:last-child tr:last-child td,\n.table-reflow tfoot:last-child tr:last-child th,\n.table-reflow tfoot:last-child tr:last-child td {\n  border-bottom: 1px solid #eceeef;\n}\n\n.table-reflow tr {\n  float: left;\n}\n\n.table-reflow tr th,\n.table-reflow tr td {\n  display: block !important;\n  border: 1px solid #eceeef;\n}\n\n.form-control {\n  display: block;\n  width: 100%;\n  padding: 0.5rem 0.75rem;\n  font-size: 1rem;\n  line-height: 1.25;\n  color: #55595c;\n  background-color: #fff;\n  background-image: none;\n  -webkit-background-clip: padding-box;\n          background-clip: padding-box;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  border-radius: 0.25rem;\n}\n\n.form-control::-ms-expand {\n  background-color: transparent;\n  border: 0;\n}\n\n.form-control:focus {\n  color: #55595c;\n  background-color: #fff;\n  border-color: #66afe9;\n  outline: none;\n}\n\n.form-control::-webkit-input-placeholder {\n  color: #999;\n  opacity: 1;\n}\n\n.form-control::-moz-placeholder {\n  color: #999;\n  opacity: 1;\n}\n\n.form-control:-ms-input-placeholder {\n  color: #999;\n  opacity: 1;\n}\n\n.form-control::placeholder {\n  color: #999;\n  opacity: 1;\n}\n\n.form-control:disabled, .form-control[readonly] {\n  background-color: #eceeef;\n  opacity: 1;\n}\n\n.form-control:disabled {\n  cursor: not-allowed;\n}\n\nselect.form-control:not([size]):not([multiple]) {\n  height: 2.5rem;\n}\n\nselect.form-control:focus::-ms-value {\n  color: #55595c;\n  background-color: #fff;\n}\n\n.form-control-file,\n.form-control-range {\n  display: block;\n}\n\n.col-form-label {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n  margin-bottom: 0;\n}\n\n.col-form-label-lg {\n  padding-top: 0.75rem;\n  padding-bottom: 0.75rem;\n  font-size: 1.25rem;\n}\n\n.col-form-label-sm {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n  font-size: 0.875rem;\n}\n\n.col-form-legend {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n  margin-bottom: 0;\n  font-size: 1rem;\n}\n\n.form-control-static {\n  min-height: 2.5rem;\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n  margin-bottom: 0;\n}\n\n.form-control-static.form-control-sm, .input-group-sm > .form-control-static.form-control,\n.input-group-sm > .form-control-static.input-group-addon,\n.input-group-sm > .input-group-btn > .form-control-static.btn, .form-control-static.form-control-lg, .input-group-lg > .form-control-static.form-control,\n.input-group-lg > .form-control-static.input-group-addon,\n.input-group-lg > .input-group-btn > .form-control-static.btn {\n  padding-right: 0;\n  padding-left: 0;\n}\n\n.form-control-sm, .input-group-sm > .form-control,\n.input-group-sm > .input-group-addon,\n.input-group-sm > .input-group-btn > .btn {\n  padding: 0.25rem 0.5rem;\n  font-size: 0.875rem;\n  border-radius: 0.2rem;\n}\n\nselect.form-control-sm:not([size]):not([multiple]), .input-group-sm > select.form-control:not([size]):not([multiple]),\n.input-group-sm > select.input-group-addon:not([size]):not([multiple]),\n.input-group-sm > .input-group-btn > select.btn:not([size]):not([multiple]) {\n  height: 1.8125rem;\n}\n\n.form-control-lg, .input-group-lg > .form-control,\n.input-group-lg > .input-group-addon,\n.input-group-lg > .input-group-btn > .btn {\n  padding: 0.75rem 1.5rem;\n  font-size: 1.25rem;\n  border-radius: 0.3rem;\n}\n\nselect.form-control-lg:not([size]):not([multiple]), .input-group-lg > select.form-control:not([size]):not([multiple]),\n.input-group-lg > select.input-group-addon:not([size]):not([multiple]),\n.input-group-lg > .input-group-btn > select.btn:not([size]):not([multiple]) {\n  height: 3.166667rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\n.form-text {\n  display: block;\n  margin-top: 0.25rem;\n}\n\n.form-check {\n  position: relative;\n  display: block;\n  margin-bottom: 0.75rem;\n}\n\n.form-check + .form-check {\n  margin-top: -.25rem;\n}\n\n.form-check.disabled .form-check-label {\n  color: #818a91;\n  cursor: not-allowed;\n}\n\n.form-check-label {\n  padding-left: 1.25rem;\n  margin-bottom: 0;\n  cursor: pointer;\n}\n\n.form-check-input {\n  position: absolute;\n  margin-top: .25rem;\n  margin-left: -1.25rem;\n}\n\n.form-check-input:only-child {\n  position: static;\n}\n\n.form-check-inline {\n  position: relative;\n  display: inline-block;\n  padding-left: 1.25rem;\n  margin-bottom: 0;\n  vertical-align: middle;\n  cursor: pointer;\n}\n\n.form-check-inline + .form-check-inline {\n  margin-left: .75rem;\n}\n\n.form-check-inline.disabled {\n  cursor: not-allowed;\n}\n\n.form-control-feedback {\n  margin-top: 0.25rem;\n}\n\n.form-control-success,\n.form-control-warning,\n.form-control-danger {\n  padding-right: 2.25rem;\n  background-repeat: no-repeat;\n  background-position: center right 0.625rem;\n  -webkit-background-size: 1.25rem 1.25rem;\n          background-size: 1.25rem 1.25rem;\n}\n\n.has-success .form-control-feedback,\n.has-success .form-control-label,\n.has-success .form-check-label,\n.has-success .form-check-inline,\n.has-success .custom-control {\n  color: #5cb85c;\n}\n\n.has-success .form-control {\n  border-color: #5cb85c;\n}\n\n.has-success .input-group-addon {\n  color: #5cb85c;\n  border-color: #5cb85c;\n  background-color: #eaf6ea;\n}\n\n.has-success .form-control-feedback {\n  color: #5cb85c;\n}\n\n.has-success .form-control-success {\n  background-image: url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%235cb85c' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3E%3C/svg%3E\");\n}\n\n.has-warning .form-control-feedback,\n.has-warning .form-control-label,\n.has-warning .form-check-label,\n.has-warning .form-check-inline,\n.has-warning .custom-control {\n  color: #f0ad4e;\n}\n\n.has-warning .form-control {\n  border-color: #f0ad4e;\n}\n\n.has-warning .input-group-addon {\n  color: #f0ad4e;\n  border-color: #f0ad4e;\n  background-color: white;\n}\n\n.has-warning .form-control-feedback {\n  color: #f0ad4e;\n}\n\n.has-warning .form-control-warning {\n  background-image: url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23f0ad4e' d='M4.4 5.324h-.8v-2.46h.8zm0 1.42h-.8V5.89h.8zM3.76.63L.04 7.075c-.115.2.016.425.26.426h7.397c.242 0 .372-.226.258-.426C6.726 4.924 5.47 2.79 4.253.63c-.113-.174-.39-.174-.494 0z'/%3E%3C/svg%3E\");\n}\n\n.has-danger .form-control-feedback,\n.has-danger .form-control-label,\n.has-danger .form-check-label,\n.has-danger .form-check-inline,\n.has-danger .custom-control {\n  color: #d9534f;\n}\n\n.has-danger .form-control {\n  border-color: #d9534f;\n}\n\n.has-danger .input-group-addon {\n  color: #d9534f;\n  border-color: #d9534f;\n  background-color: #fdf7f7;\n}\n\n.has-danger .form-control-feedback {\n  color: #d9534f;\n}\n\n.has-danger .form-control-danger {\n  background-image: url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23d9534f' viewBox='-2 -2 7 7'%3E%3Cpath stroke='%23d9534f' d='M0 0l3 3m0-3L0 3'/%3E%3Ccircle r='.5'/%3E%3Ccircle cx='3' r='.5'/%3E%3Ccircle cy='3' r='.5'/%3E%3Ccircle cx='3' cy='3' r='.5'/%3E%3C/svg%3E\");\n}\n\n@media (min-width: 544px) {\n  .form-inline .form-group {\n    display: inline-block;\n    margin-bottom: 0;\n    vertical-align: middle;\n  }\n  .form-inline .form-control {\n    display: inline-block;\n    width: auto;\n    vertical-align: middle;\n  }\n  .form-inline .form-control-static {\n    display: inline-block;\n  }\n  .form-inline .input-group {\n    display: inline-table;\n    vertical-align: middle;\n  }\n  .form-inline .input-group .input-group-addon,\n  .form-inline .input-group .input-group-btn,\n  .form-inline .input-group .form-control {\n    width: auto;\n  }\n  .form-inline .input-group > .form-control {\n    width: 100%;\n  }\n  .form-inline .form-control-label {\n    margin-bottom: 0;\n    vertical-align: middle;\n  }\n  .form-inline .form-check {\n    display: inline-block;\n    margin-top: 0;\n    margin-bottom: 0;\n    vertical-align: middle;\n  }\n  .form-inline .form-check-label {\n    padding-left: 0;\n  }\n  .form-inline .form-check-input {\n    position: relative;\n    margin-left: 0;\n  }\n  .form-inline .has-feedback .form-control-feedback {\n    top: 0;\n  }\n}\n\n.btn {\n  display: inline-block;\n  font-weight: normal;\n  line-height: 1.25;\n  text-align: center;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  border: 1px solid transparent;\n  padding: 0.5rem 1rem;\n  font-size: 1rem;\n  border-radius: 0.25rem;\n}\n\n.btn:focus, .btn.focus, .btn:active:focus, .btn:active.focus, .btn.active:focus, .btn.active.focus {\n  outline: 5px auto -webkit-focus-ring-color;\n  outline-offset: -2px;\n}\n\n.btn:focus, .btn:hover {\n  text-decoration: none;\n}\n\n.btn.focus {\n  text-decoration: none;\n}\n\n.btn:active, .btn.active {\n  background-image: none;\n  outline: 0;\n}\n\n.btn.disabled, .btn:disabled {\n  cursor: not-allowed;\n  opacity: .65;\n}\n\na.btn.disabled,\nfieldset[disabled] a.btn {\n  pointer-events: none;\n}\n\n.btn-primary {\n  color: #fff;\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.btn-primary:hover {\n  color: #fff;\n  background-color: #025aa5;\n  border-color: #01549b;\n}\n\n.btn-primary:focus, .btn-primary.focus {\n  color: #fff;\n  background-color: #025aa5;\n  border-color: #01549b;\n}\n\n.btn-primary:active, .btn-primary.active,\n.open > .btn-primary.dropdown-toggle {\n  color: #fff;\n  background-color: #025aa5;\n  border-color: #01549b;\n  background-image: none;\n}\n\n.btn-primary:active:hover, .btn-primary:active:focus, .btn-primary:active.focus, .btn-primary.active:hover, .btn-primary.active:focus, .btn-primary.active.focus,\n.open > .btn-primary.dropdown-toggle:hover,\n.open > .btn-primary.dropdown-toggle:focus,\n.open > .btn-primary.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #014682;\n  border-color: #01315a;\n}\n\n.btn-primary.disabled:focus, .btn-primary.disabled.focus, .btn-primary:disabled:focus, .btn-primary:disabled.focus {\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.btn-primary.disabled:hover, .btn-primary:disabled:hover {\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.btn-secondary {\n  color: #373a3c;\n  background-color: #fff;\n  border-color: #ccc;\n}\n\n.btn-secondary:hover {\n  color: #373a3c;\n  background-color: #e6e6e6;\n  border-color: #adadad;\n}\n\n.btn-secondary:focus, .btn-secondary.focus {\n  color: #373a3c;\n  background-color: #e6e6e6;\n  border-color: #adadad;\n}\n\n.btn-secondary:active, .btn-secondary.active,\n.open > .btn-secondary.dropdown-toggle {\n  color: #373a3c;\n  background-color: #e6e6e6;\n  border-color: #adadad;\n  background-image: none;\n}\n\n.btn-secondary:active:hover, .btn-secondary:active:focus, .btn-secondary:active.focus, .btn-secondary.active:hover, .btn-secondary.active:focus, .btn-secondary.active.focus,\n.open > .btn-secondary.dropdown-toggle:hover,\n.open > .btn-secondary.dropdown-toggle:focus,\n.open > .btn-secondary.dropdown-toggle.focus {\n  color: #373a3c;\n  background-color: #d4d4d4;\n  border-color: #8c8c8c;\n}\n\n.btn-secondary.disabled:focus, .btn-secondary.disabled.focus, .btn-secondary:disabled:focus, .btn-secondary:disabled.focus {\n  background-color: #fff;\n  border-color: #ccc;\n}\n\n.btn-secondary.disabled:hover, .btn-secondary:disabled:hover {\n  background-color: #fff;\n  border-color: #ccc;\n}\n\n.btn-info {\n  color: #fff;\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.btn-info:hover {\n  color: #fff;\n  background-color: #31b0d5;\n  border-color: #2aabd2;\n}\n\n.btn-info:focus, .btn-info.focus {\n  color: #fff;\n  background-color: #31b0d5;\n  border-color: #2aabd2;\n}\n\n.btn-info:active, .btn-info.active,\n.open > .btn-info.dropdown-toggle {\n  color: #fff;\n  background-color: #31b0d5;\n  border-color: #2aabd2;\n  background-image: none;\n}\n\n.btn-info:active:hover, .btn-info:active:focus, .btn-info:active.focus, .btn-info.active:hover, .btn-info.active:focus, .btn-info.active.focus,\n.open > .btn-info.dropdown-toggle:hover,\n.open > .btn-info.dropdown-toggle:focus,\n.open > .btn-info.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #269abc;\n  border-color: #1f7e9a;\n}\n\n.btn-info.disabled:focus, .btn-info.disabled.focus, .btn-info:disabled:focus, .btn-info:disabled.focus {\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.btn-info.disabled:hover, .btn-info:disabled:hover {\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.btn-success {\n  color: #fff;\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.btn-success:hover {\n  color: #fff;\n  background-color: #449d44;\n  border-color: #419641;\n}\n\n.btn-success:focus, .btn-success.focus {\n  color: #fff;\n  background-color: #449d44;\n  border-color: #419641;\n}\n\n.btn-success:active, .btn-success.active,\n.open > .btn-success.dropdown-toggle {\n  color: #fff;\n  background-color: #449d44;\n  border-color: #419641;\n  background-image: none;\n}\n\n.btn-success:active:hover, .btn-success:active:focus, .btn-success:active.focus, .btn-success.active:hover, .btn-success.active:focus, .btn-success.active.focus,\n.open > .btn-success.dropdown-toggle:hover,\n.open > .btn-success.dropdown-toggle:focus,\n.open > .btn-success.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #398439;\n  border-color: #2d672d;\n}\n\n.btn-success.disabled:focus, .btn-success.disabled.focus, .btn-success:disabled:focus, .btn-success:disabled.focus {\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.btn-success.disabled:hover, .btn-success:disabled:hover {\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.btn-warning {\n  color: #fff;\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.btn-warning:hover {\n  color: #fff;\n  background-color: #ec971f;\n  border-color: #eb9316;\n}\n\n.btn-warning:focus, .btn-warning.focus {\n  color: #fff;\n  background-color: #ec971f;\n  border-color: #eb9316;\n}\n\n.btn-warning:active, .btn-warning.active,\n.open > .btn-warning.dropdown-toggle {\n  color: #fff;\n  background-color: #ec971f;\n  border-color: #eb9316;\n  background-image: none;\n}\n\n.btn-warning:active:hover, .btn-warning:active:focus, .btn-warning:active.focus, .btn-warning.active:hover, .btn-warning.active:focus, .btn-warning.active.focus,\n.open > .btn-warning.dropdown-toggle:hover,\n.open > .btn-warning.dropdown-toggle:focus,\n.open > .btn-warning.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #d58512;\n  border-color: #b06d0f;\n}\n\n.btn-warning.disabled:focus, .btn-warning.disabled.focus, .btn-warning:disabled:focus, .btn-warning:disabled.focus {\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.btn-warning.disabled:hover, .btn-warning:disabled:hover {\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.btn-danger {\n  color: #fff;\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.btn-danger:hover {\n  color: #fff;\n  background-color: #c9302c;\n  border-color: #c12e2a;\n}\n\n.btn-danger:focus, .btn-danger.focus {\n  color: #fff;\n  background-color: #c9302c;\n  border-color: #c12e2a;\n}\n\n.btn-danger:active, .btn-danger.active,\n.open > .btn-danger.dropdown-toggle {\n  color: #fff;\n  background-color: #c9302c;\n  border-color: #c12e2a;\n  background-image: none;\n}\n\n.btn-danger:active:hover, .btn-danger:active:focus, .btn-danger:active.focus, .btn-danger.active:hover, .btn-danger.active:focus, .btn-danger.active.focus,\n.open > .btn-danger.dropdown-toggle:hover,\n.open > .btn-danger.dropdown-toggle:focus,\n.open > .btn-danger.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #ac2925;\n  border-color: #8b211e;\n}\n\n.btn-danger.disabled:focus, .btn-danger.disabled.focus, .btn-danger:disabled:focus, .btn-danger:disabled.focus {\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.btn-danger.disabled:hover, .btn-danger:disabled:hover {\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.btn-outline-primary {\n  color: #0275d8;\n  background-image: none;\n  background-color: transparent;\n  border-color: #0275d8;\n}\n\n.btn-outline-primary:hover {\n  color: #fff;\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.btn-outline-primary:focus, .btn-outline-primary.focus {\n  color: #fff;\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.btn-outline-primary:active, .btn-outline-primary.active,\n.open > .btn-outline-primary.dropdown-toggle {\n  color: #fff;\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.btn-outline-primary:active:hover, .btn-outline-primary:active:focus, .btn-outline-primary:active.focus, .btn-outline-primary.active:hover, .btn-outline-primary.active:focus, .btn-outline-primary.active.focus,\n.open > .btn-outline-primary.dropdown-toggle:hover,\n.open > .btn-outline-primary.dropdown-toggle:focus,\n.open > .btn-outline-primary.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #014682;\n  border-color: #01315a;\n}\n\n.btn-outline-primary.disabled:focus, .btn-outline-primary.disabled.focus, .btn-outline-primary:disabled:focus, .btn-outline-primary:disabled.focus {\n  border-color: #43a7fd;\n}\n\n.btn-outline-primary.disabled:hover, .btn-outline-primary:disabled:hover {\n  border-color: #43a7fd;\n}\n\n.btn-outline-secondary {\n  color: #ccc;\n  background-image: none;\n  background-color: transparent;\n  border-color: #ccc;\n}\n\n.btn-outline-secondary:hover {\n  color: #fff;\n  background-color: #ccc;\n  border-color: #ccc;\n}\n\n.btn-outline-secondary:focus, .btn-outline-secondary.focus {\n  color: #fff;\n  background-color: #ccc;\n  border-color: #ccc;\n}\n\n.btn-outline-secondary:active, .btn-outline-secondary.active,\n.open > .btn-outline-secondary.dropdown-toggle {\n  color: #fff;\n  background-color: #ccc;\n  border-color: #ccc;\n}\n\n.btn-outline-secondary:active:hover, .btn-outline-secondary:active:focus, .btn-outline-secondary:active.focus, .btn-outline-secondary.active:hover, .btn-outline-secondary.active:focus, .btn-outline-secondary.active.focus,\n.open > .btn-outline-secondary.dropdown-toggle:hover,\n.open > .btn-outline-secondary.dropdown-toggle:focus,\n.open > .btn-outline-secondary.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #a1a1a1;\n  border-color: #8c8c8c;\n}\n\n.btn-outline-secondary.disabled:focus, .btn-outline-secondary.disabled.focus, .btn-outline-secondary:disabled:focus, .btn-outline-secondary:disabled.focus {\n  border-color: white;\n}\n\n.btn-outline-secondary.disabled:hover, .btn-outline-secondary:disabled:hover {\n  border-color: white;\n}\n\n.btn-outline-info {\n  color: #5bc0de;\n  background-image: none;\n  background-color: transparent;\n  border-color: #5bc0de;\n}\n\n.btn-outline-info:hover {\n  color: #fff;\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.btn-outline-info:focus, .btn-outline-info.focus {\n  color: #fff;\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.btn-outline-info:active, .btn-outline-info.active,\n.open > .btn-outline-info.dropdown-toggle {\n  color: #fff;\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.btn-outline-info:active:hover, .btn-outline-info:active:focus, .btn-outline-info:active.focus, .btn-outline-info.active:hover, .btn-outline-info.active:focus, .btn-outline-info.active.focus,\n.open > .btn-outline-info.dropdown-toggle:hover,\n.open > .btn-outline-info.dropdown-toggle:focus,\n.open > .btn-outline-info.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #269abc;\n  border-color: #1f7e9a;\n}\n\n.btn-outline-info.disabled:focus, .btn-outline-info.disabled.focus, .btn-outline-info:disabled:focus, .btn-outline-info:disabled.focus {\n  border-color: #b0e1ef;\n}\n\n.btn-outline-info.disabled:hover, .btn-outline-info:disabled:hover {\n  border-color: #b0e1ef;\n}\n\n.btn-outline-success {\n  color: #5cb85c;\n  background-image: none;\n  background-color: transparent;\n  border-color: #5cb85c;\n}\n\n.btn-outline-success:hover {\n  color: #fff;\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.btn-outline-success:focus, .btn-outline-success.focus {\n  color: #fff;\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.btn-outline-success:active, .btn-outline-success.active,\n.open > .btn-outline-success.dropdown-toggle {\n  color: #fff;\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.btn-outline-success:active:hover, .btn-outline-success:active:focus, .btn-outline-success:active.focus, .btn-outline-success.active:hover, .btn-outline-success.active:focus, .btn-outline-success.active.focus,\n.open > .btn-outline-success.dropdown-toggle:hover,\n.open > .btn-outline-success.dropdown-toggle:focus,\n.open > .btn-outline-success.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #398439;\n  border-color: #2d672d;\n}\n\n.btn-outline-success.disabled:focus, .btn-outline-success.disabled.focus, .btn-outline-success:disabled:focus, .btn-outline-success:disabled.focus {\n  border-color: #a3d7a3;\n}\n\n.btn-outline-success.disabled:hover, .btn-outline-success:disabled:hover {\n  border-color: #a3d7a3;\n}\n\n.btn-outline-warning {\n  color: #f0ad4e;\n  background-image: none;\n  background-color: transparent;\n  border-color: #f0ad4e;\n}\n\n.btn-outline-warning:hover {\n  color: #fff;\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.btn-outline-warning:focus, .btn-outline-warning.focus {\n  color: #fff;\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.btn-outline-warning:active, .btn-outline-warning.active,\n.open > .btn-outline-warning.dropdown-toggle {\n  color: #fff;\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.btn-outline-warning:active:hover, .btn-outline-warning:active:focus, .btn-outline-warning:active.focus, .btn-outline-warning.active:hover, .btn-outline-warning.active:focus, .btn-outline-warning.active.focus,\n.open > .btn-outline-warning.dropdown-toggle:hover,\n.open > .btn-outline-warning.dropdown-toggle:focus,\n.open > .btn-outline-warning.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #d58512;\n  border-color: #b06d0f;\n}\n\n.btn-outline-warning.disabled:focus, .btn-outline-warning.disabled.focus, .btn-outline-warning:disabled:focus, .btn-outline-warning:disabled.focus {\n  border-color: #f8d9ac;\n}\n\n.btn-outline-warning.disabled:hover, .btn-outline-warning:disabled:hover {\n  border-color: #f8d9ac;\n}\n\n.btn-outline-danger {\n  color: #d9534f;\n  background-image: none;\n  background-color: transparent;\n  border-color: #d9534f;\n}\n\n.btn-outline-danger:hover {\n  color: #fff;\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.btn-outline-danger:focus, .btn-outline-danger.focus {\n  color: #fff;\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.btn-outline-danger:active, .btn-outline-danger.active,\n.open > .btn-outline-danger.dropdown-toggle {\n  color: #fff;\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.btn-outline-danger:active:hover, .btn-outline-danger:active:focus, .btn-outline-danger:active.focus, .btn-outline-danger.active:hover, .btn-outline-danger.active:focus, .btn-outline-danger.active.focus,\n.open > .btn-outline-danger.dropdown-toggle:hover,\n.open > .btn-outline-danger.dropdown-toggle:focus,\n.open > .btn-outline-danger.dropdown-toggle.focus {\n  color: #fff;\n  background-color: #ac2925;\n  border-color: #8b211e;\n}\n\n.btn-outline-danger.disabled:focus, .btn-outline-danger.disabled.focus, .btn-outline-danger:disabled:focus, .btn-outline-danger:disabled.focus {\n  border-color: #eba5a3;\n}\n\n.btn-outline-danger.disabled:hover, .btn-outline-danger:disabled:hover {\n  border-color: #eba5a3;\n}\n\n.btn-link {\n  font-weight: normal;\n  color: #0275d8;\n  border-radius: 0;\n}\n\n.btn-link, .btn-link:active, .btn-link.active, .btn-link:disabled {\n  background-color: transparent;\n}\n\n.btn-link, .btn-link:focus, .btn-link:active {\n  border-color: transparent;\n}\n\n.btn-link:hover {\n  border-color: transparent;\n}\n\n.btn-link:focus, .btn-link:hover {\n  color: #014c8c;\n  text-decoration: underline;\n  background-color: transparent;\n}\n\n.btn-link:disabled:focus, .btn-link:disabled:hover {\n  color: #818a91;\n  text-decoration: none;\n}\n\n.btn-lg, .btn-group-lg > .btn {\n  padding: 0.75rem 1.5rem;\n  font-size: 1.25rem;\n  border-radius: 0.3rem;\n}\n\n.btn-sm, .btn-group-sm > .btn {\n  padding: 0.25rem 0.5rem;\n  font-size: 0.875rem;\n  border-radius: 0.2rem;\n}\n\n.btn-block {\n  display: block;\n  width: 100%;\n}\n\n.btn-block + .btn-block {\n  margin-top: 0.5rem;\n}\n\ninput[type=\"submit\"].btn-block,\ninput[type=\"reset\"].btn-block,\ninput[type=\"button\"].btn-block {\n  width: 100%;\n}\n\n.fade {\n  opacity: 0;\n  -webkit-transition: opacity .15s linear;\n  -o-transition: opacity .15s linear;\n  transition: opacity .15s linear;\n}\n\n.fade.in {\n  opacity: 1;\n}\n\n.collapse {\n  display: none;\n}\n\n.collapse.in {\n  display: block;\n}\n\n.collapsing {\n  position: relative;\n  height: 0;\n  overflow: hidden;\n  -webkit-transition-timing-function: ease;\n       -o-transition-timing-function: ease;\n          transition-timing-function: ease;\n  -webkit-transition-duration: .35s;\n       -o-transition-duration: .35s;\n          transition-duration: .35s;\n  -webkit-transition-property: height;\n  -o-transition-property: height;\n  transition-property: height;\n}\n\n.dropup,\n.dropdown {\n  position: relative;\n}\n\n.dropdown-toggle::after {\n  display: inline-block;\n  width: 0;\n  height: 0;\n  margin-left: 0.3em;\n  vertical-align: middle;\n  content: \"\";\n  border-top: 0.3em solid;\n  border-right: 0.3em solid transparent;\n  border-left: 0.3em solid transparent;\n}\n\n.dropdown-toggle:focus {\n  outline: 0;\n}\n\n.dropup .dropdown-toggle::after {\n  border-top: 0;\n  border-bottom: 0.3em solid;\n}\n\n.dropdown-menu {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  z-index: 1000;\n  display: none;\n  float: left;\n  min-width: 160px;\n  padding: 5px 0;\n  margin: 2px 0 0;\n  font-size: 1rem;\n  color: #373a3c;\n  text-align: left;\n  list-style: none;\n  background-color: #fff;\n  -webkit-background-clip: padding-box;\n          background-clip: padding-box;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  border-radius: 0.25rem;\n}\n\n.dropdown-divider {\n  height: 1px;\n  margin: 0.5rem 0;\n  overflow: hidden;\n  background-color: #e5e5e5;\n}\n\n.dropdown-item {\n  display: block;\n  width: 100%;\n  padding: 3px 20px;\n  clear: both;\n  font-weight: normal;\n  color: #373a3c;\n  text-align: inherit;\n  white-space: nowrap;\n  background: none;\n  border: 0;\n}\n\n.dropdown-item:focus, .dropdown-item:hover {\n  color: #2b2d2f;\n  text-decoration: none;\n  background-color: #f5f5f5;\n}\n\n.dropdown-item.active, .dropdown-item.active:focus, .dropdown-item.active:hover {\n  color: #fff;\n  text-decoration: none;\n  background-color: #0275d8;\n  outline: 0;\n}\n\n.dropdown-item.disabled, .dropdown-item.disabled:focus, .dropdown-item.disabled:hover {\n  color: #818a91;\n}\n\n.dropdown-item.disabled:focus, .dropdown-item.disabled:hover {\n  text-decoration: none;\n  cursor: not-allowed;\n  background-color: transparent;\n  background-image: none;\n  filter: \"progid:DXImageTransform.Microsoft.gradient(enabled = false)\";\n}\n\n.open > .dropdown-menu {\n  display: block;\n}\n\n.open > a {\n  outline: 0;\n}\n\n.dropdown-menu-right {\n  right: 0;\n  left: auto;\n}\n\n.dropdown-menu-left {\n  right: auto;\n  left: 0;\n}\n\n.dropdown-header {\n  display: block;\n  padding: 5px 20px;\n  font-size: 0.875rem;\n  color: #818a91;\n  white-space: nowrap;\n}\n\n.dropdown-backdrop {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 990;\n}\n\n.dropup .caret,\n.navbar-fixed-bottom .dropdown .caret {\n  content: \"\";\n  border-top: 0;\n  border-bottom: 0.3em solid;\n}\n\n.dropup .dropdown-menu,\n.navbar-fixed-bottom .dropdown .dropdown-menu {\n  top: auto;\n  bottom: 100%;\n  margin-bottom: 2px;\n}\n\n.btn-group,\n.btn-group-vertical {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.btn-group > .btn,\n.btn-group-vertical > .btn {\n  position: relative;\n  float: left;\n}\n\n.btn-group > .btn:focus, .btn-group > .btn:active, .btn-group > .btn.active,\n.btn-group-vertical > .btn:focus,\n.btn-group-vertical > .btn:active,\n.btn-group-vertical > .btn.active {\n  z-index: 2;\n}\n\n.btn-group > .btn:hover,\n.btn-group-vertical > .btn:hover {\n  z-index: 2;\n}\n\n.btn-group .btn + .btn,\n.btn-group .btn + .btn-group,\n.btn-group .btn-group + .btn,\n.btn-group .btn-group + .btn-group {\n  margin-left: -1px;\n}\n\n.btn-toolbar {\n  margin-left: -0.5rem;\n}\n\n.btn-toolbar::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.btn-toolbar .btn-group,\n.btn-toolbar .input-group {\n  float: left;\n}\n\n.btn-toolbar > .btn,\n.btn-toolbar > .btn-group,\n.btn-toolbar > .input-group {\n  margin-left: 0.5rem;\n}\n\n.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {\n  border-radius: 0;\n}\n\n.btn-group > .btn:first-child {\n  margin-left: 0;\n}\n\n.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.btn-group > .btn:last-child:not(:first-child),\n.btn-group > .dropdown-toggle:not(:first-child) {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0;\n}\n\n.btn-group > .btn-group {\n  float: left;\n}\n\n.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {\n  border-radius: 0;\n}\n\n.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,\n.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0;\n}\n\n.btn-group .dropdown-toggle:active,\n.btn-group.open .dropdown-toggle {\n  outline: 0;\n}\n\n.btn + .dropdown-toggle-split {\n  padding-right: 0.75rem;\n  padding-left: 0.75rem;\n}\n\n.btn + .dropdown-toggle-split::after {\n  margin-left: 0;\n}\n\n.btn-sm + .dropdown-toggle-split, .btn-group-sm > .btn + .dropdown-toggle-split {\n  padding-right: 0.375rem;\n  padding-left: 0.375rem;\n}\n\n.btn-lg + .dropdown-toggle-split, .btn-group-lg > .btn + .dropdown-toggle-split {\n  padding-right: 1.125rem;\n  padding-left: 1.125rem;\n}\n\n.btn .caret {\n  margin-left: 0;\n}\n\n.btn-lg .caret, .btn-group-lg > .btn .caret {\n  border-width: 0.3em 0.3em 0;\n  border-bottom-width: 0;\n}\n\n.dropup .btn-lg .caret, .dropup .btn-group-lg > .btn .caret {\n  border-width: 0 0.3em 0.3em;\n}\n\n.btn-group-vertical > .btn,\n.btn-group-vertical > .btn-group,\n.btn-group-vertical > .btn-group > .btn {\n  display: block;\n  float: none;\n  width: 100%;\n  max-width: 100%;\n}\n\n.btn-group-vertical > .btn-group::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.btn-group-vertical > .btn-group > .btn {\n  float: none;\n}\n\n.btn-group-vertical > .btn + .btn,\n.btn-group-vertical > .btn + .btn-group,\n.btn-group-vertical > .btn-group + .btn,\n.btn-group-vertical > .btn-group + .btn-group {\n  margin-top: -1px;\n  margin-left: 0;\n}\n\n.btn-group-vertical > .btn:not(:first-child):not(:last-child) {\n  border-radius: 0;\n}\n\n.btn-group-vertical > .btn:first-child:not(:last-child) {\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.btn-group-vertical > .btn:last-child:not(:first-child) {\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n}\n\n.btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn {\n  border-radius: 0;\n}\n\n.btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child,\n.btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle {\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child {\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n}\n\n[data-toggle=\"buttons\"] > .btn input[type=\"radio\"],\n[data-toggle=\"buttons\"] > .btn input[type=\"checkbox\"],\n[data-toggle=\"buttons\"] > .btn-group > .btn input[type=\"radio\"],\n[data-toggle=\"buttons\"] > .btn-group > .btn input[type=\"checkbox\"] {\n  position: absolute;\n  clip: rect(0, 0, 0, 0);\n  pointer-events: none;\n}\n\n.input-group {\n  position: relative;\n  width: 100%;\n  display: table;\n  border-collapse: separate;\n}\n\n.input-group .form-control {\n  position: relative;\n  z-index: 2;\n  float: left;\n  width: 100%;\n  margin-bottom: 0;\n}\n\n.input-group .form-control:focus, .input-group .form-control:active, .input-group .form-control:hover {\n  z-index: 3;\n}\n\n.input-group-addon,\n.input-group-btn,\n.input-group .form-control {\n  display: table-cell;\n}\n\n.input-group-addon:not(:first-child):not(:last-child),\n.input-group-btn:not(:first-child):not(:last-child),\n.input-group .form-control:not(:first-child):not(:last-child) {\n  border-radius: 0;\n}\n\n.input-group-addon,\n.input-group-btn {\n  width: 1%;\n  white-space: nowrap;\n  vertical-align: middle;\n}\n\n.input-group-addon {\n  padding: 0.5rem 0.75rem;\n  margin-bottom: 0;\n  font-size: 1rem;\n  font-weight: normal;\n  line-height: 1.25;\n  color: #55595c;\n  text-align: center;\n  background-color: #eceeef;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  border-radius: 0.25rem;\n}\n\n.input-group-addon.form-control-sm,\n.input-group-sm > .input-group-addon,\n.input-group-sm > .input-group-btn > .input-group-addon.btn {\n  padding: 0.25rem 0.5rem;\n  font-size: 0.875rem;\n  border-radius: 0.2rem;\n}\n\n.input-group-addon.form-control-lg,\n.input-group-lg > .input-group-addon,\n.input-group-lg > .input-group-btn > .input-group-addon.btn {\n  padding: 0.75rem 1.5rem;\n  font-size: 1.25rem;\n  border-radius: 0.3rem;\n}\n\n.input-group-addon input[type=\"radio\"],\n.input-group-addon input[type=\"checkbox\"] {\n  margin-top: 0;\n}\n\n.input-group .form-control:not(:last-child),\n.input-group-addon:not(:last-child),\n.input-group-btn:not(:last-child) > .btn,\n.input-group-btn:not(:last-child) > .btn-group > .btn,\n.input-group-btn:not(:last-child) > .dropdown-toggle,\n.input-group-btn:not(:first-child) > .btn:not(:last-child):not(.dropdown-toggle),\n.input-group-btn:not(:first-child) > .btn-group:not(:last-child) > .btn {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.input-group-addon:not(:last-child) {\n  border-right: 0;\n}\n\n.input-group .form-control:not(:first-child),\n.input-group-addon:not(:first-child),\n.input-group-btn:not(:first-child) > .btn,\n.input-group-btn:not(:first-child) > .btn-group > .btn,\n.input-group-btn:not(:first-child) > .dropdown-toggle,\n.input-group-btn:not(:last-child) > .btn:not(:first-child),\n.input-group-btn:not(:last-child) > .btn-group:not(:first-child) > .btn {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0;\n}\n\n.form-control + .input-group-addon:not(:first-child) {\n  border-left: 0;\n}\n\n.input-group-btn {\n  position: relative;\n  font-size: 0;\n  white-space: nowrap;\n}\n\n.input-group-btn > .btn {\n  position: relative;\n}\n\n.input-group-btn > .btn + .btn {\n  margin-left: -1px;\n}\n\n.input-group-btn > .btn:focus, .input-group-btn > .btn:active, .input-group-btn > .btn:hover {\n  z-index: 3;\n}\n\n.input-group-btn:not(:last-child) > .btn,\n.input-group-btn:not(:last-child) > .btn-group {\n  margin-right: -1px;\n}\n\n.input-group-btn:not(:first-child) > .btn,\n.input-group-btn:not(:first-child) > .btn-group {\n  z-index: 2;\n  margin-left: -1px;\n}\n\n.input-group-btn:not(:first-child) > .btn:focus, .input-group-btn:not(:first-child) > .btn:active, .input-group-btn:not(:first-child) > .btn:hover,\n.input-group-btn:not(:first-child) > .btn-group:focus,\n.input-group-btn:not(:first-child) > .btn-group:active,\n.input-group-btn:not(:first-child) > .btn-group:hover {\n  z-index: 3;\n}\n\n.custom-control {\n  position: relative;\n  display: inline;\n  padding-left: 1.5rem;\n  cursor: pointer;\n}\n\n.custom-control + .custom-control {\n  margin-left: 1rem;\n}\n\n.custom-control-input {\n  position: absolute;\n  z-index: -1;\n  opacity: 0;\n}\n\n.custom-control-input:checked ~ .custom-control-indicator {\n  color: #fff;\n  background-color: #0074d9;\n}\n\n.custom-control-input:focus ~ .custom-control-indicator {\n  -webkit-box-shadow: 0 0 0 0.075rem #fff, 0 0 0 0.2rem #0074d9;\n          box-shadow: 0 0 0 0.075rem #fff, 0 0 0 0.2rem #0074d9;\n}\n\n.custom-control-input:active ~ .custom-control-indicator {\n  color: #fff;\n  background-color: #84c6ff;\n}\n\n.custom-control-input:disabled ~ .custom-control-indicator {\n  cursor: not-allowed;\n  background-color: #eee;\n}\n\n.custom-control-input:disabled ~ .custom-control-description {\n  color: #767676;\n  cursor: not-allowed;\n}\n\n.custom-control-indicator {\n  position: absolute;\n  top: .0625rem;\n  left: 0;\n  display: block;\n  width: 1rem;\n  height: 1rem;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  background-color: #ddd;\n  background-repeat: no-repeat;\n  background-position: center center;\n  -webkit-background-size: 50% 50%;\n          background-size: 50% 50%;\n}\n\n.custom-checkbox .custom-control-indicator {\n  border-radius: 0.25rem;\n}\n\n.custom-checkbox .custom-control-input:checked ~ .custom-control-indicator {\n  background-image: url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3E%3C/svg%3E\");\n}\n\n.custom-checkbox .custom-control-input:indeterminate ~ .custom-control-indicator {\n  background-color: #0074d9;\n  background-image: url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 4'%3E%3Cpath stroke='%23fff' d='M0 2h4'/%3E%3C/svg%3E\");\n}\n\n.custom-radio .custom-control-indicator {\n  border-radius: 50%;\n}\n\n.custom-radio .custom-control-input:checked ~ .custom-control-indicator {\n  background-image: url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3E%3Ccircle r='3' fill='%23fff'/%3E%3C/svg%3E\");\n}\n\n.custom-controls-stacked .custom-control {\n  display: inline;\n}\n\n.custom-controls-stacked .custom-control::after {\n  display: block;\n  margin-bottom: 0.25rem;\n  content: \"\";\n}\n\n.custom-controls-stacked .custom-control + .custom-control {\n  margin-left: 0;\n}\n\n.custom-select {\n  display: inline-block;\n  max-width: 100%;\n  padding: 0.375rem 1.75rem 0.375rem 0.75rem;\n  padding-right: 0.75rem \\9;\n  color: #55595c;\n  vertical-align: middle;\n  background: #fff url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E\") no-repeat right 0.75rem center;\n  background-image: none \\9;\n  -webkit-background-size: 8px 10px;\n          background-size: 8px 10px;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  border-radius: 0.25rem;\n  -moz-appearance: none;\n  -webkit-appearance: none;\n}\n\n.custom-select:focus {\n  border-color: #51a7e8;\n  outline: none;\n}\n\n.custom-select:focus::-ms-value {\n  color: #55595c;\n  background-color: #fff;\n}\n\n.custom-select:disabled {\n  color: #818a91;\n  cursor: not-allowed;\n  background-color: #eceeef;\n}\n\n.custom-select::-ms-expand {\n  opacity: 0;\n}\n\n.custom-select-sm {\n  padding-top: 0.375rem;\n  padding-bottom: 0.375rem;\n  font-size: 75%;\n}\n\n.custom-file {\n  position: relative;\n  display: inline-block;\n  max-width: 100%;\n  height: 2.5rem;\n  cursor: pointer;\n}\n\n.custom-file-input {\n  min-width: 14rem;\n  max-width: 100%;\n  margin: 0;\n  filter: alpha(opacity=0);\n  opacity: 0;\n}\n\n.custom-file-control {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  z-index: 5;\n  height: 2.5rem;\n  padding: 0.5rem 1rem;\n  line-height: 1.5;\n  color: #555;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  background-color: #fff;\n  border: 1px solid #ddd;\n  border-radius: 0.25rem;\n}\n\n.custom-file-control:lang(en)::after {\n  content: \"Choose file...\";\n}\n\n.custom-file-control::before {\n  position: absolute;\n  top: -1px;\n  right: -1px;\n  bottom: -1px;\n  z-index: 6;\n  display: block;\n  height: 2.5rem;\n  padding: 0.5rem 1rem;\n  line-height: 1.5;\n  color: #555;\n  background-color: #eee;\n  border: 1px solid #ddd;\n  border-radius: 0 0.25rem 0.25rem 0;\n}\n\n.custom-file-control:lang(en)::before {\n  content: \"Browse\";\n}\n\n.nav {\n  padding-left: 0;\n  margin-bottom: 0;\n  list-style: none;\n}\n\n.nav-link {\n  display: inline-block;\n}\n\n.nav-link:focus, .nav-link:hover {\n  text-decoration: none;\n}\n\n.nav-link.disabled {\n  color: #818a91;\n}\n\n.nav-link.disabled, .nav-link.disabled:focus, .nav-link.disabled:hover {\n  color: #818a91;\n  cursor: not-allowed;\n  background-color: transparent;\n}\n\n.nav-inline .nav-item {\n  display: inline-block;\n}\n\n.nav-inline .nav-item + .nav-item,\n.nav-inline .nav-link + .nav-link {\n  margin-left: 1rem;\n}\n\n.nav-tabs {\n  border-bottom: 1px solid #ddd;\n}\n\n.nav-tabs::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.nav-tabs .nav-item {\n  float: left;\n  margin-bottom: -1px;\n}\n\n.nav-tabs .nav-item + .nav-item {\n  margin-left: 0.2rem;\n}\n\n.nav-tabs .nav-link {\n  display: block;\n  padding: 0.5em 1em;\n  border: 1px solid transparent;\n  border-top-right-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.nav-tabs .nav-link:focus, .nav-tabs .nav-link:hover {\n  border-color: #eceeef #eceeef #ddd;\n}\n\n.nav-tabs .nav-link.disabled, .nav-tabs .nav-link.disabled:focus, .nav-tabs .nav-link.disabled:hover {\n  color: #818a91;\n  background-color: transparent;\n  border-color: transparent;\n}\n\n.nav-tabs .nav-link.active, .nav-tabs .nav-link.active:focus, .nav-tabs .nav-link.active:hover,\n.nav-tabs .nav-item.open .nav-link,\n.nav-tabs .nav-item.open .nav-link:focus,\n.nav-tabs .nav-item.open .nav-link:hover {\n  color: #55595c;\n  background-color: #fff;\n  border-color: #ddd #ddd transparent;\n}\n\n.nav-tabs .dropdown-menu {\n  margin-top: -1px;\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n}\n\n.nav-pills::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.nav-pills .nav-item {\n  float: left;\n}\n\n.nav-pills .nav-item + .nav-item {\n  margin-left: 0.2rem;\n}\n\n.nav-pills .nav-link {\n  display: block;\n  padding: 0.5em 1em;\n  border-radius: 0.25rem;\n}\n\n.nav-pills .nav-link.active, .nav-pills .nav-link.active:focus, .nav-pills .nav-link.active:hover,\n.nav-pills .nav-item.open .nav-link,\n.nav-pills .nav-item.open .nav-link:focus,\n.nav-pills .nav-item.open .nav-link:hover {\n  color: #fff;\n  cursor: default;\n  background-color: #0275d8;\n}\n\n.nav-stacked .nav-item {\n  display: block;\n  float: none;\n}\n\n.nav-stacked .nav-item + .nav-item {\n  margin-top: 0.2rem;\n  margin-left: 0;\n}\n\n.tab-content > .tab-pane {\n  display: none;\n}\n\n.tab-content > .active {\n  display: block;\n}\n\n.navbar {\n  position: relative;\n  padding: 0.5rem 1rem;\n}\n\n.navbar::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n@media (min-width: 544px) {\n  .navbar {\n    border-radius: 0.25rem;\n  }\n}\n\n.navbar-full {\n  z-index: 1000;\n}\n\n@media (min-width: 544px) {\n  .navbar-full {\n    border-radius: 0;\n  }\n}\n\n.navbar-fixed-top,\n.navbar-fixed-bottom {\n  position: fixed;\n  right: 0;\n  left: 0;\n  z-index: 1030;\n}\n\n@media (min-width: 544px) {\n  .navbar-fixed-top,\n  .navbar-fixed-bottom {\n    border-radius: 0;\n  }\n}\n\n.navbar-fixed-top {\n  top: 0;\n}\n\n.navbar-fixed-bottom {\n  bottom: 0;\n}\n\n.navbar-sticky-top {\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0;\n  z-index: 1030;\n  width: 100%;\n}\n\n@media (min-width: 544px) {\n  .navbar-sticky-top {\n    border-radius: 0;\n  }\n}\n\n.navbar-brand {\n  float: left;\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n  margin-right: 1rem;\n  font-size: 1.25rem;\n}\n\n.navbar-brand:focus, .navbar-brand:hover {\n  text-decoration: none;\n}\n\n.navbar-brand > img {\n  display: block;\n}\n\n.navbar-divider {\n  float: left;\n  width: 1px;\n  padding-top: .425rem;\n  padding-bottom: .425rem;\n  margin-right: 1rem;\n  margin-left: 1rem;\n  overflow: hidden;\n}\n\n.navbar-divider::before {\n  content: \"\\A0\";\n}\n\n.navbar-toggler {\n  padding: .5rem .75rem;\n  font-size: 1.25rem;\n  line-height: 1;\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 0.25rem;\n}\n\n.navbar-toggler:focus, .navbar-toggler:hover {\n  text-decoration: none;\n}\n\n.navbar-nav .nav-item {\n  float: left;\n}\n\n.navbar-nav .nav-link {\n  display: block;\n  padding-top: .425rem;\n  padding-bottom: .425rem;\n}\n\n.navbar-nav .nav-link + .nav-link {\n  margin-left: 1rem;\n}\n\n.navbar-nav .nav-item + .nav-item {\n  margin-left: 1rem;\n}\n\n.navbar-light .navbar-brand {\n  color: rgba(0, 0, 0, 0.8);\n}\n\n.navbar-light .navbar-brand:focus, .navbar-light .navbar-brand:hover {\n  color: rgba(0, 0, 0, 0.8);\n}\n\n.navbar-light .navbar-nav .nav-link {\n  color: rgba(0, 0, 0, 0.3);\n}\n\n.navbar-light .navbar-nav .nav-link:focus, .navbar-light .navbar-nav .nav-link:hover {\n  color: rgba(0, 0, 0, 0.6);\n}\n\n.navbar-light .navbar-nav .open > .nav-link, .navbar-light .navbar-nav .open > .nav-link:focus, .navbar-light .navbar-nav .open > .nav-link:hover,\n.navbar-light .navbar-nav .active > .nav-link,\n.navbar-light .navbar-nav .active > .nav-link:focus,\n.navbar-light .navbar-nav .active > .nav-link:hover,\n.navbar-light .navbar-nav .nav-link.open,\n.navbar-light .navbar-nav .nav-link.open:focus,\n.navbar-light .navbar-nav .nav-link.open:hover,\n.navbar-light .navbar-nav .nav-link.active,\n.navbar-light .navbar-nav .nav-link.active:focus,\n.navbar-light .navbar-nav .nav-link.active:hover {\n  color: rgba(0, 0, 0, 0.8);\n}\n\n.navbar-light .navbar-divider {\n  background-color: rgba(0, 0, 0, 0.075);\n}\n\n.navbar-dark .navbar-brand {\n  color: white;\n}\n\n.navbar-dark .navbar-brand:focus, .navbar-dark .navbar-brand:hover {\n  color: white;\n}\n\n.navbar-dark .navbar-nav .nav-link {\n  color: rgba(255, 255, 255, 0.5);\n}\n\n.navbar-dark .navbar-nav .nav-link:focus, .navbar-dark .navbar-nav .nav-link:hover {\n  color: rgba(255, 255, 255, 0.75);\n}\n\n.navbar-dark .navbar-nav .open > .nav-link, .navbar-dark .navbar-nav .open > .nav-link:focus, .navbar-dark .navbar-nav .open > .nav-link:hover,\n.navbar-dark .navbar-nav .active > .nav-link,\n.navbar-dark .navbar-nav .active > .nav-link:focus,\n.navbar-dark .navbar-nav .active > .nav-link:hover,\n.navbar-dark .navbar-nav .nav-link.open,\n.navbar-dark .navbar-nav .nav-link.open:focus,\n.navbar-dark .navbar-nav .nav-link.open:hover,\n.navbar-dark .navbar-nav .nav-link.active,\n.navbar-dark .navbar-nav .nav-link.active:focus,\n.navbar-dark .navbar-nav .nav-link.active:hover {\n  color: white;\n}\n\n.navbar-dark .navbar-divider {\n  background-color: rgba(255, 255, 255, 0.075);\n}\n\n.navbar-toggleable-xs::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n@media (max-width: 543px) {\n  .navbar-toggleable-xs .navbar-nav .nav-item {\n    float: none;\n    margin-left: 0;\n  }\n}\n\n@media (min-width: 544px) {\n  .navbar-toggleable-xs {\n    display: block !important;\n  }\n}\n\n.navbar-toggleable-sm::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n@media (max-width: 767px) {\n  .navbar-toggleable-sm .navbar-nav .nav-item {\n    float: none;\n    margin-left: 0;\n  }\n}\n\n@media (min-width: 768px) {\n  .navbar-toggleable-sm {\n    display: block !important;\n  }\n}\n\n.navbar-toggleable-md::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n@media (max-width: 991px) {\n  .navbar-toggleable-md .navbar-nav .nav-item {\n    float: none;\n    margin-left: 0;\n  }\n}\n\n@media (min-width: 992px) {\n  .navbar-toggleable-md {\n    display: block !important;\n  }\n}\n\n.card {\n  position: relative;\n  display: block;\n  margin-bottom: 0.75rem;\n  background-color: #fff;\n  border-radius: 0.25rem;\n  border: 1px solid rgba(0, 0, 0, 0.125);\n}\n\n.card-block {\n  padding: 1.25rem;\n}\n\n.card-block::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.card-title {\n  margin-bottom: 0.75rem;\n}\n\n.card-subtitle {\n  margin-top: -0.375rem;\n  margin-bottom: 0;\n}\n\n.card-text:last-child {\n  margin-bottom: 0;\n}\n\n.card-link:hover {\n  text-decoration: none;\n}\n\n.card-link + .card-link {\n  margin-left: 1.25rem;\n}\n\n.card > .list-group:first-child .list-group-item:first-child {\n  border-top-right-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.card > .list-group:last-child .list-group-item:last-child {\n  border-bottom-right-radius: 0.25rem;\n  border-bottom-left-radius: 0.25rem;\n}\n\n.card-header {\n  padding: 0.75rem 1.25rem;\n  background-color: #f5f5f5;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.125);\n}\n\n.card-header::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.card-header:first-child {\n  border-radius: 0.25rem 0.25rem 0 0;\n}\n\n.card-footer {\n  padding: 0.75rem 1.25rem;\n  background-color: #f5f5f5;\n  border-top: 1px solid rgba(0, 0, 0, 0.125);\n}\n\n.card-footer::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.card-footer:last-child {\n  border-radius: 0 0 0.25rem 0.25rem;\n}\n\n.card-header-tabs {\n  margin-right: -0.625rem;\n  margin-bottom: -0.75rem;\n  margin-left: -0.625rem;\n  border-bottom: 0;\n}\n\n.card-header-pills {\n  margin-right: -0.625rem;\n  margin-left: -0.625rem;\n}\n\n.card-primary {\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.card-primary .card-header,\n.card-primary .card-footer {\n  background-color: transparent;\n}\n\n.card-success {\n  background-color: #5cb85c;\n  border-color: #5cb85c;\n}\n\n.card-success .card-header,\n.card-success .card-footer {\n  background-color: transparent;\n}\n\n.card-info {\n  background-color: #5bc0de;\n  border-color: #5bc0de;\n}\n\n.card-info .card-header,\n.card-info .card-footer {\n  background-color: transparent;\n}\n\n.card-warning {\n  background-color: #f0ad4e;\n  border-color: #f0ad4e;\n}\n\n.card-warning .card-header,\n.card-warning .card-footer {\n  background-color: transparent;\n}\n\n.card-danger {\n  background-color: #d9534f;\n  border-color: #d9534f;\n}\n\n.card-danger .card-header,\n.card-danger .card-footer {\n  background-color: transparent;\n}\n\n.card-outline-primary {\n  background-color: transparent;\n  border-color: #0275d8;\n}\n\n.card-outline-secondary {\n  background-color: transparent;\n  border-color: #ccc;\n}\n\n.card-outline-info {\n  background-color: transparent;\n  border-color: #5bc0de;\n}\n\n.card-outline-success {\n  background-color: transparent;\n  border-color: #5cb85c;\n}\n\n.card-outline-warning {\n  background-color: transparent;\n  border-color: #f0ad4e;\n}\n\n.card-outline-danger {\n  background-color: transparent;\n  border-color: #d9534f;\n}\n\n.card-inverse .card-header,\n.card-inverse .card-footer {\n  border-color: rgba(255, 255, 255, 0.2);\n}\n\n.card-inverse .card-header,\n.card-inverse .card-footer,\n.card-inverse .card-title,\n.card-inverse .card-blockquote {\n  color: #fff;\n}\n\n.card-inverse .card-link,\n.card-inverse .card-text,\n.card-inverse .card-subtitle,\n.card-inverse .card-blockquote .blockquote-footer {\n  color: rgba(255, 255, 255, 0.65);\n}\n\n.card-inverse .card-link:focus, .card-inverse .card-link:hover {\n  color: #fff;\n}\n\n.card-blockquote {\n  padding: 0;\n  margin-bottom: 0;\n  border-left: 0;\n}\n\n.card-img {\n  border-radius: 0.25rem;\n}\n\n.card-img-overlay {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  padding: 1.25rem;\n}\n\n.card-img-top {\n  border-top-right-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.card-img-bottom {\n  border-bottom-right-radius: 0.25rem;\n  border-bottom-left-radius: 0.25rem;\n}\n\n@media (min-width: 544px) {\n  .card-deck {\n    display: table;\n    width: 100%;\n    margin-bottom: 0.75rem;\n    table-layout: fixed;\n    border-spacing: 1.25rem 0;\n  }\n  .card-deck .card {\n    display: table-cell;\n    margin-bottom: 0;\n    vertical-align: top;\n  }\n  .card-deck-wrapper {\n    margin-right: -1.25rem;\n    margin-left: -1.25rem;\n  }\n}\n\n@media (min-width: 544px) {\n  .card-group {\n    display: table;\n    width: 100%;\n    table-layout: fixed;\n  }\n  .card-group .card {\n    display: table-cell;\n    vertical-align: top;\n  }\n  .card-group .card + .card {\n    margin-left: 0;\n    border-left: 0;\n  }\n  .card-group .card:first-child {\n    border-bottom-right-radius: 0;\n    border-top-right-radius: 0;\n  }\n  .card-group .card:first-child .card-img-top {\n    border-top-right-radius: 0;\n  }\n  .card-group .card:first-child .card-img-bottom {\n    border-bottom-right-radius: 0;\n  }\n  .card-group .card:last-child {\n    border-bottom-left-radius: 0;\n    border-top-left-radius: 0;\n  }\n  .card-group .card:last-child .card-img-top {\n    border-top-left-radius: 0;\n  }\n  .card-group .card:last-child .card-img-bottom {\n    border-bottom-left-radius: 0;\n  }\n  .card-group .card:not(:first-child):not(:last-child) {\n    border-radius: 0;\n  }\n  .card-group .card:not(:first-child):not(:last-child) .card-img-top,\n  .card-group .card:not(:first-child):not(:last-child) .card-img-bottom {\n    border-radius: 0;\n  }\n}\n\n@media (min-width: 544px) {\n  .card-columns {\n    -webkit-column-count: 3;\n       -moz-column-count: 3;\n            column-count: 3;\n    -webkit-column-gap: 1.25rem;\n       -moz-column-gap: 1.25rem;\n            column-gap: 1.25rem;\n  }\n  .card-columns .card {\n    width: 100%;\n  }\n}\n\n.breadcrumb {\n  padding: 0.75rem 1rem;\n  margin-bottom: 1rem;\n  list-style: none;\n  background-color: #eceeef;\n  border-radius: 0.25rem;\n}\n\n.breadcrumb::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.breadcrumb-item {\n  float: left;\n}\n\n.breadcrumb-item + .breadcrumb-item::before {\n  display: inline-block;\n  padding-right: 0.5rem;\n  padding-left: 0.5rem;\n  color: #818a91;\n  content: \"/\";\n}\n\n.breadcrumb-item + .breadcrumb-item:hover::before {\n  text-decoration: underline;\n}\n\n.breadcrumb-item + .breadcrumb-item:hover::before {\n  text-decoration: none;\n}\n\n.breadcrumb-item.active {\n  color: #818a91;\n}\n\n.pagination {\n  display: inline-block;\n  padding-left: 0;\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n  border-radius: 0.25rem;\n}\n\n.page-item {\n  display: inline;\n}\n\n.page-item:first-child .page-link {\n  margin-left: 0;\n  border-bottom-left-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.page-item:last-child .page-link {\n  border-bottom-right-radius: 0.25rem;\n  border-top-right-radius: 0.25rem;\n}\n\n.page-item.active .page-link, .page-item.active .page-link:focus, .page-item.active .page-link:hover {\n  z-index: 2;\n  color: #fff;\n  cursor: default;\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.page-item.disabled .page-link, .page-item.disabled .page-link:focus, .page-item.disabled .page-link:hover {\n  color: #818a91;\n  pointer-events: none;\n  cursor: not-allowed;\n  background-color: #fff;\n  border-color: #ddd;\n}\n\n.page-link {\n  position: relative;\n  float: left;\n  padding: 0.5rem 0.75rem;\n  margin-left: -1px;\n  color: #0275d8;\n  text-decoration: none;\n  background-color: #fff;\n  border: 1px solid #ddd;\n}\n\n.page-link:focus, .page-link:hover {\n  color: #014c8c;\n  background-color: #eceeef;\n  border-color: #ddd;\n}\n\n.pagination-lg .page-link {\n  padding: 0.75rem 1.5rem;\n  font-size: 1.25rem;\n}\n\n.pagination-lg .page-item:first-child .page-link {\n  border-bottom-left-radius: 0.3rem;\n  border-top-left-radius: 0.3rem;\n}\n\n.pagination-lg .page-item:last-child .page-link {\n  border-bottom-right-radius: 0.3rem;\n  border-top-right-radius: 0.3rem;\n}\n\n.pagination-sm .page-link {\n  padding: 0.275rem 0.75rem;\n  font-size: 0.875rem;\n}\n\n.pagination-sm .page-item:first-child .page-link {\n  border-bottom-left-radius: 0.2rem;\n  border-top-left-radius: 0.2rem;\n}\n\n.pagination-sm .page-item:last-child .page-link {\n  border-bottom-right-radius: 0.2rem;\n  border-top-right-radius: 0.2rem;\n}\n\n.tag {\n  display: inline-block;\n  padding: 0.25em 0.4em;\n  font-size: 75%;\n  font-weight: bold;\n  line-height: 1;\n  color: #fff;\n  text-align: center;\n  white-space: nowrap;\n  vertical-align: baseline;\n  border-radius: 0.25rem;\n}\n\n.tag:empty {\n  display: none;\n}\n\n.btn .tag {\n  position: relative;\n  top: -1px;\n}\n\na.tag:focus, a.tag:hover {\n  color: #fff;\n  text-decoration: none;\n  cursor: pointer;\n}\n\n.tag-pill {\n  padding-right: 0.6em;\n  padding-left: 0.6em;\n  border-radius: 10rem;\n}\n\n.tag-default {\n  background-color: #818a91;\n}\n\n.tag-default[href]:focus, .tag-default[href]:hover {\n  background-color: #687077;\n}\n\n.tag-primary {\n  background-color: #0275d8;\n}\n\n.tag-primary[href]:focus, .tag-primary[href]:hover {\n  background-color: #025aa5;\n}\n\n.tag-success {\n  background-color: #5cb85c;\n}\n\n.tag-success[href]:focus, .tag-success[href]:hover {\n  background-color: #449d44;\n}\n\n.tag-info {\n  background-color: #5bc0de;\n}\n\n.tag-info[href]:focus, .tag-info[href]:hover {\n  background-color: #31b0d5;\n}\n\n.tag-warning {\n  background-color: #f0ad4e;\n}\n\n.tag-warning[href]:focus, .tag-warning[href]:hover {\n  background-color: #ec971f;\n}\n\n.tag-danger {\n  background-color: #d9534f;\n}\n\n.tag-danger[href]:focus, .tag-danger[href]:hover {\n  background-color: #c9302c;\n}\n\n.jumbotron {\n  padding: 2rem 1rem;\n  margin-bottom: 2rem;\n  background-color: #eceeef;\n  border-radius: 0.3rem;\n}\n\n@media (min-width: 544px) {\n  .jumbotron {\n    padding: 4rem 2rem;\n  }\n}\n\n.jumbotron-hr {\n  border-top-color: #d0d5d8;\n}\n\n.jumbotron-fluid {\n  padding-right: 0;\n  padding-left: 0;\n  border-radius: 0;\n}\n\n.alert {\n  padding: 1rem;\n  margin-bottom: 1rem;\n  border: 1px solid transparent;\n  border-radius: 0.25rem;\n}\n\n.alert-heading {\n  color: inherit;\n}\n\n.alert-link {\n  font-weight: bold;\n}\n\n.alert-dismissible {\n  padding-right: 2rem;\n}\n\n.alert-dismissible .close {\n  position: relative;\n  top: -.125rem;\n  right: -1rem;\n  color: inherit;\n}\n\n.alert-success {\n  background-color: #dff0d8;\n  border-color: #d0e9c6;\n  color: #3c763d;\n}\n\n.alert-success hr {\n  border-top-color: #c1e2b3;\n}\n\n.alert-success .alert-link {\n  color: #2b542c;\n}\n\n.alert-info {\n  background-color: #d9edf7;\n  border-color: #bcdff1;\n  color: #31708f;\n}\n\n.alert-info hr {\n  border-top-color: #a6d5ec;\n}\n\n.alert-info .alert-link {\n  color: #245269;\n}\n\n.alert-warning {\n  background-color: #fcf8e3;\n  border-color: #faf2cc;\n  color: #8a6d3b;\n}\n\n.alert-warning hr {\n  border-top-color: #f7ecb5;\n}\n\n.alert-warning .alert-link {\n  color: #66512c;\n}\n\n.alert-danger {\n  background-color: #f2dede;\n  border-color: #ebcccc;\n  color: #a94442;\n}\n\n.alert-danger hr {\n  border-top-color: #e4b9b9;\n}\n\n.alert-danger .alert-link {\n  color: #843534;\n}\n\n@-webkit-keyframes progress-bar-stripes {\n  from {\n    background-position: 1rem 0;\n  }\n  to {\n    background-position: 0 0;\n  }\n}\n\n@-o-keyframes progress-bar-stripes {\n  from {\n    background-position: 1rem 0;\n  }\n  to {\n    background-position: 0 0;\n  }\n}\n\n@keyframes progress-bar-stripes {\n  from {\n    background-position: 1rem 0;\n  }\n  to {\n    background-position: 0 0;\n  }\n}\n\n.progress {\n  display: block;\n  width: 100%;\n  height: 1rem;\n  margin-bottom: 1rem;\n}\n\n.progress[value] {\n  background-color: #eee;\n  border: 0;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border-radius: 0.25rem;\n}\n\n.progress[value]::-ms-fill {\n  background-color: #0074d9;\n  border: 0;\n}\n\n.progress[value]::-moz-progress-bar {\n  background-color: #0074d9;\n  border-bottom-left-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.progress[value]::-webkit-progress-value {\n  background-color: #0074d9;\n  border-bottom-left-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.progress[value=\"100\"]::-moz-progress-bar {\n  border-bottom-right-radius: 0.25rem;\n  border-top-right-radius: 0.25rem;\n}\n\n.progress[value=\"100\"]::-webkit-progress-value {\n  border-bottom-right-radius: 0.25rem;\n  border-top-right-radius: 0.25rem;\n}\n\n.progress[value]::-webkit-progress-bar {\n  background-color: #eee;\n  border-radius: 0.25rem;\n}\n\nbase::-moz-progress-bar,\n.progress[value] {\n  background-color: #eee;\n  border-radius: 0.25rem;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress {\n    background-color: #eee;\n    border-radius: 0.25rem;\n  }\n  .progress-bar {\n    display: inline-block;\n    height: 1rem;\n    text-indent: -999rem;\n    background-color: #0074d9;\n    border-bottom-left-radius: 0.25rem;\n    border-top-left-radius: 0.25rem;\n  }\n  .progress[width=\"100%\"] {\n    border-bottom-right-radius: 0.25rem;\n    border-top-right-radius: 0.25rem;\n  }\n}\n\n.progress-striped[value]::-webkit-progress-value {\n  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n  -webkit-background-size: 1rem 1rem;\n          background-size: 1rem 1rem;\n}\n\n.progress-striped[value]::-moz-progress-bar {\n  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n  background-size: 1rem 1rem;\n}\n\n.progress-striped[value]::-ms-fill {\n  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n  background-size: 1rem 1rem;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress-bar-striped {\n    background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n    background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n    background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);\n    -webkit-background-size: 1rem 1rem;\n            background-size: 1rem 1rem;\n  }\n}\n\n.progress-animated[value]::-webkit-progress-value {\n  -webkit-animation: progress-bar-stripes 2s linear infinite;\n          animation: progress-bar-stripes 2s linear infinite;\n}\n\n.progress-animated[value]::-moz-progress-bar {\n  animation: progress-bar-stripes 2s linear infinite;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress-animated .progress-bar-striped {\n    -webkit-animation: progress-bar-stripes 2s linear infinite;\n         -o-animation: progress-bar-stripes 2s linear infinite;\n            animation: progress-bar-stripes 2s linear infinite;\n  }\n}\n\n.progress-success[value]::-webkit-progress-value {\n  background-color: #5cb85c;\n}\n\n.progress-success[value]::-moz-progress-bar {\n  background-color: #5cb85c;\n}\n\n.progress-success[value]::-ms-fill {\n  background-color: #5cb85c;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress-success .progress-bar {\n    background-color: #5cb85c;\n  }\n}\n\n.progress-info[value]::-webkit-progress-value {\n  background-color: #5bc0de;\n}\n\n.progress-info[value]::-moz-progress-bar {\n  background-color: #5bc0de;\n}\n\n.progress-info[value]::-ms-fill {\n  background-color: #5bc0de;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress-info .progress-bar {\n    background-color: #5bc0de;\n  }\n}\n\n.progress-warning[value]::-webkit-progress-value {\n  background-color: #f0ad4e;\n}\n\n.progress-warning[value]::-moz-progress-bar {\n  background-color: #f0ad4e;\n}\n\n.progress-warning[value]::-ms-fill {\n  background-color: #f0ad4e;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress-warning .progress-bar {\n    background-color: #f0ad4e;\n  }\n}\n\n.progress-danger[value]::-webkit-progress-value {\n  background-color: #d9534f;\n}\n\n.progress-danger[value]::-moz-progress-bar {\n  background-color: #d9534f;\n}\n\n.progress-danger[value]::-ms-fill {\n  background-color: #d9534f;\n}\n\n@media screen and (min-width: 0\\0) {\n  .progress-danger .progress-bar {\n    background-color: #d9534f;\n  }\n}\n\n.media,\n.media-body {\n  overflow: hidden;\n}\n\n.media-body {\n  width: 10000px;\n}\n\n.media-left,\n.media-right,\n.media-body {\n  display: table-cell;\n  vertical-align: top;\n}\n\n.media-middle {\n  vertical-align: middle;\n}\n\n.media-bottom {\n  vertical-align: bottom;\n}\n\n.media-object {\n  display: block;\n}\n\n.media-object.img-thumbnail {\n  max-width: none;\n}\n\n.media-right {\n  padding-left: 10px;\n}\n\n.media-left {\n  padding-right: 10px;\n}\n\n.media-heading {\n  margin-top: 0;\n  margin-bottom: 5px;\n}\n\n.media-list {\n  padding-left: 0;\n  list-style: none;\n}\n\n.list-group {\n  padding-left: 0;\n  margin-bottom: 0;\n}\n\n.list-group-item {\n  position: relative;\n  display: block;\n  padding: 0.75rem 1.25rem;\n  margin-bottom: -1px;\n  background-color: #fff;\n  border: 1px solid #ddd;\n}\n\n.list-group-item:first-child {\n  border-top-right-radius: 0.25rem;\n  border-top-left-radius: 0.25rem;\n}\n\n.list-group-item:last-child {\n  margin-bottom: 0;\n  border-bottom-right-radius: 0.25rem;\n  border-bottom-left-radius: 0.25rem;\n}\n\n.list-group-item.disabled, .list-group-item.disabled:focus, .list-group-item.disabled:hover {\n  color: #818a91;\n  cursor: not-allowed;\n  background-color: #eceeef;\n}\n\n.list-group-item.disabled .list-group-item-heading, .list-group-item.disabled:focus .list-group-item-heading, .list-group-item.disabled:hover .list-group-item-heading {\n  color: inherit;\n}\n\n.list-group-item.disabled .list-group-item-text, .list-group-item.disabled:focus .list-group-item-text, .list-group-item.disabled:hover .list-group-item-text {\n  color: #818a91;\n}\n\n.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {\n  z-index: 2;\n  color: #fff;\n  text-decoration: none;\n  background-color: #0275d8;\n  border-color: #0275d8;\n}\n\n.list-group-item.active .list-group-item-heading,\n.list-group-item.active .list-group-item-heading > small,\n.list-group-item.active .list-group-item-heading > .small, .list-group-item.active:focus .list-group-item-heading,\n.list-group-item.active:focus .list-group-item-heading > small,\n.list-group-item.active:focus .list-group-item-heading > .small, .list-group-item.active:hover .list-group-item-heading,\n.list-group-item.active:hover .list-group-item-heading > small,\n.list-group-item.active:hover .list-group-item-heading > .small {\n  color: inherit;\n}\n\n.list-group-item.active .list-group-item-text, .list-group-item.active:focus .list-group-item-text, .list-group-item.active:hover .list-group-item-text {\n  color: #a8d6fe;\n}\n\n.list-group-flush .list-group-item {\n  border-radius: 0;\n}\n\n.list-group-item-action {\n  width: 100%;\n  color: #555;\n  text-align: inherit;\n}\n\n.list-group-item-action .list-group-item-heading {\n  color: #333;\n}\n\n.list-group-item-action:focus, .list-group-item-action:hover {\n  color: #555;\n  text-decoration: none;\n  background-color: #f5f5f5;\n}\n\n.list-group-item-success {\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n\na.list-group-item-success,\nbutton.list-group-item-success {\n  color: #3c763d;\n}\n\na.list-group-item-success .list-group-item-heading,\nbutton.list-group-item-success .list-group-item-heading {\n  color: inherit;\n}\n\na.list-group-item-success:focus, a.list-group-item-success:hover,\nbutton.list-group-item-success:focus,\nbutton.list-group-item-success:hover {\n  color: #3c763d;\n  background-color: #d0e9c6;\n}\n\na.list-group-item-success.active, a.list-group-item-success.active:focus, a.list-group-item-success.active:hover,\nbutton.list-group-item-success.active,\nbutton.list-group-item-success.active:focus,\nbutton.list-group-item-success.active:hover {\n  color: #fff;\n  background-color: #3c763d;\n  border-color: #3c763d;\n}\n\n.list-group-item-info {\n  color: #31708f;\n  background-color: #d9edf7;\n}\n\na.list-group-item-info,\nbutton.list-group-item-info {\n  color: #31708f;\n}\n\na.list-group-item-info .list-group-item-heading,\nbutton.list-group-item-info .list-group-item-heading {\n  color: inherit;\n}\n\na.list-group-item-info:focus, a.list-group-item-info:hover,\nbutton.list-group-item-info:focus,\nbutton.list-group-item-info:hover {\n  color: #31708f;\n  background-color: #c4e3f3;\n}\n\na.list-group-item-info.active, a.list-group-item-info.active:focus, a.list-group-item-info.active:hover,\nbutton.list-group-item-info.active,\nbutton.list-group-item-info.active:focus,\nbutton.list-group-item-info.active:hover {\n  color: #fff;\n  background-color: #31708f;\n  border-color: #31708f;\n}\n\n.list-group-item-warning {\n  color: #8a6d3b;\n  background-color: #fcf8e3;\n}\n\na.list-group-item-warning,\nbutton.list-group-item-warning {\n  color: #8a6d3b;\n}\n\na.list-group-item-warning .list-group-item-heading,\nbutton.list-group-item-warning .list-group-item-heading {\n  color: inherit;\n}\n\na.list-group-item-warning:focus, a.list-group-item-warning:hover,\nbutton.list-group-item-warning:focus,\nbutton.list-group-item-warning:hover {\n  color: #8a6d3b;\n  background-color: #faf2cc;\n}\n\na.list-group-item-warning.active, a.list-group-item-warning.active:focus, a.list-group-item-warning.active:hover,\nbutton.list-group-item-warning.active,\nbutton.list-group-item-warning.active:focus,\nbutton.list-group-item-warning.active:hover {\n  color: #fff;\n  background-color: #8a6d3b;\n  border-color: #8a6d3b;\n}\n\n.list-group-item-danger {\n  color: #a94442;\n  background-color: #f2dede;\n}\n\na.list-group-item-danger,\nbutton.list-group-item-danger {\n  color: #a94442;\n}\n\na.list-group-item-danger .list-group-item-heading,\nbutton.list-group-item-danger .list-group-item-heading {\n  color: inherit;\n}\n\na.list-group-item-danger:focus, a.list-group-item-danger:hover,\nbutton.list-group-item-danger:focus,\nbutton.list-group-item-danger:hover {\n  color: #a94442;\n  background-color: #ebcccc;\n}\n\na.list-group-item-danger.active, a.list-group-item-danger.active:focus, a.list-group-item-danger.active:hover,\nbutton.list-group-item-danger.active,\nbutton.list-group-item-danger.active:focus,\nbutton.list-group-item-danger.active:hover {\n  color: #fff;\n  background-color: #a94442;\n  border-color: #a94442;\n}\n\n.list-group-item-heading {\n  margin-top: 0;\n  margin-bottom: 5px;\n}\n\n.list-group-item-text {\n  margin-bottom: 0;\n  line-height: 1.3;\n}\n\n.embed-responsive {\n  position: relative;\n  display: block;\n  height: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.embed-responsive .embed-responsive-item,\n.embed-responsive iframe,\n.embed-responsive embed,\n.embed-responsive object,\n.embed-responsive video {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border: 0;\n}\n\n.embed-responsive-21by9 {\n  padding-bottom: 42.857143%;\n}\n\n.embed-responsive-16by9 {\n  padding-bottom: 56.25%;\n}\n\n.embed-responsive-4by3 {\n  padding-bottom: 75%;\n}\n\n.embed-responsive-1by1 {\n  padding-bottom: 100%;\n}\n\n.close {\n  float: right;\n  font-size: 1.5rem;\n  font-weight: bold;\n  line-height: 1;\n  color: #000;\n  text-shadow: 0 1px 0 #fff;\n  opacity: .2;\n}\n\n.close:focus, .close:hover {\n  color: #000;\n  text-decoration: none;\n  cursor: pointer;\n  opacity: .5;\n}\n\nbutton.close {\n  padding: 0;\n  cursor: pointer;\n  background: transparent;\n  border: 0;\n  -webkit-appearance: none;\n}\n\n.modal-open {\n  overflow: hidden;\n}\n\n.modal {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 1050;\n  display: none;\n  overflow: hidden;\n  outline: 0;\n  -webkit-overflow-scrolling: touch;\n}\n\n.modal.fade .modal-dialog {\n  -webkit-transition: -webkit-transform .3s ease-out;\n  transition: -webkit-transform .3s ease-out;\n  -o-transition: -o-transform .3s ease-out;\n  transition: transform .3s ease-out;\n  transition: transform .3s ease-out, -webkit-transform .3s ease-out, -o-transform .3s ease-out;\n  -webkit-transform: translate(0, -25%);\n      -ms-transform: translate(0, -25%);\n       -o-transform: translate(0, -25%);\n          transform: translate(0, -25%);\n}\n\n.modal.in .modal-dialog {\n  -webkit-transform: translate(0, 0);\n      -ms-transform: translate(0, 0);\n       -o-transform: translate(0, 0);\n          transform: translate(0, 0);\n}\n\n.modal-open .modal {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.modal-dialog {\n  position: relative;\n  width: auto;\n  margin: 10px;\n}\n\n.modal-content {\n  position: relative;\n  background-color: #fff;\n  -webkit-background-clip: padding-box;\n          background-clip: padding-box;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  border-radius: 0.3rem;\n  outline: 0;\n}\n\n.modal-backdrop {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 1040;\n  background-color: #000;\n}\n\n.modal-backdrop.fade {\n  opacity: 0;\n}\n\n.modal-backdrop.in {\n  opacity: 0.5;\n}\n\n.modal-header {\n  padding: 15px;\n  border-bottom: 1px solid #e5e5e5;\n}\n\n.modal-header::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.modal-header .close {\n  margin-top: -2px;\n}\n\n.modal-title {\n  margin: 0;\n  line-height: 1.5;\n}\n\n.modal-body {\n  position: relative;\n  padding: 15px;\n}\n\n.modal-footer {\n  padding: 15px;\n  text-align: right;\n  border-top: 1px solid #e5e5e5;\n}\n\n.modal-footer::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.modal-scrollbar-measure {\n  position: absolute;\n  top: -9999px;\n  width: 50px;\n  height: 50px;\n  overflow: scroll;\n}\n\n@media (min-width: 544px) {\n  .modal-dialog {\n    max-width: 600px;\n    margin: 30px auto;\n  }\n  .modal-sm {\n    max-width: 300px;\n  }\n}\n\n@media (min-width: 992px) {\n  .modal-lg {\n    max-width: 900px;\n  }\n}\n\n.tooltip {\n  position: absolute;\n  z-index: 1070;\n  display: block;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n  font-style: normal;\n  font-weight: normal;\n  letter-spacing: normal;\n  line-break: auto;\n  line-height: 1.5;\n  text-align: left;\n  text-align: start;\n  text-decoration: none;\n  text-shadow: none;\n  text-transform: none;\n  white-space: normal;\n  word-break: normal;\n  word-spacing: normal;\n  font-size: 0.875rem;\n  word-wrap: break-word;\n  opacity: 0;\n}\n\n.tooltip.in {\n  opacity: 0.9;\n}\n\n.tooltip.tooltip-top, .tooltip.bs-tether-element-attached-bottom {\n  padding: 5px 0;\n  margin-top: -3px;\n}\n\n.tooltip.tooltip-top .tooltip-arrow, .tooltip.bs-tether-element-attached-bottom .tooltip-arrow {\n  bottom: 0;\n  left: 50%;\n  margin-left: -5px;\n  border-width: 5px 5px 0;\n  border-top-color: #000;\n}\n\n.tooltip.tooltip-right, .tooltip.bs-tether-element-attached-left {\n  padding: 0 5px;\n  margin-left: 3px;\n}\n\n.tooltip.tooltip-right .tooltip-arrow, .tooltip.bs-tether-element-attached-left .tooltip-arrow {\n  top: 50%;\n  left: 0;\n  margin-top: -5px;\n  border-width: 5px 5px 5px 0;\n  border-right-color: #000;\n}\n\n.tooltip.tooltip-bottom, .tooltip.bs-tether-element-attached-top {\n  padding: 5px 0;\n  margin-top: 3px;\n}\n\n.tooltip.tooltip-bottom .tooltip-arrow, .tooltip.bs-tether-element-attached-top .tooltip-arrow {\n  top: 0;\n  left: 50%;\n  margin-left: -5px;\n  border-width: 0 5px 5px;\n  border-bottom-color: #000;\n}\n\n.tooltip.tooltip-left, .tooltip.bs-tether-element-attached-right {\n  padding: 0 5px;\n  margin-left: -3px;\n}\n\n.tooltip.tooltip-left .tooltip-arrow, .tooltip.bs-tether-element-attached-right .tooltip-arrow {\n  top: 50%;\n  right: 0;\n  margin-top: -5px;\n  border-width: 5px 0 5px 5px;\n  border-left-color: #000;\n}\n\n.tooltip-inner {\n  max-width: 200px;\n  padding: 3px 8px;\n  color: #fff;\n  text-align: center;\n  background-color: #000;\n  border-radius: 0.25rem;\n}\n\n.tooltip-arrow {\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-color: transparent;\n  border-style: solid;\n}\n\n.popover {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1060;\n  display: block;\n  max-width: 276px;\n  padding: 1px;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n  font-style: normal;\n  font-weight: normal;\n  letter-spacing: normal;\n  line-break: auto;\n  line-height: 1.5;\n  text-align: left;\n  text-align: start;\n  text-decoration: none;\n  text-shadow: none;\n  text-transform: none;\n  white-space: normal;\n  word-break: normal;\n  word-spacing: normal;\n  font-size: 0.875rem;\n  word-wrap: break-word;\n  background-color: #fff;\n  -webkit-background-clip: padding-box;\n          background-clip: padding-box;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n  border-radius: 0.3rem;\n}\n\n.popover.popover-top, .popover.bs-tether-element-attached-bottom {\n  margin-top: -10px;\n}\n\n.popover.popover-top .popover-arrow, .popover.bs-tether-element-attached-bottom .popover-arrow {\n  bottom: -11px;\n  left: 50%;\n  margin-left: -11px;\n  border-top-color: rgba(0, 0, 0, 0.25);\n  border-bottom-width: 0;\n}\n\n.popover.popover-top .popover-arrow::after, .popover.bs-tether-element-attached-bottom .popover-arrow::after {\n  bottom: 1px;\n  margin-left: -10px;\n  content: \"\";\n  border-top-color: #fff;\n  border-bottom-width: 0;\n}\n\n.popover.popover-right, .popover.bs-tether-element-attached-left {\n  margin-left: 10px;\n}\n\n.popover.popover-right .popover-arrow, .popover.bs-tether-element-attached-left .popover-arrow {\n  top: 50%;\n  left: -11px;\n  margin-top: -11px;\n  border-right-color: rgba(0, 0, 0, 0.25);\n  border-left-width: 0;\n}\n\n.popover.popover-right .popover-arrow::after, .popover.bs-tether-element-attached-left .popover-arrow::after {\n  bottom: -10px;\n  left: 1px;\n  content: \"\";\n  border-right-color: #fff;\n  border-left-width: 0;\n}\n\n.popover.popover-bottom, .popover.bs-tether-element-attached-top {\n  margin-top: 10px;\n}\n\n.popover.popover-bottom .popover-arrow, .popover.bs-tether-element-attached-top .popover-arrow {\n  top: -11px;\n  left: 50%;\n  margin-left: -11px;\n  border-top-width: 0;\n  border-bottom-color: rgba(0, 0, 0, 0.25);\n}\n\n.popover.popover-bottom .popover-arrow::after, .popover.bs-tether-element-attached-top .popover-arrow::after {\n  top: 1px;\n  margin-left: -10px;\n  content: \"\";\n  border-top-width: 0;\n  border-bottom-color: #fff;\n}\n\n.popover.popover-left, .popover.bs-tether-element-attached-right {\n  margin-left: -10px;\n}\n\n.popover.popover-left .popover-arrow, .popover.bs-tether-element-attached-right .popover-arrow {\n  top: 50%;\n  right: -11px;\n  margin-top: -11px;\n  border-right-width: 0;\n  border-left-color: rgba(0, 0, 0, 0.25);\n}\n\n.popover.popover-left .popover-arrow::after, .popover.bs-tether-element-attached-right .popover-arrow::after {\n  right: 1px;\n  bottom: -10px;\n  content: \"\";\n  border-right-width: 0;\n  border-left-color: #fff;\n}\n\n.popover-title {\n  padding: 8px 14px;\n  margin: 0;\n  font-size: 1rem;\n  background-color: #f7f7f7;\n  border-bottom: 1px solid #ebebeb;\n  border-radius: 0.2375rem 0.2375rem 0 0;\n}\n\n.popover-title:empty {\n  display: none;\n}\n\n.popover-content {\n  padding: 9px 14px;\n}\n\n.popover-arrow, .popover-arrow::after {\n  position: absolute;\n  display: block;\n  width: 0;\n  height: 0;\n  border-color: transparent;\n  border-style: solid;\n}\n\n.popover-arrow {\n  border-width: 11px;\n}\n\n.popover-arrow::after {\n  content: \"\";\n  border-width: 10px;\n}\n\n.carousel {\n  position: relative;\n}\n\n.carousel-inner {\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n}\n\n.carousel-inner > .carousel-item {\n  position: relative;\n  display: none;\n  -webkit-transition: .6s ease-in-out left;\n  -o-transition: .6s ease-in-out left;\n  transition: .6s ease-in-out left;\n}\n\n.carousel-inner > .carousel-item > img,\n.carousel-inner > .carousel-item > a > img {\n  line-height: 1;\n}\n\n@media all and (transform-3d), (-webkit-transform-3d) {\n  .carousel-inner > .carousel-item {\n    -webkit-transition: -webkit-transform .6s ease-in-out;\n    transition: -webkit-transform .6s ease-in-out;\n    -o-transition: -o-transform .6s ease-in-out;\n    transition: transform .6s ease-in-out;\n    transition: transform .6s ease-in-out, -webkit-transform .6s ease-in-out, -o-transform .6s ease-in-out;\n    -webkit-backface-visibility: hidden;\n            backface-visibility: hidden;\n    -webkit-perspective: 1000px;\n            perspective: 1000px;\n  }\n  .carousel-inner > .carousel-item.next, .carousel-inner > .carousel-item.active.right {\n    left: 0;\n    -webkit-transform: translate3d(100%, 0, 0);\n            transform: translate3d(100%, 0, 0);\n  }\n  .carousel-inner > .carousel-item.prev, .carousel-inner > .carousel-item.active.left {\n    left: 0;\n    -webkit-transform: translate3d(-100%, 0, 0);\n            transform: translate3d(-100%, 0, 0);\n  }\n  .carousel-inner > .carousel-item.next.left, .carousel-inner > .carousel-item.prev.right, .carousel-inner > .carousel-item.active {\n    left: 0;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n\n.carousel-inner > .active,\n.carousel-inner > .next,\n.carousel-inner > .prev {\n  display: block;\n}\n\n.carousel-inner > .active {\n  left: 0;\n}\n\n.carousel-inner > .next,\n.carousel-inner > .prev {\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n\n.carousel-inner > .next {\n  left: 100%;\n}\n\n.carousel-inner > .prev {\n  left: -100%;\n}\n\n.carousel-inner > .next.left,\n.carousel-inner > .prev.right {\n  left: 0;\n}\n\n.carousel-inner > .active.left {\n  left: -100%;\n}\n\n.carousel-inner > .active.right {\n  left: 100%;\n}\n\n.carousel-control {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  width: 15%;\n  font-size: 20px;\n  color: #fff;\n  text-align: center;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);\n  opacity: 0.5;\n}\n\n.carousel-control.left {\n  background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0.0001)));\n  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);\n  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);\n}\n\n.carousel-control.right {\n  right: 0;\n  left: auto;\n  background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.0001)), to(rgba(0, 0, 0, 0.5)));\n  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);\n  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);\n}\n\n.carousel-control:focus, .carousel-control:hover {\n  color: #fff;\n  text-decoration: none;\n  outline: 0;\n  opacity: .9;\n}\n\n.carousel-control .icon-prev,\n.carousel-control .icon-next {\n  position: absolute;\n  top: 50%;\n  z-index: 5;\n  display: inline-block;\n  width: 20px;\n  height: 20px;\n  margin-top: -10px;\n  font-family: serif;\n  line-height: 1;\n}\n\n.carousel-control .icon-prev {\n  left: 50%;\n  margin-left: -10px;\n}\n\n.carousel-control .icon-next {\n  right: 50%;\n  margin-right: -10px;\n}\n\n.carousel-control .icon-prev::before {\n  content: \"\\2039\";\n}\n\n.carousel-control .icon-next::before {\n  content: \"\\203A\";\n}\n\n.carousel-indicators {\n  position: absolute;\n  bottom: 10px;\n  left: 50%;\n  z-index: 15;\n  width: 60%;\n  padding-left: 0;\n  margin-left: -30%;\n  text-align: center;\n  list-style: none;\n}\n\n.carousel-indicators li {\n  display: inline-block;\n  width: 10px;\n  height: 10px;\n  margin: 1px;\n  text-indent: -999px;\n  cursor: pointer;\n  background-color: transparent;\n  border: 1px solid #fff;\n  border-radius: 10px;\n}\n\n.carousel-indicators .active {\n  width: 12px;\n  height: 12px;\n  margin: 0;\n  background-color: #fff;\n}\n\n.carousel-caption {\n  position: absolute;\n  right: 15%;\n  bottom: 20px;\n  left: 15%;\n  z-index: 10;\n  padding-top: 20px;\n  padding-bottom: 20px;\n  color: #fff;\n  text-align: center;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);\n}\n\n.carousel-caption .btn {\n  text-shadow: none;\n}\n\n@media (min-width: 544px) {\n  .carousel-control .icon-prev,\n  .carousel-control .icon-next {\n    width: 30px;\n    height: 30px;\n    margin-top: -15px;\n    font-size: 30px;\n  }\n  .carousel-control .icon-prev {\n    margin-left: -15px;\n  }\n  .carousel-control .icon-next {\n    margin-right: -15px;\n  }\n  .carousel-caption {\n    right: 20%;\n    left: 20%;\n    padding-bottom: 30px;\n  }\n  .carousel-indicators {\n    bottom: 20px;\n  }\n}\n\n.bg-faded {\n  background-color: #f7f7f9;\n}\n\n.bg-primary {\n  color: #fff !important;\n  background-color: #0275d8 !important;\n}\n\na.bg-primary:focus, a.bg-primary:hover {\n  background-color: #025aa5 !important;\n}\n\n.bg-success {\n  color: #fff !important;\n  background-color: #5cb85c !important;\n}\n\na.bg-success:focus, a.bg-success:hover {\n  background-color: #449d44 !important;\n}\n\n.bg-info {\n  color: #fff !important;\n  background-color: #5bc0de !important;\n}\n\na.bg-info:focus, a.bg-info:hover {\n  background-color: #31b0d5 !important;\n}\n\n.bg-warning {\n  color: #fff !important;\n  background-color: #f0ad4e !important;\n}\n\na.bg-warning:focus, a.bg-warning:hover {\n  background-color: #ec971f !important;\n}\n\n.bg-danger {\n  color: #fff !important;\n  background-color: #d9534f !important;\n}\n\na.bg-danger:focus, a.bg-danger:hover {\n  background-color: #c9302c !important;\n}\n\n.bg-inverse {\n  color: #fff !important;\n  background-color: #373a3c !important;\n}\n\na.bg-inverse:focus, a.bg-inverse:hover {\n  background-color: #1f2021 !important;\n}\n\n.clearfix::after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.d-block {\n  display: block !important;\n}\n\n.d-inline-block {\n  display: inline-block !important;\n}\n\n.d-inline {\n  display: inline !important;\n}\n\n.pull-xs-left {\n  float: left !important;\n}\n\n.pull-xs-right {\n  float: right !important;\n}\n\n.pull-xs-none {\n  float: none !important;\n}\n\n@media (min-width: 544px) {\n  .pull-sm-left {\n    float: left !important;\n  }\n  .pull-sm-right {\n    float: right !important;\n  }\n  .pull-sm-none {\n    float: none !important;\n  }\n}\n\n@media (min-width: 768px) {\n  .pull-md-left {\n    float: left !important;\n  }\n  .pull-md-right {\n    float: right !important;\n  }\n  .pull-md-none {\n    float: none !important;\n  }\n}\n\n@media (min-width: 992px) {\n  .pull-lg-left {\n    float: left !important;\n  }\n  .pull-lg-right {\n    float: right !important;\n  }\n  .pull-lg-none {\n    float: none !important;\n  }\n}\n\n@media (min-width: 1200px) {\n  .pull-xl-left {\n    float: left !important;\n  }\n  .pull-xl-right {\n    float: right !important;\n  }\n  .pull-xl-none {\n    float: none !important;\n  }\n}\n\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  position: static;\n  width: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  clip: auto;\n}\n\n.w-100 {\n  width: 100% !important;\n}\n\n.m-x-auto {\n  margin-right: auto !important;\n  margin-left: auto !important;\n}\n\n.m-a-0 {\n  margin: 0 0 !important;\n}\n\n.m-t-0 {\n  margin-top: 0 !important;\n}\n\n.m-r-0 {\n  margin-right: 0 !important;\n}\n\n.m-b-0 {\n  margin-bottom: 0 !important;\n}\n\n.m-l-0 {\n  margin-left: 0 !important;\n}\n\n.m-x-0 {\n  margin-right: 0 !important;\n  margin-left: 0 !important;\n}\n\n.m-y-0 {\n  margin-top: 0 !important;\n  margin-bottom: 0 !important;\n}\n\n.m-a-1 {\n  margin: 1rem 1rem !important;\n}\n\n.m-t-1 {\n  margin-top: 1rem !important;\n}\n\n.m-r-1 {\n  margin-right: 1rem !important;\n}\n\n.m-b-1 {\n  margin-bottom: 1rem !important;\n}\n\n.m-l-1 {\n  margin-left: 1rem !important;\n}\n\n.m-x-1 {\n  margin-right: 1rem !important;\n  margin-left: 1rem !important;\n}\n\n.m-y-1 {\n  margin-top: 1rem !important;\n  margin-bottom: 1rem !important;\n}\n\n.m-a-2 {\n  margin: 1.5rem 1.5rem !important;\n}\n\n.m-t-2 {\n  margin-top: 1.5rem !important;\n}\n\n.m-r-2 {\n  margin-right: 1.5rem !important;\n}\n\n.m-b-2 {\n  margin-bottom: 1.5rem !important;\n}\n\n.m-l-2 {\n  margin-left: 1.5rem !important;\n}\n\n.m-x-2 {\n  margin-right: 1.5rem !important;\n  margin-left: 1.5rem !important;\n}\n\n.m-y-2 {\n  margin-top: 1.5rem !important;\n  margin-bottom: 1.5rem !important;\n}\n\n.m-a-3 {\n  margin: 3rem 3rem !important;\n}\n\n.m-t-3 {\n  margin-top: 3rem !important;\n}\n\n.m-r-3 {\n  margin-right: 3rem !important;\n}\n\n.m-b-3 {\n  margin-bottom: 3rem !important;\n}\n\n.m-l-3 {\n  margin-left: 3rem !important;\n}\n\n.m-x-3 {\n  margin-right: 3rem !important;\n  margin-left: 3rem !important;\n}\n\n.m-y-3 {\n  margin-top: 3rem !important;\n  margin-bottom: 3rem !important;\n}\n\n.p-a-0 {\n  padding: 0 0 !important;\n}\n\n.p-t-0 {\n  padding-top: 0 !important;\n}\n\n.p-r-0 {\n  padding-right: 0 !important;\n}\n\n.p-b-0 {\n  padding-bottom: 0 !important;\n}\n\n.p-l-0 {\n  padding-left: 0 !important;\n}\n\n.p-x-0 {\n  padding-right: 0 !important;\n  padding-left: 0 !important;\n}\n\n.p-y-0 {\n  padding-top: 0 !important;\n  padding-bottom: 0 !important;\n}\n\n.p-a-1 {\n  padding: 1rem 1rem !important;\n}\n\n.p-t-1 {\n  padding-top: 1rem !important;\n}\n\n.p-r-1 {\n  padding-right: 1rem !important;\n}\n\n.p-b-1 {\n  padding-bottom: 1rem !important;\n}\n\n.p-l-1 {\n  padding-left: 1rem !important;\n}\n\n.p-x-1 {\n  padding-right: 1rem !important;\n  padding-left: 1rem !important;\n}\n\n.p-y-1 {\n  padding-top: 1rem !important;\n  padding-bottom: 1rem !important;\n}\n\n.p-a-2 {\n  padding: 1.5rem 1.5rem !important;\n}\n\n.p-t-2 {\n  padding-top: 1.5rem !important;\n}\n\n.p-r-2 {\n  padding-right: 1.5rem !important;\n}\n\n.p-b-2 {\n  padding-bottom: 1.5rem !important;\n}\n\n.p-l-2 {\n  padding-left: 1.5rem !important;\n}\n\n.p-x-2 {\n  padding-right: 1.5rem !important;\n  padding-left: 1.5rem !important;\n}\n\n.p-y-2 {\n  padding-top: 1.5rem !important;\n  padding-bottom: 1.5rem !important;\n}\n\n.p-a-3 {\n  padding: 3rem 3rem !important;\n}\n\n.p-t-3 {\n  padding-top: 3rem !important;\n}\n\n.p-r-3 {\n  padding-right: 3rem !important;\n}\n\n.p-b-3 {\n  padding-bottom: 3rem !important;\n}\n\n.p-l-3 {\n  padding-left: 3rem !important;\n}\n\n.p-x-3 {\n  padding-right: 3rem !important;\n  padding-left: 3rem !important;\n}\n\n.p-y-3 {\n  padding-top: 3rem !important;\n  padding-bottom: 3rem !important;\n}\n\n.pos-f-t {\n  position: fixed;\n  top: 0;\n  right: 0;\n  left: 0;\n  z-index: 1030;\n}\n\n.text-justify {\n  text-align: justify !important;\n}\n\n.text-nowrap {\n  white-space: nowrap !important;\n}\n\n.text-truncate {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.text-xs-left {\n  text-align: left !important;\n}\n\n.text-xs-right {\n  text-align: right !important;\n}\n\n.text-xs-center {\n  text-align: center !important;\n}\n\n@media (min-width: 544px) {\n  .text-sm-left {\n    text-align: left !important;\n  }\n  .text-sm-right {\n    text-align: right !important;\n  }\n  .text-sm-center {\n    text-align: center !important;\n  }\n}\n\n@media (min-width: 768px) {\n  .text-md-left {\n    text-align: left !important;\n  }\n  .text-md-right {\n    text-align: right !important;\n  }\n  .text-md-center {\n    text-align: center !important;\n  }\n}\n\n@media (min-width: 992px) {\n  .text-lg-left {\n    text-align: left !important;\n  }\n  .text-lg-right {\n    text-align: right !important;\n  }\n  .text-lg-center {\n    text-align: center !important;\n  }\n}\n\n@media (min-width: 1200px) {\n  .text-xl-left {\n    text-align: left !important;\n  }\n  .text-xl-right {\n    text-align: right !important;\n  }\n  .text-xl-center {\n    text-align: center !important;\n  }\n}\n\n.text-lowercase {\n  text-transform: lowercase !important;\n}\n\n.text-uppercase {\n  text-transform: uppercase !important;\n}\n\n.text-capitalize {\n  text-transform: capitalize !important;\n}\n\n.font-weight-normal {\n  font-weight: normal;\n}\n\n.font-weight-bold {\n  font-weight: bold;\n}\n\n.font-italic {\n  font-style: italic;\n}\n\n.text-muted {\n  color: #818a91 !important;\n}\n\na.text-muted:focus, a.text-muted:hover {\n  color: #687077 !important;\n}\n\n.text-primary {\n  color: #0275d8 !important;\n}\n\na.text-primary:focus, a.text-primary:hover {\n  color: #025aa5 !important;\n}\n\n.text-success {\n  color: #5cb85c !important;\n}\n\na.text-success:focus, a.text-success:hover {\n  color: #449d44 !important;\n}\n\n.text-info {\n  color: #5bc0de !important;\n}\n\na.text-info:focus, a.text-info:hover {\n  color: #31b0d5 !important;\n}\n\n.text-warning {\n  color: #f0ad4e !important;\n}\n\na.text-warning:focus, a.text-warning:hover {\n  color: #ec971f !important;\n}\n\n.text-danger {\n  color: #d9534f !important;\n}\n\na.text-danger:focus, a.text-danger:hover {\n  color: #c9302c !important;\n}\n\n.text-hide {\n  font: 0/0 a;\n  color: transparent;\n  text-shadow: none;\n  background-color: transparent;\n  border: 0;\n}\n\n.invisible {\n  visibility: hidden !important;\n}\n\n.hidden-xs-up {\n  display: none !important;\n}\n\n@media (max-width: 543px) {\n  .hidden-xs-down {\n    display: none !important;\n  }\n}\n\n@media (min-width: 544px) {\n  .hidden-sm-up {\n    display: none !important;\n  }\n}\n\n@media (max-width: 767px) {\n  .hidden-sm-down {\n    display: none !important;\n  }\n}\n\n@media (min-width: 768px) {\n  .hidden-md-up {\n    display: none !important;\n  }\n}\n\n@media (max-width: 991px) {\n  .hidden-md-down {\n    display: none !important;\n  }\n}\n\n@media (min-width: 992px) {\n  .hidden-lg-up {\n    display: none !important;\n  }\n}\n\n@media (max-width: 1199px) {\n  .hidden-lg-down {\n    display: none !important;\n  }\n}\n\n@media (min-width: 1200px) {\n  .hidden-xl-up {\n    display: none !important;\n  }\n}\n\n.hidden-xl-down {\n  display: none !important;\n}\n\n.visible-print-block {\n  display: none !important;\n}\n\n@media print {\n  .visible-print-block {\n    display: block !important;\n  }\n}\n\n.visible-print-inline {\n  display: none !important;\n}\n\n@media print {\n  .visible-print-inline {\n    display: inline !important;\n  }\n}\n\n.visible-print-inline-block {\n  display: none !important;\n}\n\n@media print {\n  .visible-print-inline-block {\n    display: inline-block !important;\n  }\n}\n\n@media print {\n  .hidden-print {\n    display: none !important;\n  }\n}\n/*# sourceMappingURL=bootstrap.css.map */", ""]);

	// exports


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, "/* reset */\nhtml {\n    font-family: sans-serif;\n    -ms-text-size-adjust: 100%;\n    -webkit-text-size-adjust: 100%;\n    -webkit-font-smoothing: antialiased;\n    -webkit-overflow-scrolling: touch;\n}\n\nhtml, body, h1, h2, h3, h4, h5, h6, div, dl, dt, dd, ul, ol, li, p, blockquote, pre, hr, figure, table, caption, th, td, form, fieldset, legend, input, button, textarea, menu {\n    margin: 0;\n    padding: 0;\n}\n\nimg {\n    vertical-align: middle;\n    border: 0;\n}\n\nli {\n    list-style: none;\n}\n\na, button {\n    cursor: pointer;\n}\n\nh1, h2, h3, h4, h5, h6, em, strong, b {\n    font-weight: normal;\n}\n\ndel, ins, u, s, a, a:hover {\n    text-decoration: none;\n}\n\nbody, textarea, input, button, select, keygen, legend {\n    font: 14px/1.14 arial, '\\9ED1\\4F53', 'microsoft yahei', \\5fae\\8f6f\\96c5\\9ed1;\n    color: #333;\n    outline: 0;\n}\n\nhtml {\n    font-size: 100px;\n    height: 100%;\n    min-width: 320px;\n    min-height: 480px;\n}\n\nbody {\n    font-size: 0.14rem;\n    min-width: 320px;\n    max-width: 768px;\n    height: 100%;\n    background-color: #fff;\n    margin-left: auto;\n    margin-right: auto;\n    box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n}\n\n/* css */\nbody {\n    background: #EEEEF0;\n}\n\n.container {\n    margin: 0;\n    padding: 0;\n    display: flex;\n    flex-flow: column;\n    height: 100vh;\n\n}\n\n.main {\n    flex: 1;\n}\n\ndiv {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n/*按钮*/\n#checkbox {\n    -webkit-appearance: none;\n    -moz-appearance: none;\n    margin-top: 3px;\n}\n\ninput[type=\"checkbox\"] {\n    -webkit-appearance: none;\n    background: #EEEEF0;\n    height: 15px;\n    vertical-align: middle;\n    width: 15px;\n    border-radius: 4px;\n    outline: none;\n    border: none;\n}\n\ninput[type=\"checkbox\"]:checked {\n    background: #EEEEF0 url(" + __webpack_require__(10) + ") 0 0 no-repeat;\n    background-size: 100% 100%;\n    border: 1px solid #EEEEF0;\n}\n\n.header {\n    height: auto;\n    /*border: 1px solid #000;*/\n    background: #BF302D url(" + __webpack_require__(11) + ") no-repeat 0 0;\n    background-size: cover;\n}\n\n.header div:first-child {\n    position: relative;\n    width: 211px;\n    /*margin-top: 30px;*/\n    margin: 30px auto 10px;\n    height: 30px;\n}\n\n.time {\n    /*margin-top: 30px;*/\n}\n\n.header div:first-child b {\n    display: inline-block;\n}\n\n.header div:first-child b:first-child {\n    width: 100px;\n    height: 30px;\n    background: url(" + __webpack_require__(12) + ") no-repeat 0 0;\n    background-size: contain;\n}\n\n.header div:first-child b:last-child {\n    position: absolute;\n    top: 5px;\n    left: 110px;\n    height: 20px;\n    border-left: 1px solid #fff;\n    padding-left: 10px;\n    font-size: 18px;\n    font-weight: 500;\n    color: #ffffff;\n}\n\n.time {\n    width: 160px;\n    height: 30px;\n    margin: 0 auto 20px;\n    color: #ffffff;\n    font-size: 15px;\n    /*padding-top: 6px;*/\n    line-height: 30px;\n    /*line-height: 100%;*/\n    text-align: center;\n    border: 1px solid #ffffff;\n    -webkit-border-radius: 30px;\n    -moz-border-radius: 30px;\n    border-radius: 30px;\n}\n\n/*名称列表*/\n.list {\n    padding: 0 10px;\n}\n\n.list div {\n    text-align: center;\n    height: 50px;\n    line-height: 50px;\n}\n\n.stock-list {\n    overflow: hidden;\n    background: #ffffff;\n    height: 200px;\n    padding: 0 10px;\n    width: 100%;\n}\n\n.stock-items {\n    height: 50px;\n    text-align: center;\n    border-bottom: 1px solid #EEEEF0;\n}\n\n.stock-items div:first-child {\n    margin-top: 10px;\n}\n\n.submit {\n    margin-top: 20px;\n    text-align: center;\n}\n\n.sub-btn {\n    background: #C7322F;\n    border: none;\n    color: #ffffff;\n    width: 200px;\n    height: 40px;\n    font-size: 14px;\n    -webkit-border-radius: 40px;\n    -moz-border-radius: 40px;\n    border-radius: 40px;\n}\n\n/* footer*/\n.footer {\n    padding: 20px;\n}\n\n.footer p {\n    line-height: 150%;\n}\n\n/*弹出框*/\n.pop-mask {\n    display: none;\n    background-color: rgba(0, 0, 0, 0.5);\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 19999;\n    font-size: 15px;\n}\n\n.pop-up {\n    position: absolute;\n    top: 45%;\n    left: 50%;\n    width: 80%;\n    height: 2rem;\n    font-size: 18px;\n    margin-top: -1rem;\n    margin-left: -40%;\n    background-color: #fff;\n    border-radius: 15px !important;\n    overflow: hidden;\n\n}\n\n.pop-head {\n    padding-top: 20px;\n    font-weight: 600;\n    text-align: center;\n}\n\n.pop-content {\n    padding: 30px;\n    text-align: center;\n}\n\n.btn-gp {\n    width: 100%;\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    border-top: 1px solid #CCCCCC;\n    /*border-bottom-right-radius: 1rem;*/\n    /*border-bottom-left-radius: 1rem;*/\n    overflow: hidden;\n    color: #C7322F;\n}\n\n.btn-gp > button:first-child {\n    border-right: 1px solid #cccccc;\n}\n\n.btn-gp > button {\n    background-color: #fff;\n    border: none;\n    width: 50%;\n    float: left;\n    color: #C7322F;\n    font-size: 18px;\n    height: 55px;\n}\n\n/*弹出框动画*/\n.show {\n    -webkit-animation-name: show;\n    -webkit-animation-duration: 0.5s;\n    animation-name: show;\n    animation-duration: 0.5s;\n}\n\n@-webkit-keyframes show {\n    from {\n        -webkit-transform: scale(0);\n    }\n    to {\n        -webkit-transform: scale(1);\n    }\n}\n\n\n@keyframes show {\n    from {\n        transform: scale(0);\n    }\n    to {\n        transform: scale(1);\n    }\n}\n\n\n\n/*申购成功页面*/\n.success {\n    height: 90px;\n    width: 100%;\n    line-height: 90px;\n    background: #ffffff;\n    font-size: 19px;\n    text-align: center;\n}\n\n.success img {\n    width: 40px;\n    height: 40px;\n}\n\n.success-list {\n    text-align: center;\n    padding: 1.5em 10px;\n    font-size: 15px;\n}\n\n.success-list-body {\n    height: auto;\n    width: 100%;\n    background: #ffffff;\n    padding: 0 10px;\n}\n\n.success-items {\n    text-align: center;\n    height: 50px;\n    background: #ffffff;\n    border-bottom: 1px solid #EEEEF0;\n}\n\n.success-items div:first-child {\n    margin-top: 10px;\n    line-height: 140%;\n}\n\n.v-middle {\n    line-height: 50px;\n}\n\n.prize {\n    color: #C7322F;\n}\n\n.back-home {\n    width: 201px;\n    background: #C7322F;\n    color: #ffffff;\n    height: 35px;\n    font-size: 14px;\n    -webkit-border-radius: 35px;\n    -moz-border-radius: 35px;\n    border-radius: 35px;\n    border: none;\n\n}\n\n.success-footer {\n    padding-top: 20px;\n    padding-bottom: 30px;\n    text-align: center;\n}\n\n/*历史查询*/\n.history-content {\n    padding: 20px 0;\n    font-size: 16px;\n}\n\n.history-content img {\n    width: 16px;\n    height: 16px;\n}\n\n.history-time {\n    display: inline-block;\n    position: relative;\n    top: 2px;\n    left: 0;\n}\n\n.history-main-content {\n    background: #ffffff;\n    padding: 0 .15rem;\n}\n\n.history-list {\n    text-align: center;\n    padding: 1.2em 10px;\n    font-size: 15px;\n    background: #EEEEF0;\n}\n\n.history-item {\n    text-align: center;\n}\n\n.history-item-content {\n    border-bottom: 1px solid #EEEEF0;\n}\n\n.history-item > div div:first-child {\n    margin-top: 10px;\n    line-height: 140%;\n}\n\n/*旋转动画*/\n.loading {\n    text-align: center;\n    height: 40px;\n    line-height: 40px;\n}\n\n.loading > span {\n    position: relative;\n    top:5px;\n    left: 0;\n    border-radius: 100%;\n    margin: 2px;\n    -webkit-animation-fill-mode: both;\n    animation-fill-mode: both;\n    border: 2px solid #C7322F;\n    border-bottom-color: transparent;\n    height: 15px;\n    width: 15px;\n    background: transparent !important;\n    display: inline-block;\n    -webkit-animation: rotate 1s 0s cubic-bezier(.38, .79, .6, .2) infinite;\n    animation: rotate 1s 0s cubic-bezier(.38, .79, .6, .2) infinite;\n}\n@-webkit-keyframes rotate {\n    0% {\n        -webkit-transform: rotate(0deg) scale(1);\n        transform: rotate(0deg) scale(1);\n    }\n\n    100% {\n        -webkit-transform: rotate(360deg) scale(1);\n        transform: rotate(360deg) scale(1);\n    }\n}\n\n@keyframes rotate {\n    0% {\n        -webkit-transform: rotate(0deg) scale(1);\n        transform: rotate(0deg) scale(1);\n    }\n\n    100% {\n        -webkit-transform: rotate(360deg) scale(1);\n        transform: rotate(360deg) scale(1);\n    }\n}\n\n.noData {\n    text-align: center;\n    padding: 10px 0;\n}\n\n/*动画*/\n.suceess-img{\n    -webkit-animation: scale .9s;\n    animation: scale .9s;\n}\n@-webkit-keyframes scale {\n    from {\n        -webkit-transform: scale(0);\n        transform: scale(0);\n    }\n    50% {\n        -webkit-transform: scale(1.2);\n        transform: scale(1.2);\n    }\n    to {\n        -webkit-transform: scale(1);\n        transform: scale(1);\n    }\n}\n@keyframes scale {\n    from {\n        -webkit-transform: scale(0);\n        transform: scale(0);\n    }\n    50% {\n        -webkit-transform: scale(1.2);\n        transform: scale(1.2);\n    }\n    to {\n        -webkit-transform: scale(1);\n        transform: scale(1);\n    }\n}\n\n/*页面加载动画*/\n.pageLoading{\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    background-color: #fff;\n  /*  height: 100%;\n    width:100%;*/\n    z-index: 999;\n}\n.sk-double-bounce {\n    width: 40px;\n    height: 40px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-top: -20px;\n    margin-left: -20px;\n}\n\n.sk-double-bounce .sk-child {\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: #C13333;\n    opacity: 0.6;\n    position: absolute;\n    top: 0;\n    left: 0;\n    -webkit-animation: sk-doubleBounce 2s infinite ease-in-out;\n    animation: sk-doubleBounce 2s infinite ease-in-out;\n}\n\n.sk-double-bounce .sk-double-bounce2 {\n    -webkit-animation-delay: -1.0s;\n    animation-delay: -1.0s;\n}\n\n@-webkit-keyframes sk-doubleBounce {\n    0%, 100% {\n        -webkit-transform: scale(0);\n        transform: scale(0);\n    }\n    50% {\n        -webkit-transform: scale(1);\n        transform: scale(1);\n    }\n}\n\n@keyframes sk-doubleBounce {\n    0%, 100% {\n        -webkit-transform: scale(0);\n        transform: scale(0);\n    }\n    50% {\n        -webkit-transform: scale(1);\n        transform: scale(1);\n    }\n}\n\n/*验证*/\n.confirmation-fundquery {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 19999;\n    background-repeat: no-repeat;\n    background-size: 100% 100%;\n    background-position: 0 0;\n    -webkit-filter: blur(3px);\n}\n\n.box-mask {\n    display: none;\n    background-color: rgba(0, 0, 0, 0.5);\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 19999;\n}\n\n.box h1 {\n    font-size: 14px;\n    font-weight: 400;\n    text-align: center;\n    color: #ff6600;\n    padding: 0 0 20px;\n}\n\n.closedown {\n    display: inline-block;\n    position: absolute;\n    right: 0;\n    top: 0;\n    font-size: 17px !important;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    color: #B6B6B6;\n}\n\n.box {\n    display: none;\n    position: absolute;\n    width: 80%;\n    height: auto;\n    top: 40%;\n    left: 50%;\n    margin-left: -40%;\n    margin-top: -10px;\n    padding: 10px;\n    border-radius: 10px;\n    background: #fff;\n    text-align: center;\n    z-index: 199999;\n}\n\n#ipt {\n    position: absolute;\n    top: 0;\n    left: -50px;\n    margin: 0;\n    padding: 0;\n    width: 1px;\n    opacity: 0;\n    height: 1px;\n    border: none;\n}\n\n.box label {\n    display: block;\n}\n\n.box ul {\n    border: 1px solid #c8c8c8;\n    font-size: 0;\n    display: inline-block;\n    position: relative;\n\n}\n\n.box ul li {\n    display: inline-block;\n    width: 35px;\n    height: 35px;\n    font-size: 24px;\n    font-weight: 700;\n    text-align: center;\n    line-height: 40px;\n    border-left: 1px solid #e6e6e6;\n    vertical-align: middle;\n    overflow: hidden;\n}\n\n.box ul li:first-child {\n    border-left: none;\n}\n\n.errMsg {\n    margin-top: 5px;\n}\n.verify{\n    display: none;\n}\n.checkBtn{\n    /*width: ;*/\n}\n", ""]);

	// exports


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3xpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1NTQ0YWM4ZS1lODFjLTRiMjItYjZlNy04MDA5MTYzYWU1MmYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjlGMDcyODE1QTEzMTFFNjkxOTg4OTYwOUNCRDhEOEIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjlGMDcyODA1QTEzMTFFNjkxOTg4OTYwOUNCRDhEOEIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpEOUJDM0JDRENDNTJFNjExQTUyQURCRURBNENFMTk4QSIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmYwNjQxYzA1LThlY2QtMTE3OS1hMWU4LWFkNjEzNDQxOWNhNSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvjWpYIAAAD5UExURfn5+f7+/stBPvz19fLy8sxGQ9JZV8g0MdNcWuSZmNZpaOSfnuenpu7Cwcg2M8o8Of35+fLOztRgX/XX1/78/Pba2u28u/76+vXZ2c1JR9dqafHLy89PTeu0s/be3v77+/HMzO2+vddsa8czMN+GhtNdW/fl5co9Ot2Af//+/so+O81HRNx+ff79/fjn5/PS0vvx8d6EhNp1dMk4NfHJyNx9fPz09Ou2tf/9/eeop+qzsuempeOXlsg1Mvfg4NFWVPnp6dBUUsxFQuqxsOqysc5MSvru7s1IRtt5eNVkY/TV1dNeXcg3NO7BwNlxcOirqtJaWMcyL////6S2Ka4AAADcSURBVHjavJNXb8JAEIQPG2zTewkQek2oCaGH3vvc//8xGFlU3fmReVt9t9Lu7BwxEgNlykCMhFCuCK9P66U6eisc/H3XeTBXykPgQP/Kif8MG4Z+ZHz1K0y4OQAms3gdqBYbta/IV12rzOq7TWuVCt6yxuJuDyD0gvdVTEDKr5URCfiduR72NDuxC3svlf0kQ/hsPpqwsAlwWEKUJpU0JgHx2SHR9gFYGt0sMA4UX+1zdebAVn0h7RneBo9RqFLsbONbS9mhuDlXEadDT+JNSdCNpm6o9b7DWYABAHh039HMyTTtAAAAAElFTkSuQmCC"

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/905fdad6.head-bg.png";

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAAAyCAMAAAA5rfQaAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAADAFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAAAHgy0aAAAA/nRSTlMAFVKbnY+OmKweravZ+CRTgiCkxjcZdU/XdikYIhbBVxd4NCYRATHAoIdtVgrPzXnJdJOelwIo6KEQpd5N+uI1fjNaZrKnD/k8tG6WkdM7VaOilK6v9uFqzFhgW1xIJwxo5WQv8dRpwu0EhHuZn40cI+klKgW9OKjDgxTOs75nE/yxuTrE3bXwK0xR3/NGXpLRULDH7GVva7wIX8UD5Ms2v3fmlX/ufEq2XWymLC3jDg0JWdodcmLn9ZDKB3C3c4EaG1RCyEv+jOrrnE70MNup8tCLQ7jWPkE/hYiK3HH3PZqAQDlH2NJE/QtFhong7xJhfTK7+y5JqgYhYx+6ek0r94kAAAABYktHRACIBR1IAAAACXBIWXMAAAsSAAALEgHS3X78AAALlElEQVRo3u2ae1xN2R7Al1J5jtARp5RHoTBUiggRESUiJJLyKpRH462YUhnPhlCTGa9kmkxFdMk1hcqjBuN6v7rGyFsMpszc3+f+1tr7nLP32eec4uNz3c+91h9nrfVbv7X277v3ev7WIaSGoZZeTTX/40G/toGhWjCqU1eqV6/+x7ZUa2gA0tDwM4laIzD+2JZqD42bqAE0NZEqyQCaaW/CtHkLOY3N5ObyWjV8bEsLSz7VqnUbLTptrQQZa/bbrn0HG9uOcmLVSaRZX0TQWVNjnwN00W5OHazW1Y4Q+jLsqcChm7oKZ4CjMu/UHaCHjCWde0IvfRcNzcp79+mryrXp6tqPkP7MRjfiNGCgsIr7ICHCYA2NeYAuBGdWbwghPTEaigJPAK9hXJn38G5GNBiM8PDwGGHoM9LDY9TQoUYGTX1HdwcfvoExWG+sH3aIcf4sjJ/Q1imgH5XC8ImKpwRibpJ7EHsWfp3gyTBlqsqGaQKC6SFSG0NBJ8IMWjwTE7MwRrNmsoZmsLKW8gAW6iIWhIXPnoOR09yAebKIiIhOzooWXGmFL+bNX1CbCwupIbM8Fy0y6LFYobMEZUvYh4al7LsuA7AIVpR2EyA0l5oYCToRopZj6QrCI9iSZUz9y2ixFn2JQYTEAKzU0EYslsbFK7OrMBsj1vgKRauJ4xra9lquL07B5Dq+eL0AYYOk+QTQjbAUCxcSBcLXG6nypkR1rc0o3UIIlvbS8J2jALYmqbLJqPyNSCFlG8C3hHxHG9/OJDt2TuH7Lw27BAhe6q2bgG6ERFq4myUdeNXUPYKpRG6ljpCC2bRAcSv2C4Q5KUIHlHgmR9ajze91m/p9+g/co1ZaVo+Q0VA3wj5WaMDSQ1n6R9coQjKzFAr6qYnZvFX7CbEAOIC5HIBAoj1IEGwBHEwTuxyk7U86dHB0n6BmHfVWGeQmKxR0IAT/DXQiOAFQjcOYnK3vi6kjCXlUfnS8QmMRQtnvafF3+vqO/YT9YVPobuPRdODnC9rhR22B5arjJyQIIYfhZCFNzC/iRkL/VK4gyLR6hIw1oBMhGnrr2WBhMTkee2rTaZWa/wiFCp3OpjcypZ3szFnvAwDd/fS2sBYFc2LbkpEsptP+dAnC2aWlXKIPyo0xTuLMjPgZzmVXgzD4POhEGH/Bxp2EYeEv5HiynK4HwC9qe3BqUiHsJWQcRv6sI/2Mg5O+mdYpnEJUwsUEnGv/QbueKcovSRAC9C77JScnp9GXBf7jk9f5Axj1c3FryC1zuhCuCJc8TQhX6cw+lO9I3Jg7v3Tp3tgVJzGVo0L4Qm1GKijBnGLRmr3LmM754CvjEKZwCBsRjtfIuXYtNDR0xm6qdfAoJg8Ox42c7ebrdnZ2hpt1ISRDdQjK2txwHiWqEF4NgpOqiamYHXRjogjhS7J5cpDoQfRzT+DTmwAWOKsZIUXYDTVDUH2FowL1EsUuriYIzRQdR4DQ/jD+3GynUroFcPuOIiNPxdKyuboRZkINEc5hIT945f/0YSeOwzZurRTFAgRbXQgWagirDa7tDp11V6nzK8p2NV7csuXiNqvS7kX/xowa4DbPShuCrCvUFOHq0cij+HayTRu5lGoo5hFsq0OIUUNYJm5m3hrI/enWqLjz5+MW+tgfVp0QtksQ7jPJqlSoMQIfwqmS4rvvX6eU8whDMHKpFiFNhSBeneW4DcO1w48+JAHzZkq7jDUjuAK8MwKhE3BLLlkOcE0NAcfi7czqEPpv0YJwFx5soTHd9ZdkYWItJpbfxJ+4hxKEOELMY6CGCPHjLP34YBlJV2m7jpjUY/uANXdUCNgpcJqNJCzCdSFvjRRhIcmLGXhXI0JSMTRhy7eMNmzIPjMmitrdOwnriQQhnSTfhpoiPOqm9Bk8tqfVZhkbGBrcMLK3sXkyQk+IcAKgCc31wdy9tf1vSxFWXF4NpI1GhAkLy7lEbZT7svGbznfbOwXqCO2zk54C1BhBFJ6h0nOpmCJ0wLfrynLpo+rUqdNzRW8pQhxAIXoZNCFE8HEptcObJdlCrZpTlQhzLInfTlf//Xzw8+v+DgitJqNSvFROEU7HxQYLZXnnxQgV7AmHRTPSN9KmmgOdvukxPId+zbhMCcILEm4BT4V1fnsHBDOKkKEZoXljsSxfPJzd6SilY143Aj1R9SAvLfps/J3tPoV7IYZQlk2KQe3UtvIDIYxUk0WIh3PUK/pOs6pBoLuAYqz7uoy3yFNQiAtxbRkZEqecVD80woa0RsLgUuEr7khncZQyT9RazgJLhpDntdVdqRKCG7CYN1w6g3XwIjPBU/7YmkkSVgvWhfdBkFFXzmup/DqKcx8bGgjCk24PUCgXKG0HEzK3bYC5HcoHzTbHYxLcfJ2Lv0e5oZyCe/UY5RGNuFCDOgqfMpEUdlZY+t4I+ToQfleTVYLaF3PqT5zDPA3D1p9xqK1fHGaPkY/nUgeH2DpsO5oXOPz6PoF69qSnHYaJWhx2QGXpeyNEZLzO2JcklZv1lb+sUpPlRV++c7kTqXEIcVYTuKeoCYQeyfdG+Lhh1/8Wgujs/AnhE8InhP8rhIS39Nx0vKKSXI78E1NVkWwR0kukV1YFe5hjcnHgIXI1kXcLOft1SS8PISZvg7YEpjPdHO9bkVccsxKZ091ynTWWRdom4P7B2rKCREcmJq8LcvMmhUFWJJ5Vohdb5cd2fNXqAyFsAnP8XQ7O5C+g9r5lp1n0FtfGyP0C88/cx5NUU5jP9EvZBseZDGet4kVKSA+WepPNTegA1lyZrzexBmC3YBiWozGl6CSkwZA8pC5a2POBELyY224bZJIF0IhQtyjeupGB0PsVPV6FrIZH5BewobcgL5n+AShs1fdQNvEB1yp5cBRJ2Yiu5IDvZrQxY9ttMgcRhoLb3EiAPHIaalWVz18Npldf4nuIR1dOWJW8tCX6mj3Dq8ZEfyCEKUB/eyHCQKBnzf1wDN8+xB6HMFrQGE6NgWmE3qRwCDuBO0Xaw0UWz+BOpIT0ha00yn1gjddOeG08HR4iDz1pdGaPuMQQ/JjuengitsJHYOkGYcFNQUFrLQhH4IeZ+mUlDUUIxnCFwCt2nYNnSa9OAgS8NBoZzKxo71mmL8OLb3OuoVIVwi64ZjlikBH9JOHsLRWwX4rQ1LPszDySfwq27RdaYS+wdIo2hB1aEHh3x+RM8gdQd783tCBJy9E9/YJ6svFAyhzbKgRyAr0YN9jt2AN6aCiBLE7+Et2oGCZhR2I3ZwNwOKsjDGGV7uH/KdDZvzVKZcU5gaWjBdZVxgkKbmhBuA+NrVMc+4A7NnMW83rY5QKhYcyRBlyn3DZoL3MqKRGY7zUN31sgqcyjY8lEgcD25M+A9mz/4Gcl+VKEzdgZKpPY9fWvl+BrlRU7BZb2LlDJTQRyGKsFwQvoy3iKc4wxPCb0wm0YDu5pB1Z+Owd7E3IlYPsnlAiOjqwTPUaEe6x+BWzIZ4nnsIlQp+AFesYcjB2yiaaO9D3TpZv6ttTnxYdxQkt5JzULK0QF0ZoRerERl4rX2eb4L4eLYfAjOo0G0pIr+E+CF9CTzbA5eDBjV/mOXvWn7imCfaQMYlvPePyI/WegZ7Pdn49HL5HFWf9cOE5fgx4dzgXEl013T/nffcQO2mOlQmLkdTB9rGpIX/EVWQoVioIuYvnOdhoRlrD2VxbhqeRNL/q1MkjX5dyhsgHsgAY0cQwuZA/nHK7Wf6HOpf6EGLBG6eJxjN6Q9L7HLxCt2eBcRcgh8LEeXUS/QmfIZ7/xzLkMUI85nh5c5y341zJQD52L0Zyc9TclBR5bNCBYyWjXiDJj/7IoTcNDvaMT71qtrNvXnDtembXLzpbx983OAewQlyWLqrU4nxvKWX9yR/nw8mh2d5aVT+8cZZ85Wslo/efsEVbYQCfZYqyE/qOQ2QEKBxm5DedPiUMq82hNwKtJtYISuEn+C8O/AfGtdNrnLC0UAAAAAElFTkSuQmCC"

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports


	// module
	exports.push([module.id, "/* reset */\r\nhtml {\r\n    font-family: sans-serif;\r\n    -ms-text-size-adjust: 100%;\r\n    -webkit-text-size-adjust: 100%;\r\n    -webkit-font-smoothing: antialiased;\r\n    -webkit-overflow-scrolling: touch;\r\n}\r\n\r\nhtml, body, h1, h2, h3, h4, h5, h6, div, dl, dt, dd, ul, ol, li, p, blockquote, pre, hr, figure, table, caption, th, td, form, fieldset, legend, input, button, textarea, menu {\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\n\r\nimg {\r\n    vertical-align: middle;\r\n    border: 0;\r\n}\r\n\r\nli {\r\n    list-style: none;\r\n}\r\n\r\na, button {\r\n    cursor: pointer;\r\n}\r\n\r\nh1, h2, h3, h4, h5, h6, em, strong, b {\r\n    font-weight: normal;\r\n}\r\n\r\ndel, ins, u, s, a, a:hover {\r\n    text-decoration: none;\r\n}\r\n\r\nbody, textarea, input, button, select, keygen, legend {\r\n    font: 14px/1.14 arial, '\\9ED1\\4F53', 'microsoft yahei', \\5fae\\8f6f\\96c5\\9ed1;\r\n    color: #333;\r\n    outline: 0;\r\n}\r\n\r\nhtml {\r\n    font-size: 100px;\r\n    height: 100%;\r\n    min-width: 320px;\r\n    min-height: 480px;\r\n}\r\n\r\nbody {\r\n    font-size: 0.14rem;\r\n    min-width: 320px;\r\n    max-width: 768px;\r\n    height: 100%;\r\n    background-color: #fff;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n    box-sizing: border-box;\r\n    -webkit-box-sizing: border-box;\r\n\r\n}\r\n\r\n/* css */\r\nbody {\r\n    background: #EEEEF0;\r\n}\r\n\r\n.container {\r\n    margin: 0;\r\n    padding: 0;\r\n   min-height:calc(100vh - .85rem);\r\n\r\n}\r\n\r\n.index{\r\n     min-height:calc(100vh - 1.45rem);\r\n}\r\n\r\n/* footer*/\r\n\r\n.footer {\r\n    margin: .20rem;\r\n    /*min-height:1.2rem;*/\r\n}\r\n@media screen and (max-height: 568px){.footer{min-height:1.6rem;}}\r\n@media screen and (min-height:569px){.footer{min-height:1.6rem;}}\r\ndiv {\r\n    -webkit-box-sizing: border-box;\r\n    -moz-box-sizing: border-box;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/*按钮*/\r\n#checkbox {\r\n    -webkit-appearance: none;\r\n    -moz-appearance: none;\r\n    margin-top: .03rem;\r\n}\r\n\r\ninput[type=\"checkbox\"] {\r\n    -webkit-appearance: none;\r\n    background: #EEEEF0;\r\n    height: .15rem;\r\n    vertical-align: middle;\r\n    width: .15rem;\r\n    border-radius: .04rem;\r\n    outline: none;\r\n    border: none;\r\n}\r\n\r\ninput[type=\"checkbox\"]:checked {\r\n    background: #EEEEF0 url(" + __webpack_require__(10) + ") 0 0 no-repeat;\r\n    background-size: 100% 100%;\r\n    border: 1px solid #EEEEF0;\r\n}\r\ninput:disabled{\r\n    background: #ddd;\r\n}\r\n\r\n.header {\r\n    height: auto;\r\n    /*border: 1px solid #000;*/\r\n    background: #BF302D url(" + __webpack_require__(11) + ") no-repeat 0 0;\r\n    background-size: cover;\r\n    padding-top:.2rem;\r\n}\r\n\r\n.header div:first-child {\r\n    position: relative;\r\n    width: 2.11rem;\r\n    /*margin-top: 30px;*/\r\n    margin: 0 auto .1rem;\r\n    height: .30rem;\r\n}\r\n\r\n.header div:first-child b {\r\n    display: inline-block;\r\n}\r\n\r\n.header div:first-child b:first-child {\r\n    width: 1.00rem;\r\n    height: .30rem;\r\n    background: url(" + __webpack_require__(12) + ") no-repeat 0 0;\r\n    background-size: contain;\r\n}\r\n\r\n.header div:first-child b:last-child {\r\n    position: absolute;\r\n    top: .05rem;\r\n    left: 1.10rem;\r\n    height: .20rem;\r\n    border-left: 1px solid #fff;\r\n    padding-left: .10rem;\r\n    font-size: .18rem;\r\n    font-weight: 500;\r\n    color: #ffffff;\r\n}\r\n.history-head{\r\n    padding:.3rem 0 .15rem;\r\n}\r\n\r\n.time {\r\n    width: 1.60rem;\r\n    height: .25rem;\r\n    margin: 0 auto .10rem;\r\n    color: #ffffff;\r\n    font-size: .14rem;\r\n    /*padding-top: .04rem;*/\r\n    line-height: .25rem;\r\n    text-align: center;\r\n    border: 1px solid #ffffff;\r\n    -webkit-border-radius: .30rem;\r\n    -moz-border-radius: .30rem;\r\n    border-radius: .30rem;\r\n}\r\n.zjzh{\r\n    text-align: center;\r\n    color: #fff;\r\n    padding-bottom: .1rem;\r\n}\r\n\r\n/*名称列表*/\r\n.list {\r\n    padding: 0 .10rem;\r\n}\r\n\r\n.list div {\r\n    text-align: center;\r\n    height: .50rem;\r\n    line-height: .50rem;\r\n}\r\n\r\n.stock-list {\r\n    /*-webkit-overflow-scrolling: touch;\r\n   overflow-y:scroll;*/\r\n    overflow: hidden;\r\n    background: #ffffff;\r\n    /*height: 2.5rem;*/\r\n    height:auto;\r\n    max-height: 2.5rem;\r\n    padding: 0 .10rem;\r\n    width: 100%;\r\n}\r\n\r\n.stock-items {\r\n    /*height: .50rem;*/\r\n    height:auto;\r\n    text-align: center;\r\n    border-bottom: 1px solid #EEEEF0;\r\n}\r\n\r\n.stock-items div:first-child {\r\n    margin-top: .10rem;\r\n}\r\n\r\n.submit {\r\n    margin-top: .20rem;\r\n    text-align: center;\r\n}\r\n\r\n.sub-btn {\r\n    background: #C7322F;\r\n    border: none;\r\n    color: #ffffff;\r\n    width: 2.00rem;\r\n    height: .40rem;\r\n    font-size: .14rem;\r\n    -webkit-border-radius: .40rem;\r\n    -moz-border-radius: .40rem;\r\n    border-radius: .40rem;\r\n    margin-bottom:.15rem;\r\n}\r\n\r\n.history-link{\r\n    display: block;\r\n    text-decoration: underline;\r\n    color: #333;\r\n}\r\n\r\n.footer p {\r\n    line-height: 150%;\r\n}\r\n\r\n/*弹出框*/\r\n.pop-mask {\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 19999;\r\n    font-size: .15rem;\r\n}\r\n\r\n.pop-up {\r\n    position: absolute;\r\n    top: 45%;\r\n    left: 50%;\r\n    width: 80%;\r\n    height: 2rem;\r\n    font-size: .18rem;\r\n    margin-top: -1rem;\r\n    margin-left: -40%;\r\n    background-color: #fff;\r\n    border-radius: 15px !important;\r\n    overflow: hidden;\r\n\r\n}\r\n\r\n.pop-head {\r\n\r\n    padding-top: .16rem;\r\n    /*font-weight: 600;*/\r\n    text-align: center;\r\n}\r\n\r\n.pop-content {\r\n    font-size: 0.14rem;\r\n    padding: .30rem;\r\n    text-align: center;\r\n}\r\n.understand {\r\n    border-top: 1px solid #CCCCCC;\r\n    color: #C7322F;\r\n}\r\n\r\n.understand>button {\r\n     color: #C7322F;\r\n    background-color: #ffffff;\r\n    border: none;\r\n    width: 100%;\r\n    height: .5rem;\r\n}\r\n\r\n.understand>button:active {\r\n    background-color: #eeeeee;\r\n}\r\n\r\n/*弹出框动画*/\r\n.show {\r\n    -webkit-animation-name: show;\r\n    -webkit-animation-duration: 0.5s;\r\n    animation-name: show;\r\n    animation-duration: 0.5s;\r\n}\r\n\r\n@-webkit-keyframes show {\r\n    from {\r\n        -webkit-transform: scale(0);\r\n    }\r\n    to {\r\n        -webkit-transform: scale(1);\r\n    }\r\n}\r\n\r\n\r\n@keyframes show {\r\n    from {\r\n        transform: scale(0);\r\n    }\r\n    to {\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n/*申购成功页面*/\r\n.success {\r\n    height: .70rem;\r\n    width: 100%;\r\n    line-height: .70rem;\r\n    background: #ffffff;\r\n    font-size: .19rem;\r\n    text-align: center;\r\n}\r\n\r\n.success img {\r\n    width: .30rem;\r\n    height: .30rem;\r\n}\r\n\r\n.success-list {\r\n    text-align: center;\r\n    padding: 1.1em .10rem;\r\n    font-size: .15rem;\r\n}\r\n\r\n.success-list-body {\r\n    height: auto;\r\n    max-height: 2.5rem;\r\n    width: 100%;\r\n    background: #ffffff;\r\n    padding: 0 .10rem;\r\n   /*-webkit-overflow-scrolling: touch;\r\n   overflow-y:scroll;*/\r\n   overflow: hidden;\r\n}\r\n\r\n.success-items {\r\n    text-align: center;\r\n    height: .50rem;\r\n    background: #ffffff;\r\n    border-bottom: 1px solid #EEEEF0;\r\n}\r\n\r\n.success-items div:first-child {\r\n    margin-top: .10rem;\r\n    line-height: 140%;\r\n}\r\n\r\n.v-middle {\r\n    line-height: .50rem;\r\n}\r\n\r\n.prize {\r\n    color: #C7322F;\r\n}\r\n\r\n.back-home {\r\n    width: 3.01rem;\r\n    background: #C7322F;\r\n    color: #ffffff;\r\n    height: .4rem;\r\n    font-size: .14rem;\r\n    -webkit-border-radius: .35rem;\r\n    -moz-border-radius: .35rem;\r\n    border-radius: .35rem;\r\n    border: none;\r\n\r\n}\r\n\r\n.success-footer {\r\n    padding-top: .20rem;\r\n    padding-bottom: .30rem;\r\n    text-align: center;\r\n}\r\n\r\n/*历史查询*/\r\n.history-content {\r\n    padding: .20rem 0;\r\n    font-size: .16rem;\r\n}\r\n\r\n.history-content img {\r\n    width: .16rem;\r\n    height: .16rem;\r\n}\r\n\r\n.history-time {\r\n    display: inline-block;\r\n    position: relative;\r\n    top: .02rem;\r\n    left: 0;\r\n}\r\n\r\n.history-main-content {\r\n    background: #ffffff;\r\n    padding: 0 .15rem;\r\n}\r\n\r\n.history-list {\r\n    text-align: center;\r\n    padding: 1.2em .10rem;\r\n    font-size: .15rem;\r\n    background: #EEEEF0;\r\n}\r\n\r\n.history-item {\r\n    text-align: center;\r\n}\r\n\r\n.history-item-content {\r\n    border-bottom: 1px solid #EEEEF0;\r\n}\r\n\r\n.history-item > div div:first-child {\r\n    margin-top: .10rem;\r\n    line-height: 140%;\r\n}\r\n.risk{\r\n    padding:.15rem .15rem  .5rem;\r\n    text-align: justify;\r\n    position: relative;\r\n}\r\n.risk>h4{\r\n    text-align: center;\r\n    margin-bottom:.1rem;\r\n}\r\n.risk>p:not(.first){\r\n    text-indent: 2em;\r\n    line-height: 150%;\r\n    margin: .1rem 0;\r\n}\r\n.riskBtn{\r\n    width: 90%;\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 5%;\r\n}\r\n\r\n/*旋转动画*/\r\n.loading {\r\n    text-align: center;\r\n    height: .40rem;\r\n    line-height: .40rem;\r\n}\r\n\r\n.loading > span {\r\n    position: relative;\r\n    top: .05rem;\r\n    left: 0;\r\n    border-radius: 100%;\r\n    margin: .02rem;\r\n    -webkit-animation-fill-mode: both;\r\n    animation-fill-mode: both;\r\n    border: 2px solid #C7322F;\r\n    border-bottom-color: transparent;\r\n    height: .15rem;\r\n    width: .15rem;\r\n    background: transparent !important;\r\n    display: inline-block;\r\n    -webkit-animation: rotate 1s 0s cubic-bezier(.38, .79, .6, .2) infinite;\r\n    animation: rotate 1s 0s cubic-bezier(.38, .79, .6, .2) infinite;\r\n}\r\n@-webkit-keyframes rotate {\r\n    0% {\r\n        -webkit-transform: rotate(0deg) scale(1);\r\n        transform: rotate(0deg) scale(1);\r\n    }\r\n\r\n    100% {\r\n        -webkit-transform: rotate(360deg) scale(1);\r\n        transform: rotate(360deg) scale(1);\r\n    }\r\n}\r\n\r\n@keyframes rotate {\r\n    0% {\r\n        -webkit-transform: rotate(0deg) scale(1);\r\n        transform: rotate(0deg) scale(1);\r\n    }\r\n\r\n    100% {\r\n        -webkit-transform: rotate(360deg) scale(1);\r\n        transform: rotate(360deg) scale(1);\r\n    }\r\n}\r\n\r\n.noData,.dropload-refresh{\r\n    text-align: center;\r\n    padding: .10rem 0;\r\n}\r\n\r\n/*动画*/\r\n.suceess-img{\r\n    -webkit-animation: scale .9s;\r\n    animation: scale .9s;\r\n}\r\n@-webkit-keyframes scale {\r\n    from {\r\n        -webkit-transform: scale(0);\r\n        transform: scale(0);\r\n    }\r\n    50% {\r\n        -webkit-transform: scale(1.2);\r\n        transform: scale(1.2);\r\n    }\r\n    to {\r\n        -webkit-transform: scale(1);\r\n        transform: scale(1);\r\n    }\r\n}\r\n@keyframes scale {\r\n    from {\r\n        -webkit-transform: scale(0);\r\n        transform: scale(0);\r\n    }\r\n    50% {\r\n        -webkit-transform: scale(1.2);\r\n        transform: scale(1.2);\r\n    }\r\n    to {\r\n        -webkit-transform: scale(1);\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n/*页面加载动画*/\r\n.pageLoading{\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    background-color: #fff;\r\n    height: 100%;\r\n    width:100%;\r\n    z-index: 999;\r\n}\r\n.sk-double-bounce {\r\n    width: .40rem;\r\n    height: .40rem;\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    margin-top: -.20rem;\r\n    margin-left: -.20rem;\r\n}\r\n\r\n.sk-double-bounce .sk-child {\r\n    width: 100%;\r\n    height: 100%;\r\n    border-radius: 50%;\r\n    background-color: #C13333;\r\n    opacity: 0.6;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    -webkit-animation: sk-doubleBounce 2s infinite ease-in-out;\r\n    animation: sk-doubleBounce 2s infinite ease-in-out;\r\n}\r\n\r\n.sk-double-bounce .sk-double-bounce2 {\r\n    -webkit-animation-delay: -1.0s;\r\n    animation-delay: -1.0s;\r\n}\r\n\r\n@-webkit-keyframes sk-doubleBounce {\r\n    0%, 100% {\r\n        -webkit-transform: scale(0);\r\n        transform: scale(0);\r\n    }\r\n    50% {\r\n        -webkit-transform: scale(1);\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes sk-doubleBounce {\r\n    0%, 100% {\r\n        -webkit-transform: scale(0);\r\n        transform: scale(0);\r\n    }\r\n    50% {\r\n        -webkit-transform: scale(1);\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n/*验证*/\r\n.confirmation-fundquery {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 19999;\r\n    background-repeat: no-repeat;\r\n    background-size: 100% 100%;\r\n    background-position: 0 0;\r\n    -webkit-filter: blur(3px);\r\n}\r\n\r\n.box-mask {\r\n    display: none;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 19999;\r\n}\r\n\r\n.box h1 {\r\n    font-size: .14rem;\r\n    font-weight: 400;\r\n    text-align: center;\r\n    color: #ff6600;\r\n    padding: 0 0 .20rem;\r\n}\r\n\r\n.closedown {\r\n    display: inline-block;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    font-size: .17rem !important;\r\n    width: .40rem;\r\n    height: .40rem;\r\n    line-height: .40rem;\r\n    color: #B6B6B6;\r\n}\r\n\r\n.box {\r\n    position: fixed;\r\n    width: 80%;\r\n    height: auto;\r\n    top: 40%;\r\n    left: 50%;\r\n    margin-left: -40%;\r\n    margin-top: -1rem;\r\n    padding: 10px;\r\n    border-radius: .10rem;\r\n    background: #fff;\r\n    text-align: center;\r\n    z-index: 199999;\r\n}\r\n\r\n#ipt {\r\n    position: absolute;\r\n    top: 0;\r\n    left: -5rem;\r\n    margin: 0;\r\n    padding: 0;\r\n    width: 1px;\r\n    opacity: 0;\r\n    height: 1px;\r\n    border: none;\r\n}\r\n\r\n.box label {\r\n    display: block;\r\n}\r\n\r\n.box ul {\r\n    border: 1px solid #c8c8c8;\r\n    font-size: 0;\r\n    display: inline-block;\r\n    position: relative;\r\n\r\n}\r\n\r\n.box ul li {\r\n    display: inline-block;\r\n    width: .35rem;\r\n    height: .35rem;\r\n    font-size: .24rem;\r\n    font-weight: 700;\r\n    text-align: center;\r\n    line-height: .40rem;\r\n    border-left: 1px solid #e6e6e6;\r\n    vertical-align: middle;\r\n    overflow: hidden;\r\n}\r\n\r\n.box ul li:first-child {\r\n    border-left: none;\r\n}\r\n.verify{\r\n    display: none;\r\n    position: relative;\r\n}\r\n.verify img{\r\n    position: relative;\r\n    top: -1px;\r\n    left: 0;\r\n}\r\n.errMsg {\r\n    margin-top: .05rem;\r\n    margin-bottom: .05rem;\r\n}\r\n.checkBtn{\r\n    width: 2.12rem;\r\n    height: .3rem;\r\n    background: #C7322F;\r\n    border: none;\r\n    color: #fff;\r\n    font-size: .14rem;\r\n    -webkit-border-radius: .25rem;\r\n    -moz-border-radius: .25rem;\r\n    border-radius: .25rem;\r\n}\r\n/*页面加载的loading动画*/\r\n.loadingBox{\r\n     position: fixed;\r\n    top: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    z-index: 99999;\r\n    width: 100%;\r\n    height: 100%;\r\n    padding: 0 0 0 0;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    /* display: none; */\r\n} \r\n.loadContainer{\r\n    width: 80px;\r\n    height: 80px;\r\n    margin: auto;\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%,-50%);\r\n    border-radius: 10px;\r\n    background: rgba(0,0,0,.3);\r\n\r\n }\r\n.sk-circle {\r\n  width: 40px;\r\n  height: 40px;\r\n  position: absolute; \r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%,-50%);\r\n}\r\n  .sk-circle .sk-child {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0; }\r\n  .sk-circle .sk-child:before {\r\n    content: '';\r\n    display: block;\r\n    margin: 0 auto;\r\n    width: 15%;\r\n    height: 15%;\r\n    background-color: #fff;\r\n    border-radius: 100%;\r\n    -webkit-animation: sk-circleBounceDelay 1.2s infinite ease-in-out both;\r\n            animation: sk-circleBounceDelay 1.2s infinite ease-in-out both; }\r\n  .sk-circle .sk-circle2 {\r\n    -webkit-transform: rotate(30deg);\r\n        -ms-transform: rotate(30deg);\r\n            transform: rotate(30deg); }\r\n  .sk-circle .sk-circle3 {\r\n    -webkit-transform: rotate(60deg);\r\n        -ms-transform: rotate(60deg);\r\n            transform: rotate(60deg); }\r\n  .sk-circle .sk-circle4 {\r\n    -webkit-transform: rotate(90deg);\r\n        -ms-transform: rotate(90deg);\r\n            transform: rotate(90deg); }\r\n  .sk-circle .sk-circle5 {\r\n    -webkit-transform: rotate(120deg);\r\n        -ms-transform: rotate(120deg);\r\n            transform: rotate(120deg); }\r\n  .sk-circle .sk-circle6 {\r\n    -webkit-transform: rotate(150deg);\r\n        -ms-transform: rotate(150deg);\r\n            transform: rotate(150deg); }\r\n  .sk-circle .sk-circle7 {\r\n    -webkit-transform: rotate(180deg);\r\n        -ms-transform: rotate(180deg);\r\n            transform: rotate(180deg); }\r\n  .sk-circle .sk-circle8 {\r\n    -webkit-transform: rotate(210deg);\r\n        -ms-transform: rotate(210deg);\r\n            transform: rotate(210deg); }\r\n  .sk-circle .sk-circle9 {\r\n    -webkit-transform: rotate(240deg);\r\n        -ms-transform: rotate(240deg);\r\n            transform: rotate(240deg); }\r\n  .sk-circle .sk-circle10 {\r\n    -webkit-transform: rotate(270deg);\r\n        -ms-transform: rotate(270deg);\r\n            transform: rotate(270deg); }\r\n  .sk-circle .sk-circle11 {\r\n    -webkit-transform: rotate(300deg);\r\n        -ms-transform: rotate(300deg);\r\n            transform: rotate(300deg); }\r\n  .sk-circle .sk-circle12 {\r\n    -webkit-transform: rotate(330deg);\r\n        -ms-transform: rotate(330deg);\r\n            transform: rotate(330deg); }\r\n  .sk-circle .sk-circle2:before {\r\n    -webkit-animation-delay: -1.1s;\r\n            animation-delay: -1.1s; }\r\n  .sk-circle .sk-circle3:before {\r\n    -webkit-animation-delay: -1s;\r\n            animation-delay: -1s; }\r\n  .sk-circle .sk-circle4:before {\r\n    -webkit-animation-delay: -0.9s;\r\n            animation-delay: -0.9s; }\r\n  .sk-circle .sk-circle5:before {\r\n    -webkit-animation-delay: -0.8s;\r\n            animation-delay: -0.8s; }\r\n  .sk-circle .sk-circle6:before {\r\n    -webkit-animation-delay: -0.7s;\r\n            animation-delay: -0.7s; }\r\n  .sk-circle .sk-circle7:before {\r\n    -webkit-animation-delay: -0.6s;\r\n            animation-delay: -0.6s; }\r\n  .sk-circle .sk-circle8:before {\r\n    -webkit-animation-delay: -0.5s;\r\n            animation-delay: -0.5s; }\r\n  .sk-circle .sk-circle9:before {\r\n    -webkit-animation-delay: -0.4s;\r\n            animation-delay: -0.4s; }\r\n  .sk-circle .sk-circle10:before {\r\n    -webkit-animation-delay: -0.3s;\r\n            animation-delay: -0.3s; }\r\n  .sk-circle .sk-circle11:before {\r\n    -webkit-animation-delay: -0.2s;\r\n            animation-delay: -0.2s; }\r\n  .sk-circle .sk-circle12:before {\r\n    -webkit-animation-delay: -0.1s;\r\n            animation-delay: -0.1s; }\r\n\r\n@-webkit-keyframes sk-circleBounceDelay {\r\n  0%, 80%, 100% {\r\n    -webkit-transform: scale(0);\r\n            transform: scale(0); }\r\n  40% {\r\n    -webkit-transform: scale(1);\r\n            transform: scale(1); } }\r\n\r\n@keyframes sk-circleBounceDelay {\r\n  0%, 80%, 100% {\r\n    -webkit-transform: scale(0);\r\n            transform: scale(0); }\r\n  40% {\r\n    -webkit-transform: scale(1);\r\n            transform: scale(1); } }\r\n", ""]);

	// exports


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if (media) {
			styleElement.setAttribute("media", media);
		}

		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(16);

	__webpack_require__(18);

	__webpack_require__(19);

	__webpack_require__(20);

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*!
	 * jQuery JavaScript Library v2.1.0
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-01-23T21:10Z
	 */

	(function (global, factory) {

	    if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
	        // For CommonJS and CommonJS-like environments where a proper window is present,
	        // execute the factory and get jQuery
	        // For environments that do not inherently posses a window with a document
	        // (such as Node.js), expose a jQuery-making factory as module.exports
	        // This accentuates the need for the creation of a real window
	        // e.g. var jQuery = require("jquery")(window);
	        // See ticket #14549 for more info
	        module.exports = global.document ? factory(global, true) : function (w) {
	            if (!w.document) {
	                throw new Error("jQuery requires a window with a document");
	            }
	            return factory(w);
	        };
	    } else {
	        factory(global);
	    }

	    // Pass this if window is not defined yet
	})(typeof window !== "undefined" ? window : undefined, function (window, noGlobal) {

	    // Can't do this because several apps including ASP.NET trace
	    // the stack via arguments.caller.callee and Firefox dies if
	    // you try to trace through "use strict" call chains. (#13335)
	    // Support: Firefox 18+
	    //

	    var arr = [];

	    var _slice = arr.slice;

	    var concat = arr.concat;

	    var push = arr.push;

	    var indexOf = arr.indexOf;

	    var class2type = {};

	    var toString = class2type.toString;

	    var hasOwn = class2type.hasOwnProperty;

	    var _trim = "".trim;

	    var support = {};

	    var
	    // Use the correct document accordingly with window argument (sandbox)
	    document = window.document,
	        version = "2.1.0",


	    // Define a local copy of jQuery
	    jQuery = function jQuery(selector, context) {
	        // The jQuery object is actually just the init constructor 'enhanced'
	        // Need init if jQuery is called (just allow error to be thrown if not included)
	        return new jQuery.fn.init(selector, context);
	    },


	    // Matches dashed string for camelizing
	    rmsPrefix = /^-ms-/,
	        rdashAlpha = /-([\da-z])/gi,


	    // Used by jQuery.camelCase as callback to replace()
	    fcamelCase = function fcamelCase(all, letter) {
	        return letter.toUpperCase();
	    };

	    jQuery.fn = jQuery.prototype = {
	        // The current version of jQuery being used
	        jquery: version,

	        constructor: jQuery,

	        // Start with an empty selector
	        selector: "",

	        // The default length of a jQuery object is 0
	        length: 0,

	        toArray: function toArray() {
	            return _slice.call(this);
	        },

	        // Get the Nth element in the matched element set OR
	        // Get the whole matched element set as a clean array
	        get: function get(num) {
	            return num != null ?

	            // Return a 'clean' array
	            num < 0 ? this[num + this.length] : this[num] :

	            // Return just the object
	            _slice.call(this);
	        },

	        // Take an array of elements and push it onto the stack
	        // (returning the new matched element set)
	        pushStack: function pushStack(elems) {

	            // Build a new jQuery matched element set
	            var ret = jQuery.merge(this.constructor(), elems);

	            // Add the old object onto the stack (as a reference)
	            ret.prevObject = this;
	            ret.context = this.context;

	            // Return the newly-formed element set
	            return ret;
	        },

	        // Execute a callback for every element in the matched set.
	        // (You can seed the arguments with an array of args, but this is
	        // only used internally.)
	        each: function each(callback, args) {
	            return jQuery.each(this, callback, args);
	        },

	        map: function map(callback) {
	            return this.pushStack(jQuery.map(this, function (elem, i) {
	                return callback.call(elem, i, elem);
	            }));
	        },

	        slice: function slice() {
	            return this.pushStack(_slice.apply(this, arguments));
	        },

	        first: function first() {
	            return this.eq(0);
	        },

	        last: function last() {
	            return this.eq(-1);
	        },

	        eq: function eq(i) {
	            var len = this.length,
	                j = +i + (i < 0 ? len : 0);
	            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
	        },

	        end: function end() {
	            return this.prevObject || this.constructor(null);
	        },

	        // For internal use only.
	        // Behaves like an Array's method, not like a jQuery method.
	        push: push,
	        sort: arr.sort,
	        splice: arr.splice
	    };

	    jQuery.extend = jQuery.fn.extend = function () {
	        var options,
	            name,
	            src,
	            copy,
	            copyIsArray,
	            clone,
	            target = arguments[0] || {},
	            i = 1,
	            length = arguments.length,
	            deep = false;

	        // Handle a deep copy situation
	        if (typeof target === "boolean") {
	            deep = target;

	            // skip the boolean and the target
	            target = arguments[i] || {};
	            i++;
	        }

	        // Handle case when target is a string or something (possible in deep copy)
	        if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !jQuery.isFunction(target)) {
	            target = {};
	        }

	        // extend jQuery itself if only one argument is passed
	        if (i === length) {
	            target = this;
	            i--;
	        }

	        for (; i < length; i++) {
	            // Only deal with non-null/undefined values
	            if ((options = arguments[i]) != null) {
	                // Extend the base object
	                for (name in options) {
	                    src = target[name];
	                    copy = options[name];

	                    // Prevent never-ending loop
	                    if (target === copy) {
	                        continue;
	                    }

	                    // Recurse if we're merging plain objects or arrays
	                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
	                        if (copyIsArray) {
	                            copyIsArray = false;
	                            clone = src && jQuery.isArray(src) ? src : [];
	                        } else {
	                            clone = src && jQuery.isPlainObject(src) ? src : {};
	                        }

	                        // Never move original objects, clone them
	                        target[name] = jQuery.extend(deep, clone, copy);

	                        // Don't bring in undefined values
	                    } else if (copy !== undefined) {
	                        target[name] = copy;
	                    }
	                }
	            }
	        }

	        // Return the modified object
	        return target;
	    };

	    jQuery.extend({
	        // Unique for each copy of jQuery on the page
	        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

	        // Assume jQuery is ready without the ready module
	        isReady: true,

	        error: function error(msg) {
	            throw new Error(msg);
	        },

	        noop: function noop() {},

	        // See test/unit/core.js for details concerning isFunction.
	        // Since version 1.3, DOM methods and functions like alert
	        // aren't supported. They return false on IE (#2968).
	        isFunction: function isFunction(obj) {
	            return jQuery.type(obj) === "function";
	        },

	        isArray: Array.isArray,

	        isWindow: function isWindow(obj) {
	            return obj != null && obj === obj.window;
	        },

	        isNumeric: function isNumeric(obj) {
	            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	            // subtraction forces infinities to NaN
	            return obj - parseFloat(obj) >= 0;
	        },

	        isPlainObject: function isPlainObject(obj) {
	            // Not plain objects:
	            // - Any object or value whose internal [[Class]] property is not "[object Object]"
	            // - DOM nodes
	            // - window
	            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
	                return false;
	            }

	            // Support: Firefox <20
	            // The try/catch suppresses exceptions thrown when attempting to access
	            // the "constructor" property of certain host objects, ie. |window.location|
	            // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
	            try {
	                if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
	                    return false;
	                }
	            } catch (e) {
	                return false;
	            }

	            // If the function hasn't returned already, we're confident that
	            // |obj| is a plain object, created by {} or constructed with new Object
	            return true;
	        },

	        isEmptyObject: function isEmptyObject(obj) {
	            var name;
	            for (name in obj) {
	                return false;
	            }
	            return true;
	        },

	        type: function type(obj) {
	            if (obj == null) {
	                return obj + "";
	            }
	            // Support: Android < 4.0, iOS < 6 (functionish RegExp)
	            return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	        },

	        // Evaluates a script in a global context
	        globalEval: function globalEval(code) {
	            var script,
	                indirect = eval;

	            code = jQuery.trim(code);

	            if (code) {
	                // If the code includes a valid, prologue position
	                // strict mode pragma, execute code by injecting a
	                // script tag into the document.
	                if (code.indexOf("use strict") === 1) {
	                    script = document.createElement("script");
	                    script.text = code;
	                    document.head.appendChild(script).parentNode.removeChild(script);
	                } else {
	                    // Otherwise, avoid the DOM node creation, insertion
	                    // and removal by using an indirect global eval
	                    indirect(code);
	                }
	            }
	        },

	        // Convert dashed to camelCase; used by the css and data modules
	        // Microsoft forgot to hump their vendor prefix (#9572)
	        camelCase: function camelCase(string) {
	            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
	        },

	        nodeName: function nodeName(elem, name) {
	            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	        },

	        // args is for internal usage only
	        each: function each(obj, callback, args) {
	            var value,
	                i = 0,
	                length = obj.length,
	                isArray = isArraylike(obj);

	            if (args) {
	                if (isArray) {
	                    for (; i < length; i++) {
	                        value = callback.apply(obj[i], args);

	                        if (value === false) {
	                            break;
	                        }
	                    }
	                } else {
	                    for (i in obj) {
	                        value = callback.apply(obj[i], args);

	                        if (value === false) {
	                            break;
	                        }
	                    }
	                }

	                // A special, fast, case for the most common use of each
	            } else {
	                if (isArray) {
	                    for (; i < length; i++) {
	                        value = callback.call(obj[i], i, obj[i]);

	                        if (value === false) {
	                            break;
	                        }
	                    }
	                } else {
	                    for (i in obj) {
	                        value = callback.call(obj[i], i, obj[i]);

	                        if (value === false) {
	                            break;
	                        }
	                    }
	                }
	            }

	            return obj;
	        },

	        trim: function trim(text) {
	            return text == null ? "" : _trim.call(text);
	        },

	        // results is for internal usage only
	        makeArray: function makeArray(arr, results) {
	            var ret = results || [];

	            if (arr != null) {
	                if (isArraylike(Object(arr))) {
	                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
	                } else {
	                    push.call(ret, arr);
	                }
	            }

	            return ret;
	        },

	        inArray: function inArray(elem, arr, i) {
	            return arr == null ? -1 : indexOf.call(arr, elem, i);
	        },

	        merge: function merge(first, second) {
	            var len = +second.length,
	                j = 0,
	                i = first.length;

	            for (; j < len; j++) {
	                first[i++] = second[j];
	            }

	            first.length = i;

	            return first;
	        },

	        grep: function grep(elems, callback, invert) {
	            var callbackInverse,
	                matches = [],
	                i = 0,
	                length = elems.length,
	                callbackExpect = !invert;

	            // Go through the array, only saving the items
	            // that pass the validator function
	            for (; i < length; i++) {
	                callbackInverse = !callback(elems[i], i);
	                if (callbackInverse !== callbackExpect) {
	                    matches.push(elems[i]);
	                }
	            }

	            return matches;
	        },

	        // arg is for internal usage only
	        map: function map(elems, callback, arg) {
	            var value,
	                i = 0,
	                length = elems.length,
	                isArray = isArraylike(elems),
	                ret = [];

	            // Go through the array, translating each of the items to their new values
	            if (isArray) {
	                for (; i < length; i++) {
	                    value = callback(elems[i], i, arg);

	                    if (value != null) {
	                        ret.push(value);
	                    }
	                }

	                // Go through every key on the object,
	            } else {
	                for (i in elems) {
	                    value = callback(elems[i], i, arg);

	                    if (value != null) {
	                        ret.push(value);
	                    }
	                }
	            }

	            // Flatten any nested arrays
	            return concat.apply([], ret);
	        },

	        // A global GUID counter for objects
	        guid: 1,

	        // Bind a function to a context, optionally partially applying any
	        // arguments.
	        proxy: function proxy(fn, context) {
	            var tmp, args, proxy;

	            if (typeof context === "string") {
	                tmp = fn[context];
	                context = fn;
	                fn = tmp;
	            }

	            // Quick check to determine if target is callable, in the spec
	            // this throws a TypeError, but we will just return undefined.
	            if (!jQuery.isFunction(fn)) {
	                return undefined;
	            }

	            // Simulated bind
	            args = _slice.call(arguments, 2);
	            proxy = function proxy() {
	                return fn.apply(context || this, args.concat(_slice.call(arguments)));
	            };

	            // Set the guid of unique handler to the same of original handler, so it can be removed
	            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	            return proxy;
	        },

	        now: Date.now,

	        // jQuery.support is not used in Core but other projects attach their
	        // properties to it so it needs to exist.
	        support: support
	    });

	    // Populate the class2type map
	    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
	        class2type["[object " + name + "]"] = name.toLowerCase();
	    });

	    function isArraylike(obj) {
	        var length = obj.length,
	            type = jQuery.type(obj);

	        if (type === "function" || jQuery.isWindow(obj)) {
	            return false;
	        }

	        if (obj.nodeType === 1 && length) {
	            return true;
	        }

	        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	    }
	    var Sizzle =
	    /*!
	     * Sizzle CSS Selector Engine v1.10.16
	     * http://sizzlejs.com/
	     *
	     * Copyright 2013 jQuery Foundation, Inc. and other contributors
	     * Released under the MIT license
	     * http://jquery.org/license
	     *
	     * Date: 2014-01-13
	     */
	    function (window) {

	        var i,
	            support,
	            Expr,
	            getText,
	            isXML,
	            compile,
	            outermostContext,
	            sortInput,
	            hasDuplicate,


	        // Local document vars
	        setDocument,
	            document,
	            docElem,
	            documentIsHTML,
	            rbuggyQSA,
	            rbuggyMatches,
	            matches,
	            contains,


	        // Instance-specific data
	        expando = "sizzle" + -new Date(),
	            preferredDoc = window.document,
	            dirruns = 0,
	            done = 0,
	            classCache = createCache(),
	            tokenCache = createCache(),
	            compilerCache = createCache(),
	            sortOrder = function sortOrder(a, b) {
	            if (a === b) {
	                hasDuplicate = true;
	            }
	            return 0;
	        },


	        // General-purpose constants
	        strundefined =  true ? "undefined" : _typeof(undefined),
	            MAX_NEGATIVE = 1 << 31,


	        // Instance methods
	        hasOwn = {}.hasOwnProperty,
	            arr = [],
	            pop = arr.pop,
	            push_native = arr.push,
	            push = arr.push,
	            slice = arr.slice,

	        // Use a stripped-down indexOf if we can't use a native one
	        indexOf = arr.indexOf || function (elem) {
	            var i = 0,
	                len = this.length;
	            for (; i < len; i++) {
	                if (this[i] === elem) {
	                    return i;
	                }
	            }
	            return -1;
	        },
	            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


	        // Regular expressions

	        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	        whitespace = "[\\x20\\t\\r\\n\\f]",

	        // http://www.w3.org/TR/css3-syntax/#characters
	        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


	        // Loosely modeled on CSS identifier characters
	        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	        identifier = characterEncoding.replace("w", "w#"),


	        // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",


	        // Prefer arguments quoted,
	        //   then not containing pseudos/brackets,
	        //   then attribute selectors/non-parenthetical expressions,
	        //   then anything else
	        // These preferences are here to reduce the number of selectors
	        //   needing tokenize in the PSEUDO preFilter
	        pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",


	        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
	            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
	            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
	            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
	            rpseudo = new RegExp(pseudos),
	            ridentifier = new RegExp("^" + identifier + "$"),
	            matchExpr = {
	            "ID": new RegExp("^#(" + characterEncoding + ")"),
	            "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
	            "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
	            "ATTR": new RegExp("^" + attributes),
	            "PSEUDO": new RegExp("^" + pseudos),
	            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
	            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
	            // For use in libraries implementing .is()
	            // We use this for POS matching in `select`
	            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
	        },
	            rinputs = /^(?:input|select|textarea|button)$/i,
	            rheader = /^h\d$/i,
	            rnative = /^[^{]+\{\s*\[native \w/,


	        // Easily-parseable/retrievable ID or TAG or CLASS selectors
	        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	            rsibling = /[+~]/,
	            rescape = /'|\\/g,


	        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
	            funescape = function funescape(_, escaped, escapedWhitespace) {
	            var high = "0x" + escaped - 0x10000;
	            // NaN means non-codepoint
	            // Support: Firefox
	            // Workaround erroneous numeric interpretation of +"0x"
	            return high !== high || escapedWhitespace ? escaped : high < 0 ?
	            // BMP codepoint
	            String.fromCharCode(high + 0x10000) :
	            // Supplemental Plane codepoint (surrogate pair)
	            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
	        };

	        // Optimize for push.apply( _, NodeList )
	        try {
	            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
	            // Support: Android<4.0
	            // Detect silently failing push.apply
	            arr[preferredDoc.childNodes.length].nodeType;
	        } catch (e) {
	            push = {
	                apply: arr.length ?

	                // Leverage slice if possible
	                function (target, els) {
	                    push_native.apply(target, slice.call(els));
	                } :

	                // Support: IE<9
	                // Otherwise append directly
	                function (target, els) {
	                    var j = target.length,
	                        i = 0;
	                    // Can't trust NodeList.length
	                    while (target[j++] = els[i++]) {}
	                    target.length = j - 1;
	                }
	            };
	        }

	        function Sizzle(selector, context, results, seed) {
	            var match, elem, m, nodeType,
	            // QSA vars
	            i, groups, old, nid, newContext, newSelector;

	            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
	                setDocument(context);
	            }

	            context = context || document;
	            results = results || [];

	            if (!selector || typeof selector !== "string") {
	                return results;
	            }

	            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
	                return [];
	            }

	            if (documentIsHTML && !seed) {

	                // Shortcuts
	                if (match = rquickExpr.exec(selector)) {
	                    // Speed-up: Sizzle("#ID")
	                    if (m = match[1]) {
	                        if (nodeType === 9) {
	                            elem = context.getElementById(m);
	                            // Check parentNode to catch when Blackberry 4.6 returns
	                            // nodes that are no longer in the document (jQuery #6963)
	                            if (elem && elem.parentNode) {
	                                // Handle the case where IE, Opera, and Webkit return items
	                                // by name instead of ID
	                                if (elem.id === m) {
	                                    results.push(elem);
	                                    return results;
	                                }
	                            } else {
	                                return results;
	                            }
	                        } else {
	                            // Context is not a document
	                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
	                                results.push(elem);
	                                return results;
	                            }
	                        }

	                        // Speed-up: Sizzle("TAG")
	                    } else if (match[2]) {
	                        push.apply(results, context.getElementsByTagName(selector));
	                        return results;

	                        // Speed-up: Sizzle(".CLASS")
	                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
	                        push.apply(results, context.getElementsByClassName(m));
	                        return results;
	                    }
	                }

	                // QSA path
	                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
	                    nid = old = expando;
	                    newContext = context;
	                    newSelector = nodeType === 9 && selector;

	                    // qSA works strangely on Element-rooted queries
	                    // We can work around this by specifying an extra ID on the root
	                    // and working up from there (Thanks to Andrew Dupont for the technique)
	                    // IE 8 doesn't work on object elements
	                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
	                        groups = tokenize(selector);

	                        if (old = context.getAttribute("id")) {
	                            nid = old.replace(rescape, "\\$&");
	                        } else {
	                            context.setAttribute("id", nid);
	                        }
	                        nid = "[id='" + nid + "'] ";

	                        i = groups.length;
	                        while (i--) {
	                            groups[i] = nid + toSelector(groups[i]);
	                        }
	                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
	                        newSelector = groups.join(",");
	                    }

	                    if (newSelector) {
	                        try {
	                            push.apply(results, newContext.querySelectorAll(newSelector));
	                            return results;
	                        } catch (qsaError) {} finally {
	                            if (!old) {
	                                context.removeAttribute("id");
	                            }
	                        }
	                    }
	                }
	            }

	            // All others
	            return select(selector.replace(rtrim, "$1"), context, results, seed);
	        }

	        /**
	         * Create key-value caches of limited size
	         * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	         *	deleting the oldest entry
	         */
	        function createCache() {
	            var keys = [];

	            function cache(key, value) {
	                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
	                if (keys.push(key + " ") > Expr.cacheLength) {
	                    // Only keep the most recent entries
	                    delete cache[keys.shift()];
	                }
	                return cache[key + " "] = value;
	            }
	            return cache;
	        }

	        /**
	         * Mark a function for special use by Sizzle
	         * @param {Function} fn The function to mark
	         */
	        function markFunction(fn) {
	            fn[expando] = true;
	            return fn;
	        }

	        /**
	         * Support testing using an element
	         * @param {Function} fn Passed the created div and expects a boolean result
	         */
	        function assert(fn) {
	            var div = document.createElement("div");

	            try {
	                return !!fn(div);
	            } catch (e) {
	                return false;
	            } finally {
	                // Remove from its parent by default
	                if (div.parentNode) {
	                    div.parentNode.removeChild(div);
	                }
	                // release memory in IE
	                div = null;
	            }
	        }

	        /**
	         * Adds the same handler for all of the specified attrs
	         * @param {String} attrs Pipe-separated list of attributes
	         * @param {Function} handler The method that will be applied
	         */
	        function addHandle(attrs, handler) {
	            var arr = attrs.split("|"),
	                i = attrs.length;

	            while (i--) {
	                Expr.attrHandle[arr[i]] = handler;
	            }
	        }

	        /**
	         * Checks document order of two siblings
	         * @param {Element} a
	         * @param {Element} b
	         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	         */
	        function siblingCheck(a, b) {
	            var cur = b && a,
	                diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

	            // Use IE sourceIndex if available on both nodes
	            if (diff) {
	                return diff;
	            }

	            // Check if b follows a
	            if (cur) {
	                while (cur = cur.nextSibling) {
	                    if (cur === b) {
	                        return -1;
	                    }
	                }
	            }

	            return a ? 1 : -1;
	        }

	        /**
	         * Returns a function to use in pseudos for input types
	         * @param {String} type
	         */
	        function createInputPseudo(type) {
	            return function (elem) {
	                var name = elem.nodeName.toLowerCase();
	                return name === "input" && elem.type === type;
	            };
	        }

	        /**
	         * Returns a function to use in pseudos for buttons
	         * @param {String} type
	         */
	        function createButtonPseudo(type) {
	            return function (elem) {
	                var name = elem.nodeName.toLowerCase();
	                return (name === "input" || name === "button") && elem.type === type;
	            };
	        }

	        /**
	         * Returns a function to use in pseudos for positionals
	         * @param {Function} fn
	         */
	        function createPositionalPseudo(fn) {
	            return markFunction(function (argument) {
	                argument = +argument;
	                return markFunction(function (seed, matches) {
	                    var j,
	                        matchIndexes = fn([], seed.length, argument),
	                        i = matchIndexes.length;

	                    // Match elements found at the specified indexes
	                    while (i--) {
	                        if (seed[j = matchIndexes[i]]) {
	                            seed[j] = !(matches[j] = seed[j]);
	                        }
	                    }
	                });
	            });
	        }

	        /**
	         * Checks a node for validity as a Sizzle context
	         * @param {Element|Object=} context
	         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	         */
	        function testContext(context) {
	            return context && _typeof(context.getElementsByTagName) !== strundefined && context;
	        }

	        // Expose support vars for convenience
	        support = Sizzle.support = {};

	        /**
	         * Detects XML nodes
	         * @param {Element|Object} elem An element or a document
	         * @returns {Boolean} True iff elem is a non-HTML XML node
	         */
	        isXML = Sizzle.isXML = function (elem) {
	            // documentElement is verified for cases where it doesn't yet exist
	            // (such as loading iframes in IE - #4833)
	            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	            return documentElement ? documentElement.nodeName !== "HTML" : false;
	        };

	        /**
	         * Sets document-related variables once based on the current document
	         * @param {Element|Object} [doc] An element or document object to use to set the document
	         * @returns {Object} Returns the current document
	         */
	        setDocument = Sizzle.setDocument = function (node) {
	            var hasCompare,
	                doc = node ? node.ownerDocument || node : preferredDoc,
	                parent = doc.defaultView;

	            // If no document and documentElement is available, return
	            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
	                return document;
	            }

	            // Set our document
	            document = doc;
	            docElem = doc.documentElement;

	            // Support tests
	            documentIsHTML = !isXML(doc);

	            // Support: IE>8
	            // If iframe document is assigned to "document" variable and if iframe has been reloaded,
	            // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	            // IE6-8 do not support the defaultView property so parent will be undefined
	            if (parent && parent !== parent.top) {
	                // IE11 does not have attachEvent, so all must suffer
	                if (parent.addEventListener) {
	                    parent.addEventListener("unload", function () {
	                        setDocument();
	                    }, false);
	                } else if (parent.attachEvent) {
	                    parent.attachEvent("onunload", function () {
	                        setDocument();
	                    });
	                }
	            }

	            /* Attributes
	             ---------------------------------------------------------------------- */

	            // Support: IE<8
	            // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	            support.attributes = assert(function (div) {
	                div.className = "i";
	                return !div.getAttribute("className");
	            });

	            /* getElement(s)By*
	             ---------------------------------------------------------------------- */

	            // Check if getElementsByTagName("*") returns only elements
	            support.getElementsByTagName = assert(function (div) {
	                div.appendChild(doc.createComment(""));
	                return !div.getElementsByTagName("*").length;
	            });

	            // Check if getElementsByClassName can be trusted
	            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
	                div.innerHTML = "<div class='a'></div><div class='a i'></div>";

	                // Support: Safari<4
	                // Catch class over-caching
	                div.firstChild.className = "i";
	                // Support: Opera<10
	                // Catch gEBCN failure to find non-leading classes
	                return div.getElementsByClassName("i").length === 2;
	            });

	            // Support: IE<10
	            // Check if getElementById returns elements by name
	            // The broken getElementById methods don't pick up programatically-set names,
	            // so use a roundabout getElementsByName test
	            support.getById = assert(function (div) {
	                docElem.appendChild(div).id = expando;
	                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
	            });

	            // ID find and filter
	            if (support.getById) {
	                Expr.find["ID"] = function (id, context) {
	                    if (_typeof(context.getElementById) !== strundefined && documentIsHTML) {
	                        var m = context.getElementById(id);
	                        // Check parentNode to catch when Blackberry 4.6 returns
	                        // nodes that are no longer in the document #6963
	                        return m && m.parentNode ? [m] : [];
	                    }
	                };
	                Expr.filter["ID"] = function (id) {
	                    var attrId = id.replace(runescape, funescape);
	                    return function (elem) {
	                        return elem.getAttribute("id") === attrId;
	                    };
	                };
	            } else {
	                // Support: IE6/7
	                // getElementById is not reliable as a find shortcut
	                delete Expr.find["ID"];

	                Expr.filter["ID"] = function (id) {
	                    var attrId = id.replace(runescape, funescape);
	                    return function (elem) {
	                        var node = _typeof(elem.getAttributeNode) !== strundefined && elem.getAttributeNode("id");
	                        return node && node.value === attrId;
	                    };
	                };
	            }

	            // Tag
	            Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
	                if (_typeof(context.getElementsByTagName) !== strundefined) {
	                    return context.getElementsByTagName(tag);
	                }
	            } : function (tag, context) {
	                var elem,
	                    tmp = [],
	                    i = 0,
	                    results = context.getElementsByTagName(tag);

	                // Filter out possible comments
	                if (tag === "*") {
	                    while (elem = results[i++]) {
	                        if (elem.nodeType === 1) {
	                            tmp.push(elem);
	                        }
	                    }

	                    return tmp;
	                }
	                return results;
	            };

	            // Class
	            Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
	                if (_typeof(context.getElementsByClassName) !== strundefined && documentIsHTML) {
	                    return context.getElementsByClassName(className);
	                }
	            };

	            /* QSA/matchesSelector
	             ---------------------------------------------------------------------- */

	            // QSA and matchesSelector support

	            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	            rbuggyMatches = [];

	            // qSa(:focus) reports false when true (Chrome 21)
	            // We allow this because of a bug in IE8/9 that throws an error
	            // whenever `document.activeElement` is accessed on an iframe
	            // So, we allow :focus to pass through QSA all the time to avoid the IE error
	            // See http://bugs.jquery.com/ticket/13378
	            rbuggyQSA = [];

	            if (support.qsa = rnative.test(doc.querySelectorAll)) {
	                // Build QSA regex
	                // Regex strategy adopted from Diego Perini
	                assert(function (div) {
	                    // Select is set to empty string on purpose
	                    // This is to test IE's treatment of not explicitly
	                    // setting a boolean content attribute,
	                    // since its presence should be enough
	                    // http://bugs.jquery.com/ticket/12359
	                    div.innerHTML = "<select t=''><option selected=''></option></select>";

	                    // Support: IE8, Opera 10-12
	                    // Nothing should be selected when empty strings follow ^= or $= or *=
	                    if (div.querySelectorAll("[t^='']").length) {
	                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
	                    }

	                    // Support: IE8
	                    // Boolean attributes and "value" are not treated correctly
	                    if (!div.querySelectorAll("[selected]").length) {
	                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
	                    }

	                    // Webkit/Opera - :checked should return selected option elements
	                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	                    // IE8 throws error here and will not see later tests
	                    if (!div.querySelectorAll(":checked").length) {
	                        rbuggyQSA.push(":checked");
	                    }
	                });

	                assert(function (div) {
	                    // Support: Windows 8 Native Apps
	                    // The type and name attributes are restricted during .innerHTML assignment
	                    var input = doc.createElement("input");
	                    input.setAttribute("type", "hidden");
	                    div.appendChild(input).setAttribute("name", "D");

	                    // Support: IE8
	                    // Enforce case-sensitivity of name attribute
	                    if (div.querySelectorAll("[name=d]").length) {
	                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
	                    }

	                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	                    // IE8 throws error here and will not see later tests
	                    if (!div.querySelectorAll(":enabled").length) {
	                        rbuggyQSA.push(":enabled", ":disabled");
	                    }

	                    // Opera 10-11 does not throw on post-comma invalid pseudos
	                    div.querySelectorAll("*,:x");
	                    rbuggyQSA.push(",.*:");
	                });
	            }

	            if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

	                assert(function (div) {
	                    // Check to see if it's possible to do matchesSelector
	                    // on a disconnected node (IE 9)
	                    support.disconnectedMatch = matches.call(div, "div");

	                    // This should fail with an exception
	                    // Gecko does not error, returns false instead
	                    matches.call(div, "[s!='']:x");
	                    rbuggyMatches.push("!=", pseudos);
	                });
	            }

	            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
	            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

	            /* Contains
	             ---------------------------------------------------------------------- */
	            hasCompare = rnative.test(docElem.compareDocumentPosition);

	            // Element contains another
	            // Purposefully does not implement inclusive descendent
	            // As in, an element does not contain itself
	            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
	                var adown = a.nodeType === 9 ? a.documentElement : a,
	                    bup = b && b.parentNode;
	                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
	            } : function (a, b) {
	                if (b) {
	                    while (b = b.parentNode) {
	                        if (b === a) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            };

	            /* Sorting
	             ---------------------------------------------------------------------- */

	            // Document order sorting
	            sortOrder = hasCompare ? function (a, b) {

	                // Flag for duplicate removal
	                if (a === b) {
	                    hasDuplicate = true;
	                    return 0;
	                }

	                // Sort on method existence if only one input has compareDocumentPosition
	                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
	                if (compare) {
	                    return compare;
	                }

	                // Calculate position if both inputs belong to the same document
	                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

	                // Otherwise we know they are disconnected
	                1;

	                // Disconnected nodes
	                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

	                    // Choose the first element that is related to our preferred document
	                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
	                        return -1;
	                    }
	                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
	                        return 1;
	                    }

	                    // Maintain original order
	                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
	                }

	                return compare & 4 ? -1 : 1;
	            } : function (a, b) {
	                // Exit early if the nodes are identical
	                if (a === b) {
	                    hasDuplicate = true;
	                    return 0;
	                }

	                var cur,
	                    i = 0,
	                    aup = a.parentNode,
	                    bup = b.parentNode,
	                    ap = [a],
	                    bp = [b];

	                // Parentless nodes are either documents or disconnected
	                if (!aup || !bup) {
	                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;

	                    // If the nodes are siblings, we can do a quick check
	                } else if (aup === bup) {
	                    return siblingCheck(a, b);
	                }

	                // Otherwise we need full lists of their ancestors for comparison
	                cur = a;
	                while (cur = cur.parentNode) {
	                    ap.unshift(cur);
	                }
	                cur = b;
	                while (cur = cur.parentNode) {
	                    bp.unshift(cur);
	                }

	                // Walk down the tree looking for a discrepancy
	                while (ap[i] === bp[i]) {
	                    i++;
	                }

	                return i ?
	                // Do a sibling check if the nodes have a common ancestor
	                siblingCheck(ap[i], bp[i]) :

	                // Otherwise nodes in our document sort first
	                ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
	            };

	            return doc;
	        };

	        Sizzle.matches = function (expr, elements) {
	            return Sizzle(expr, null, null, elements);
	        };

	        Sizzle.matchesSelector = function (elem, expr) {
	            // Set document vars if needed
	            if ((elem.ownerDocument || elem) !== document) {
	                setDocument(elem);
	            }

	            // Make sure that attribute selectors are quoted
	            expr = expr.replace(rattributeQuotes, "='$1']");

	            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

	                try {
	                    var ret = matches.call(elem, expr);

	                    // IE 9's matchesSelector returns false on disconnected nodes
	                    if (ret || support.disconnectedMatch ||
	                    // As well, disconnected nodes are said to be in a document
	                    // fragment in IE 9
	                    elem.document && elem.document.nodeType !== 11) {
	                        return ret;
	                    }
	                } catch (e) {}
	            }

	            return Sizzle(expr, document, null, [elem]).length > 0;
	        };

	        Sizzle.contains = function (context, elem) {
	            // Set document vars if needed
	            if ((context.ownerDocument || context) !== document) {
	                setDocument(context);
	            }
	            return contains(context, elem);
	        };

	        Sizzle.attr = function (elem, name) {
	            // Set document vars if needed
	            if ((elem.ownerDocument || elem) !== document) {
	                setDocument(elem);
	            }

	            var fn = Expr.attrHandle[name.toLowerCase()],

	            // Don't get fooled by Object.prototype properties (jQuery #13807)
	            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

	            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	        };

	        Sizzle.error = function (msg) {
	            throw new Error("Syntax error, unrecognized expression: " + msg);
	        };

	        /**
	         * Document sorting and removing duplicates
	         * @param {ArrayLike} results
	         */
	        Sizzle.uniqueSort = function (results) {
	            var elem,
	                duplicates = [],
	                j = 0,
	                i = 0;

	            // Unless we *know* we can detect duplicates, assume their presence
	            hasDuplicate = !support.detectDuplicates;
	            sortInput = !support.sortStable && results.slice(0);
	            results.sort(sortOrder);

	            if (hasDuplicate) {
	                while (elem = results[i++]) {
	                    if (elem === results[i]) {
	                        j = duplicates.push(i);
	                    }
	                }
	                while (j--) {
	                    results.splice(duplicates[j], 1);
	                }
	            }

	            // Clear input after sorting to release objects
	            // See https://github.com/jquery/sizzle/pull/225
	            sortInput = null;

	            return results;
	        };

	        /**
	         * Utility function for retrieving the text value of an array of DOM nodes
	         * @param {Array|Element} elem
	         */
	        getText = Sizzle.getText = function (elem) {
	            var node,
	                ret = "",
	                i = 0,
	                nodeType = elem.nodeType;

	            if (!nodeType) {
	                // If no nodeType, this is expected to be an array
	                while (node = elem[i++]) {
	                    // Do not traverse comment nodes
	                    ret += getText(node);
	                }
	            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
	                // Use textContent for elements
	                // innerText usage removed for consistency of new lines (jQuery #11153)
	                if (typeof elem.textContent === "string") {
	                    return elem.textContent;
	                } else {
	                    // Traverse its children
	                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	                        ret += getText(elem);
	                    }
	                }
	            } else if (nodeType === 3 || nodeType === 4) {
	                return elem.nodeValue;
	            }
	            // Do not include comment or processing instruction nodes

	            return ret;
	        };

	        Expr = Sizzle.selectors = {

	            // Can be adjusted by the user
	            cacheLength: 50,

	            createPseudo: markFunction,

	            match: matchExpr,

	            attrHandle: {},

	            find: {},

	            relative: {
	                ">": {
	                    dir: "parentNode",
	                    first: true
	                },
	                " ": {
	                    dir: "parentNode"
	                },
	                "+": {
	                    dir: "previousSibling",
	                    first: true
	                },
	                "~": {
	                    dir: "previousSibling"
	                }
	            },

	            preFilter: {
	                "ATTR": function ATTR(match) {
	                    match[1] = match[1].replace(runescape, funescape);

	                    // Move the given value to match[3] whether quoted or unquoted
	                    match[3] = (match[4] || match[5] || "").replace(runescape, funescape);

	                    if (match[2] === "~=") {
	                        match[3] = " " + match[3] + " ";
	                    }

	                    return match.slice(0, 4);
	                },

	                "CHILD": function CHILD(match) {
	                    /* matches from matchExpr["CHILD"]
	                     1 type (only|nth|...)
	                     2 what (child|of-type)
	                     3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	                     4 xn-component of xn+y argument ([+-]?\d*n|)
	                     5 sign of xn-component
	                     6 x of xn-component
	                     7 sign of y-component
	                     8 y of y-component
	                     */
	                    match[1] = match[1].toLowerCase();

	                    if (match[1].slice(0, 3) === "nth") {
	                        // nth-* requires argument
	                        if (!match[3]) {
	                            Sizzle.error(match[0]);
	                        }

	                        // numeric x and y parameters for Expr.filter.CHILD
	                        // remember that false/true cast respectively to 0/1
	                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
	                        match[5] = +(match[7] + match[8] || match[3] === "odd");

	                        // other types prohibit arguments
	                    } else if (match[3]) {
	                        Sizzle.error(match[0]);
	                    }

	                    return match;
	                },

	                "PSEUDO": function PSEUDO(match) {
	                    var excess,
	                        unquoted = !match[5] && match[2];

	                    if (matchExpr["CHILD"].test(match[0])) {
	                        return null;
	                    }

	                    // Accept quoted arguments as-is
	                    if (match[3] && match[4] !== undefined) {
	                        match[2] = match[4];

	                        // Strip excess characters from unquoted arguments
	                    } else if (unquoted && rpseudo.test(unquoted) && (
	                    // Get excess from tokenize (recursively)
	                    excess = tokenize(unquoted, true)) && (
	                    // advance to the next closing parenthesis
	                    excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

	                        // excess is a negative index
	                        match[0] = match[0].slice(0, excess);
	                        match[2] = unquoted.slice(0, excess);
	                    }

	                    // Return only captures needed by the pseudo filter method (type and argument)
	                    return match.slice(0, 3);
	                }
	            },

	            filter: {

	                "TAG": function TAG(nodeNameSelector) {
	                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
	                    return nodeNameSelector === "*" ? function () {
	                        return true;
	                    } : function (elem) {
	                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	                    };
	                },

	                "CLASS": function CLASS(className) {
	                    var pattern = classCache[className + " "];

	                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
	                        return pattern.test(typeof elem.className === "string" && elem.className || _typeof(elem.getAttribute) !== strundefined && elem.getAttribute("class") || "");
	                    });
	                },

	                "ATTR": function ATTR(name, operator, check) {
	                    return function (elem) {
	                        var result = Sizzle.attr(elem, name);

	                        if (result == null) {
	                            return operator === "!=";
	                        }
	                        if (!operator) {
	                            return true;
	                        }

	                        result += "";

	                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
	                    };
	                },

	                "CHILD": function CHILD(type, what, argument, first, last) {
	                    var simple = type.slice(0, 3) !== "nth",
	                        forward = type.slice(-4) !== "last",
	                        ofType = what === "of-type";

	                    return first === 1 && last === 0 ?

	                    // Shortcut for :nth-*(n)
	                    function (elem) {
	                        return !!elem.parentNode;
	                    } : function (elem, context, xml) {
	                        var cache,
	                            outerCache,
	                            node,
	                            diff,
	                            nodeIndex,
	                            start,
	                            dir = simple !== forward ? "nextSibling" : "previousSibling",
	                            parent = elem.parentNode,
	                            name = ofType && elem.nodeName.toLowerCase(),
	                            useCache = !xml && !ofType;

	                        if (parent) {

	                            // :(first|last|only)-(child|of-type)
	                            if (simple) {
	                                while (dir) {
	                                    node = elem;
	                                    while (node = node[dir]) {
	                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
	                                            return false;
	                                        }
	                                    }
	                                    // Reverse direction for :only-* (if we haven't yet done so)
	                                    start = dir = type === "only" && !start && "nextSibling";
	                                }
	                                return true;
	                            }

	                            start = [forward ? parent.firstChild : parent.lastChild];

	                            // non-xml :nth-child(...) stores cache data on `parent`
	                            if (forward && useCache) {
	                                // Seek `elem` from a previously-cached index
	                                outerCache = parent[expando] || (parent[expando] = {});
	                                cache = outerCache[type] || [];
	                                nodeIndex = cache[0] === dirruns && cache[1];
	                                diff = cache[0] === dirruns && cache[2];
	                                node = nodeIndex && parent.childNodes[nodeIndex];

	                                while (node = ++nodeIndex && node && node[dir] || (

	                                // Fallback to seeking `elem` from the start
	                                diff = nodeIndex = 0) || start.pop()) {

	                                    // When found, cache indexes on `parent` and break
	                                    if (node.nodeType === 1 && ++diff && node === elem) {
	                                        outerCache[type] = [dirruns, nodeIndex, diff];
	                                        break;
	                                    }
	                                }

	                                // Use previously-cached element index if available
	                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
	                                diff = cache[1];

	                                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
	                            } else {
	                                // Use the same loop as above to seek `elem` from the start
	                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

	                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
	                                        // Cache the index of each encountered element
	                                        if (useCache) {
	                                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
	                                        }

	                                        if (node === elem) {
	                                            break;
	                                        }
	                                    }
	                                }
	                            }

	                            // Incorporate the offset, then check against cycle size
	                            diff -= last;
	                            return diff === first || diff % first === 0 && diff / first >= 0;
	                        }
	                    };
	                },

	                "PSEUDO": function PSEUDO(pseudo, argument) {
	                    // pseudo-class names are case-insensitive
	                    // http://www.w3.org/TR/selectors/#pseudo-classes
	                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	                    // Remember that setFilters inherits from pseudos
	                    var args,
	                        fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

	                    // The user may use createPseudo to indicate that
	                    // arguments are needed to create the filter function
	                    // just as Sizzle does
	                    if (fn[expando]) {
	                        return fn(argument);
	                    }

	                    // But maintain support for old signatures
	                    if (fn.length > 1) {
	                        args = [pseudo, pseudo, "", argument];
	                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
	                            var idx,
	                                matched = fn(seed, argument),
	                                i = matched.length;
	                            while (i--) {
	                                idx = indexOf.call(seed, matched[i]);
	                                seed[idx] = !(matches[idx] = matched[i]);
	                            }
	                        }) : function (elem) {
	                            return fn(elem, 0, args);
	                        };
	                    }

	                    return fn;
	                }
	            },

	            pseudos: {
	                // Potentially complex pseudos
	                "not": markFunction(function (selector) {
	                    // Trim the selector passed to compile
	                    // to avoid treating leading and trailing
	                    // spaces as combinators
	                    var input = [],
	                        results = [],
	                        matcher = compile(selector.replace(rtrim, "$1"));

	                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
	                        var elem,
	                            unmatched = matcher(seed, null, xml, []),
	                            i = seed.length;

	                        // Match elements unmatched by `matcher`
	                        while (i--) {
	                            if (elem = unmatched[i]) {
	                                seed[i] = !(matches[i] = elem);
	                            }
	                        }
	                    }) : function (elem, context, xml) {
	                        input[0] = elem;
	                        matcher(input, null, xml, results);
	                        return !results.pop();
	                    };
	                }),

	                "has": markFunction(function (selector) {
	                    return function (elem) {
	                        return Sizzle(selector, elem).length > 0;
	                    };
	                }),

	                "contains": markFunction(function (text) {
	                    return function (elem) {
	                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
	                    };
	                }),

	                // "Whether an element is represented by a :lang() selector
	                // is based solely on the element's language value
	                // being equal to the identifier C,
	                // or beginning with the identifier C immediately followed by "-".
	                // The matching of C against the element's language value is performed case-insensitively.
	                // The identifier C does not have to be a valid language name."
	                // http://www.w3.org/TR/selectors/#lang-pseudo
	                "lang": markFunction(function (lang) {
	                    // lang value must be a valid identifier
	                    if (!ridentifier.test(lang || "")) {
	                        Sizzle.error("unsupported lang: " + lang);
	                    }
	                    lang = lang.replace(runescape, funescape).toLowerCase();
	                    return function (elem) {
	                        var elemLang;
	                        do {
	                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

	                                elemLang = elemLang.toLowerCase();
	                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
	                            }
	                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
	                        return false;
	                    };
	                }),

	                // Miscellaneous
	                "target": function target(elem) {
	                    var hash = window.location && window.location.hash;
	                    return hash && hash.slice(1) === elem.id;
	                },

	                "root": function root(elem) {
	                    return elem === docElem;
	                },

	                "focus": function focus(elem) {
	                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	                },

	                // Boolean properties
	                "enabled": function enabled(elem) {
	                    return elem.disabled === false;
	                },

	                "disabled": function disabled(elem) {
	                    return elem.disabled === true;
	                },

	                "checked": function checked(elem) {
	                    // In CSS3, :checked should return both checked and selected elements
	                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	                    var nodeName = elem.nodeName.toLowerCase();
	                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
	                },

	                "selected": function selected(elem) {
	                    // Accessing this property makes selected-by-default
	                    // options in Safari work properly
	                    if (elem.parentNode) {
	                        elem.parentNode.selectedIndex;
	                    }

	                    return elem.selected === true;
	                },

	                // Contents
	                "empty": function empty(elem) {
	                    // http://www.w3.org/TR/selectors/#empty-pseudo
	                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
	                    //   but not by others (comment: 8; processing instruction: 7; etc.)
	                    // nodeType < 6 works because attributes (2) do not appear as children
	                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	                        if (elem.nodeType < 6) {
	                            return false;
	                        }
	                    }
	                    return true;
	                },

	                "parent": function parent(elem) {
	                    return !Expr.pseudos["empty"](elem);
	                },

	                // Element/input types
	                "header": function header(elem) {
	                    return rheader.test(elem.nodeName);
	                },

	                "input": function input(elem) {
	                    return rinputs.test(elem.nodeName);
	                },

	                "button": function button(elem) {
	                    var name = elem.nodeName.toLowerCase();
	                    return name === "input" && elem.type === "button" || name === "button";
	                },

	                "text": function text(elem) {
	                    var attr;
	                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

	                    // Support: IE<8
	                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
	                    (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
	                },

	                // Position-in-collection
	                "first": createPositionalPseudo(function () {
	                    return [0];
	                }),

	                "last": createPositionalPseudo(function (matchIndexes, length) {
	                    return [length - 1];
	                }),

	                "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
	                    return [argument < 0 ? argument + length : argument];
	                }),

	                "even": createPositionalPseudo(function (matchIndexes, length) {
	                    var i = 0;
	                    for (; i < length; i += 2) {
	                        matchIndexes.push(i);
	                    }
	                    return matchIndexes;
	                }),

	                "odd": createPositionalPseudo(function (matchIndexes, length) {
	                    var i = 1;
	                    for (; i < length; i += 2) {
	                        matchIndexes.push(i);
	                    }
	                    return matchIndexes;
	                }),

	                "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
	                    var i = argument < 0 ? argument + length : argument;
	                    for (; --i >= 0;) {
	                        matchIndexes.push(i);
	                    }
	                    return matchIndexes;
	                }),

	                "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
	                    var i = argument < 0 ? argument + length : argument;
	                    for (; ++i < length;) {
	                        matchIndexes.push(i);
	                    }
	                    return matchIndexes;
	                })
	            }
	        };

	        Expr.pseudos["nth"] = Expr.pseudos["eq"];

	        // Add button/input type pseudos
	        for (i in {
	            radio: true,
	            checkbox: true,
	            file: true,
	            password: true,
	            image: true
	        }) {
	            Expr.pseudos[i] = createInputPseudo(i);
	        }
	        for (i in {
	            submit: true,
	            reset: true
	        }) {
	            Expr.pseudos[i] = createButtonPseudo(i);
	        }

	        // Easy API for creating new setFilters
	        function setFilters() {}
	        setFilters.prototype = Expr.filters = Expr.pseudos;
	        Expr.setFilters = new setFilters();

	        function tokenize(selector, parseOnly) {
	            var matched,
	                match,
	                tokens,
	                type,
	                soFar,
	                groups,
	                preFilters,
	                cached = tokenCache[selector + " "];

	            if (cached) {
	                return parseOnly ? 0 : cached.slice(0);
	            }

	            soFar = selector;
	            groups = [];
	            preFilters = Expr.preFilter;

	            while (soFar) {

	                // Comma and first run
	                if (!matched || (match = rcomma.exec(soFar))) {
	                    if (match) {
	                        // Don't consume trailing commas as valid
	                        soFar = soFar.slice(match[0].length) || soFar;
	                    }
	                    groups.push(tokens = []);
	                }

	                matched = false;

	                // Combinators
	                if (match = rcombinators.exec(soFar)) {
	                    matched = match.shift();
	                    tokens.push({
	                        value: matched,
	                        // Cast descendant combinators to space
	                        type: match[0].replace(rtrim, " ")
	                    });
	                    soFar = soFar.slice(matched.length);
	                }

	                // Filters
	                for (type in Expr.filter) {
	                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
	                        matched = match.shift();
	                        tokens.push({
	                            value: matched,
	                            type: type,
	                            matches: match
	                        });
	                        soFar = soFar.slice(matched.length);
	                    }
	                }

	                if (!matched) {
	                    break;
	                }
	            }

	            // Return the length of the invalid excess
	            // if we're just parsing
	            // Otherwise, throw an error or return tokens
	            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
	            // Cache the tokens
	            tokenCache(selector, groups).slice(0);
	        }

	        function toSelector(tokens) {
	            var i = 0,
	                len = tokens.length,
	                selector = "";
	            for (; i < len; i++) {
	                selector += tokens[i].value;
	            }
	            return selector;
	        }

	        function addCombinator(matcher, combinator, base) {
	            var dir = combinator.dir,
	                checkNonElements = base && dir === "parentNode",
	                doneName = done++;

	            return combinator.first ?
	            // Check against closest ancestor/preceding element
	            function (elem, context, xml) {
	                while (elem = elem[dir]) {
	                    if (elem.nodeType === 1 || checkNonElements) {
	                        return matcher(elem, context, xml);
	                    }
	                }
	            } :

	            // Check against all ancestor/preceding elements
	            function (elem, context, xml) {
	                var oldCache,
	                    outerCache,
	                    newCache = [dirruns, doneName];

	                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
	                if (xml) {
	                    while (elem = elem[dir]) {
	                        if (elem.nodeType === 1 || checkNonElements) {
	                            if (matcher(elem, context, xml)) {
	                                return true;
	                            }
	                        }
	                    }
	                } else {
	                    while (elem = elem[dir]) {
	                        if (elem.nodeType === 1 || checkNonElements) {
	                            outerCache = elem[expando] || (elem[expando] = {});
	                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

	                                // Assign to newCache so results back-propagate to previous elements
	                                return newCache[2] = oldCache[2];
	                            } else {
	                                // Reuse newcache so results back-propagate to previous elements
	                                outerCache[dir] = newCache;

	                                // A match means we're done; a fail means we have to keep checking
	                                if (newCache[2] = matcher(elem, context, xml)) {
	                                    return true;
	                                }
	                            }
	                        }
	                    }
	                }
	            };
	        }

	        function elementMatcher(matchers) {
	            return matchers.length > 1 ? function (elem, context, xml) {
	                var i = matchers.length;
	                while (i--) {
	                    if (!matchers[i](elem, context, xml)) {
	                        return false;
	                    }
	                }
	                return true;
	            } : matchers[0];
	        }

	        function condense(unmatched, map, filter, context, xml) {
	            var elem,
	                newUnmatched = [],
	                i = 0,
	                len = unmatched.length,
	                mapped = map != null;

	            for (; i < len; i++) {
	                if (elem = unmatched[i]) {
	                    if (!filter || filter(elem, context, xml)) {
	                        newUnmatched.push(elem);
	                        if (mapped) {
	                            map.push(i);
	                        }
	                    }
	                }
	            }

	            return newUnmatched;
	        }

	        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	            if (postFilter && !postFilter[expando]) {
	                postFilter = setMatcher(postFilter);
	            }
	            if (postFinder && !postFinder[expando]) {
	                postFinder = setMatcher(postFinder, postSelector);
	            }
	            return markFunction(function (seed, results, context, xml) {
	                var temp,
	                    i,
	                    elem,
	                    preMap = [],
	                    postMap = [],
	                    preexisting = results.length,


	                // Get initial elements from seed or context
	                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


	                // Prefilter to get matcher input, preserving a map for seed-results synchronization
	                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
	                    matcherOut = matcher ?
	                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	                postFinder || (seed ? preFilter : preexisting || postFilter) ?

	                // ...intermediate processing is necessary
	                [] :

	                // ...otherwise use results directly
	                results : matcherIn;

	                // Find primary matches
	                if (matcher) {
	                    matcher(matcherIn, matcherOut, context, xml);
	                }

	                // Apply postFilter
	                if (postFilter) {
	                    temp = condense(matcherOut, postMap);
	                    postFilter(temp, [], context, xml);

	                    // Un-match failing elements by moving them back to matcherIn
	                    i = temp.length;
	                    while (i--) {
	                        if (elem = temp[i]) {
	                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
	                        }
	                    }
	                }

	                if (seed) {
	                    if (postFinder || preFilter) {
	                        if (postFinder) {
	                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
	                            temp = [];
	                            i = matcherOut.length;
	                            while (i--) {
	                                if (elem = matcherOut[i]) {
	                                    // Restore matcherIn since elem is not yet a final match
	                                    temp.push(matcherIn[i] = elem);
	                                }
	                            }
	                            postFinder(null, matcherOut = [], temp, xml);
	                        }

	                        // Move matched elements from seed to results to keep them synchronized
	                        i = matcherOut.length;
	                        while (i--) {
	                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

	                                seed[temp] = !(results[temp] = elem);
	                            }
	                        }
	                    }

	                    // Add elements to results, through postFinder if defined
	                } else {
	                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
	                    if (postFinder) {
	                        postFinder(null, results, matcherOut, xml);
	                    } else {
	                        push.apply(results, matcherOut);
	                    }
	                }
	            });
	        }

	        function matcherFromTokens(tokens) {
	            var checkContext,
	                matcher,
	                j,
	                len = tokens.length,
	                leadingRelative = Expr.relative[tokens[0].type],
	                implicitRelative = leadingRelative || Expr.relative[" "],
	                i = leadingRelative ? 1 : 0,


	            // The foundational matcher ensures that elements are reachable from top-level context(s)
	            matchContext = addCombinator(function (elem) {
	                return elem === checkContext;
	            }, implicitRelative, true),
	                matchAnyContext = addCombinator(function (elem) {
	                return indexOf.call(checkContext, elem) > -1;
	            }, implicitRelative, true),
	                matchers = [function (elem, context, xml) {
	                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
	            }];

	            for (; i < len; i++) {
	                if (matcher = Expr.relative[tokens[i].type]) {
	                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
	                } else {
	                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

	                    // Return special upon seeing a positional matcher
	                    if (matcher[expando]) {
	                        // Find the next relative operator (if any) for proper handling
	                        j = ++i;
	                        for (; j < len; j++) {
	                            if (Expr.relative[tokens[j].type]) {
	                                break;
	                            }
	                        }
	                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
	                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
	                        tokens.slice(0, i - 1).concat({
	                            value: tokens[i - 2].type === " " ? "*" : ""
	                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
	                    }
	                    matchers.push(matcher);
	                }
	            }

	            return elementMatcher(matchers);
	        }

	        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
	            var bySet = setMatchers.length > 0,
	                byElement = elementMatchers.length > 0,
	                superMatcher = function superMatcher(seed, context, xml, results, outermost) {
	                var elem,
	                    j,
	                    matcher,
	                    matchedCount = 0,
	                    i = "0",
	                    unmatched = seed && [],
	                    setMatched = [],
	                    contextBackup = outermostContext,

	                // We must always have either seed elements or outermost context
	                elems = seed || byElement && Expr.find["TAG"]("*", outermost),

	                // Use integer dirruns iff this is the outermost matcher
	                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
	                    len = elems.length;

	                if (outermost) {
	                    outermostContext = context !== document && context;
	                }

	                // Add elements passing elementMatchers directly to results
	                // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
	                // Support: IE<9, Safari
	                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
	                for (; i !== len && (elem = elems[i]) != null; i++) {
	                    if (byElement && elem) {
	                        j = 0;
	                        while (matcher = elementMatchers[j++]) {
	                            if (matcher(elem, context, xml)) {
	                                results.push(elem);
	                                break;
	                            }
	                        }
	                        if (outermost) {
	                            dirruns = dirrunsUnique;
	                        }
	                    }

	                    // Track unmatched elements for set filters
	                    if (bySet) {
	                        // They will have gone through all possible matchers
	                        if (elem = !matcher && elem) {
	                            matchedCount--;
	                        }

	                        // Lengthen the array for every element, matched or not
	                        if (seed) {
	                            unmatched.push(elem);
	                        }
	                    }
	                }

	                // Apply set filters to unmatched elements
	                matchedCount += i;
	                if (bySet && i !== matchedCount) {
	                    j = 0;
	                    while (matcher = setMatchers[j++]) {
	                        matcher(unmatched, setMatched, context, xml);
	                    }

	                    if (seed) {
	                        // Reintegrate element matches to eliminate the need for sorting
	                        if (matchedCount > 0) {
	                            while (i--) {
	                                if (!(unmatched[i] || setMatched[i])) {
	                                    setMatched[i] = pop.call(results);
	                                }
	                            }
	                        }

	                        // Discard index placeholder values to get only actual matches
	                        setMatched = condense(setMatched);
	                    }

	                    // Add matches to results
	                    push.apply(results, setMatched);

	                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
	                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

	                        Sizzle.uniqueSort(results);
	                    }
	                }

	                // Override manipulation of globals by nested matchers
	                if (outermost) {
	                    dirruns = dirrunsUnique;
	                    outermostContext = contextBackup;
	                }

	                return unmatched;
	            };

	            return bySet ? markFunction(superMatcher) : superMatcher;
	        }

	        compile = Sizzle.compile = function (selector, group /* Internal Use Only */) {
	            var i,
	                setMatchers = [],
	                elementMatchers = [],
	                cached = compilerCache[selector + " "];

	            if (!cached) {
	                // Generate a function of recursive functions that can be used to check each element
	                if (!group) {
	                    group = tokenize(selector);
	                }
	                i = group.length;
	                while (i--) {
	                    cached = matcherFromTokens(group[i]);
	                    if (cached[expando]) {
	                        setMatchers.push(cached);
	                    } else {
	                        elementMatchers.push(cached);
	                    }
	                }

	                // Cache the compiled function
	                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
	            }
	            return cached;
	        };

	        function multipleContexts(selector, contexts, results) {
	            var i = 0,
	                len = contexts.length;
	            for (; i < len; i++) {
	                Sizzle(selector, contexts[i], results);
	            }
	            return results;
	        }

	        function select(selector, context, results, seed) {
	            var i,
	                tokens,
	                token,
	                type,
	                find,
	                match = tokenize(selector);

	            if (!seed) {
	                // Try to minimize operations if there is only one group
	                if (match.length === 1) {

	                    // Take a shortcut and set the context if the root selector is an ID
	                    tokens = match[0] = match[0].slice(0);
	                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

	                        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
	                        if (!context) {
	                            return results;
	                        }
	                        selector = selector.slice(tokens.shift().value.length);
	                    }

	                    // Fetch a seed set for right-to-left matching
	                    i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
	                    while (i--) {
	                        token = tokens[i];

	                        // Abort if we hit a combinator
	                        if (Expr.relative[type = token.type]) {
	                            break;
	                        }
	                        if (find = Expr.find[type]) {
	                            // Search, expanding context for leading sibling combinators
	                            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

	                                // If seed is empty or no tokens remain, we can return early
	                                tokens.splice(i, 1);
	                                selector = seed.length && toSelector(tokens);
	                                if (!selector) {
	                                    push.apply(results, seed);
	                                    return results;
	                                }

	                                break;
	                            }
	                        }
	                    }
	                }
	            }

	            // Compile and execute a filtering function
	            // Provide `match` to avoid retokenization if we modified the selector above
	            compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
	            return results;
	        }

	        // One-time assignments

	        // Sort stability
	        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

	        // Support: Chrome<14
	        // Always assume duplicates if they aren't passed to the comparison function
	        support.detectDuplicates = !!hasDuplicate;

	        // Initialize against the default document
	        setDocument();

	        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	        // Detached nodes confoundingly follow *each other*
	        support.sortDetached = assert(function (div1) {
	            // Should return 1, but returns 4 (following)
	            return div1.compareDocumentPosition(document.createElement("div")) & 1;
	        });

	        // Support: IE<8
	        // Prevent attribute/property "interpolation"
	        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	        if (!assert(function (div) {
	            div.innerHTML = "<a href='#'></a>";
	            return div.firstChild.getAttribute("href") === "#";
	        })) {
	            addHandle("type|href|height|width", function (elem, name, isXML) {
	                if (!isXML) {
	                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
	                }
	            });
	        }

	        // Support: IE<9
	        // Use defaultValue in place of getAttribute("value")
	        if (!support.attributes || !assert(function (div) {
	            div.innerHTML = "<input/>";
	            div.firstChild.setAttribute("value", "");
	            return div.firstChild.getAttribute("value") === "";
	        })) {
	            addHandle("value", function (elem, name, isXML) {
	                if (!isXML && elem.nodeName.toLowerCase() === "input") {
	                    return elem.defaultValue;
	                }
	            });
	        }

	        // Support: IE<9
	        // Use getAttributeNode to fetch booleans when getAttribute lies
	        if (!assert(function (div) {
	            return div.getAttribute("disabled") == null;
	        })) {
	            addHandle(booleans, function (elem, name, isXML) {
	                var val;
	                if (!isXML) {
	                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	                }
	            });
	        }

	        return Sizzle;
	    }(window);

	    jQuery.find = Sizzle;
	    jQuery.expr = Sizzle.selectors;
	    jQuery.expr[":"] = jQuery.expr.pseudos;
	    jQuery.unique = Sizzle.uniqueSort;
	    jQuery.text = Sizzle.getText;
	    jQuery.isXMLDoc = Sizzle.isXML;
	    jQuery.contains = Sizzle.contains;

	    var rneedsContext = jQuery.expr.match.needsContext;

	    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;

	    var risSimple = /^.[^:#\[\.,]*$/;

	    // Implement the identical functionality for filter and not
	    function winnow(elements, qualifier, not) {
	        if (jQuery.isFunction(qualifier)) {
	            return jQuery.grep(elements, function (elem, i) {
	                /* jshint -W018 */
	                return !!qualifier.call(elem, i, elem) !== not;
	            });
	        }

	        if (qualifier.nodeType) {
	            return jQuery.grep(elements, function (elem) {
	                return elem === qualifier !== not;
	            });
	        }

	        if (typeof qualifier === "string") {
	            if (risSimple.test(qualifier)) {
	                return jQuery.filter(qualifier, elements, not);
	            }

	            qualifier = jQuery.filter(qualifier, elements);
	        }

	        return jQuery.grep(elements, function (elem) {
	            return indexOf.call(qualifier, elem) >= 0 !== not;
	        });
	    }

	    jQuery.filter = function (expr, elems, not) {
	        var elem = elems[0];

	        if (not) {
	            expr = ":not(" + expr + ")";
	        }

	        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
	            return elem.nodeType === 1;
	        }));
	    };

	    jQuery.fn.extend({
	        find: function find(selector) {
	            var i,
	                len = this.length,
	                ret = [],
	                self = this;

	            if (typeof selector !== "string") {
	                return this.pushStack(jQuery(selector).filter(function () {
	                    for (i = 0; i < len; i++) {
	                        if (jQuery.contains(self[i], this)) {
	                            return true;
	                        }
	                    }
	                }));
	            }

	            for (i = 0; i < len; i++) {
	                jQuery.find(selector, self[i], ret);
	            }

	            // Needed because $( selector, context ) becomes $( context ).find( selector )
	            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
	            ret.selector = this.selector ? this.selector + " " + selector : selector;
	            return ret;
	        },
	        filter: function filter(selector) {
	            return this.pushStack(winnow(this, selector || [], false));
	        },
	        not: function not(selector) {
	            return this.pushStack(winnow(this, selector || [], true));
	        },
	        is: function is(selector) {
	            return !!winnow(this,

	            // If this is a positional/relative selector, check membership in the returned set
	            // so $("p:first").is("p:last") won't return true for a doc with two "p".
	            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
	        }
	    });

	    // Initialize a jQuery object


	    // A central reference to the root jQuery(document)
	    var rootjQuery,


	    // A simple way to check for HTML strings
	    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	    // Strict HTML recognition (#11290: must start with <)
	    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	        init = jQuery.fn.init = function (selector, context) {
	        var match, elem;

	        // HANDLE: $(""), $(null), $(undefined), $(false)
	        if (!selector) {
	            return this;
	        }

	        // Handle HTML strings
	        if (typeof selector === "string") {
	            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
	                // Assume that strings that start and end with <> are HTML and skip the regex check
	                match = [null, selector, null];
	            } else {
	                match = rquickExpr.exec(selector);
	            }

	            // Match html or make sure no context is specified for #id
	            if (match && (match[1] || !context)) {

	                // HANDLE: $(html) -> $(array)
	                if (match[1]) {
	                    context = context instanceof jQuery ? context[0] : context;

	                    // scripts is true for back-compat
	                    // Intentionally let the error be thrown if parseHTML is not present
	                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

	                    // HANDLE: $(html, props)
	                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
	                        for (match in context) {
	                            // Properties of context are called as methods if possible
	                            if (jQuery.isFunction(this[match])) {
	                                this[match](context[match]);

	                                // ...and otherwise set as attributes
	                            } else {
	                                this.attr(match, context[match]);
	                            }
	                        }
	                    }

	                    return this;

	                    // HANDLE: $(#id)
	                } else {
	                    elem = document.getElementById(match[2]);

	                    // Check parentNode to catch when Blackberry 4.6 returns
	                    // nodes that are no longer in the document #6963
	                    if (elem && elem.parentNode) {
	                        // Inject the element directly into the jQuery object
	                        this.length = 1;
	                        this[0] = elem;
	                    }

	                    this.context = document;
	                    this.selector = selector;
	                    return this;
	                }

	                // HANDLE: $(expr, $(...))
	            } else if (!context || context.jquery) {
	                return (context || rootjQuery).find(selector);

	                // HANDLE: $(expr, context)
	                // (which is just equivalent to: $(context).find(expr)
	            } else {
	                return this.constructor(context).find(selector);
	            }

	            // HANDLE: $(DOMElement)
	        } else if (selector.nodeType) {
	            this.context = this[0] = selector;
	            this.length = 1;
	            return this;

	            // HANDLE: $(function)
	            // Shortcut for document ready
	        } else if (jQuery.isFunction(selector)) {
	            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) :
	            // Execute immediately if ready is not present
	            selector(jQuery);
	        }

	        if (selector.selector !== undefined) {
	            this.selector = selector.selector;
	            this.context = selector.context;
	        }

	        return jQuery.makeArray(selector, this);
	    };

	    // Give the init function the jQuery prototype for later instantiation
	    init.prototype = jQuery.fn;

	    // Initialize central reference
	    rootjQuery = jQuery(document);

	    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	    // methods guaranteed to produce a unique set when starting from a unique set
	    guaranteedUnique = {
	        children: true,
	        contents: true,
	        next: true,
	        prev: true
	    };

	    jQuery.extend({
	        dir: function dir(elem, _dir, until) {
	            var matched = [],
	                truncate = until !== undefined;

	            while ((elem = elem[_dir]) && elem.nodeType !== 9) {
	                if (elem.nodeType === 1) {
	                    if (truncate && jQuery(elem).is(until)) {
	                        break;
	                    }
	                    matched.push(elem);
	                }
	            }
	            return matched;
	        },

	        sibling: function sibling(n, elem) {
	            var matched = [];

	            for (; n; n = n.nextSibling) {
	                if (n.nodeType === 1 && n !== elem) {
	                    matched.push(n);
	                }
	            }

	            return matched;
	        }
	    });

	    jQuery.fn.extend({
	        has: function has(target) {
	            var targets = jQuery(target, this),
	                l = targets.length;

	            return this.filter(function () {
	                var i = 0;
	                for (; i < l; i++) {
	                    if (jQuery.contains(this, targets[i])) {
	                        return true;
	                    }
	                }
	            });
	        },

	        closest: function closest(selectors, context) {
	            var cur,
	                i = 0,
	                l = this.length,
	                matched = [],
	                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

	            for (; i < l; i++) {
	                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
	                    // Always skip document fragments
	                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

	                    // Don't pass non-elements to Sizzle
	                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

	                        matched.push(cur);
	                        break;
	                    }
	                }
	            }

	            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
	        },

	        // Determine the position of an element within
	        // the matched set of elements
	        index: function index(elem) {

	            // No argument, return index in parent
	            if (!elem) {
	                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	            }

	            // index in selector
	            if (typeof elem === "string") {
	                return indexOf.call(jQuery(elem), this[0]);
	            }

	            // Locate the position of the desired element
	            return indexOf.call(this,

	            // If it receives a jQuery object, the first element is used
	            elem.jquery ? elem[0] : elem);
	        },

	        add: function add(selector, context) {
	            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
	        },

	        addBack: function addBack(selector) {
	            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
	        }
	    });

	    function sibling(cur, dir) {
	        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
	        return cur;
	    }

	    jQuery.each({
	        parent: function parent(elem) {
	            var parent = elem.parentNode;
	            return parent && parent.nodeType !== 11 ? parent : null;
	        },
	        parents: function parents(elem) {
	            return jQuery.dir(elem, "parentNode");
	        },
	        parentsUntil: function parentsUntil(elem, i, until) {
	            return jQuery.dir(elem, "parentNode", until);
	        },
	        next: function next(elem) {
	            return sibling(elem, "nextSibling");
	        },
	        prev: function prev(elem) {
	            return sibling(elem, "previousSibling");
	        },
	        nextAll: function nextAll(elem) {
	            return jQuery.dir(elem, "nextSibling");
	        },
	        prevAll: function prevAll(elem) {
	            return jQuery.dir(elem, "previousSibling");
	        },
	        nextUntil: function nextUntil(elem, i, until) {
	            return jQuery.dir(elem, "nextSibling", until);
	        },
	        prevUntil: function prevUntil(elem, i, until) {
	            return jQuery.dir(elem, "previousSibling", until);
	        },
	        siblings: function siblings(elem) {
	            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
	        },
	        children: function children(elem) {
	            return jQuery.sibling(elem.firstChild);
	        },
	        contents: function contents(elem) {
	            return elem.contentDocument || jQuery.merge([], elem.childNodes);
	        }
	    }, function (name, fn) {
	        jQuery.fn[name] = function (until, selector) {
	            var matched = jQuery.map(this, fn, until);

	            if (name.slice(-5) !== "Until") {
	                selector = until;
	            }

	            if (selector && typeof selector === "string") {
	                matched = jQuery.filter(selector, matched);
	            }

	            if (this.length > 1) {
	                // Remove duplicates
	                if (!guaranteedUnique[name]) {
	                    jQuery.unique(matched);
	                }

	                // Reverse order for parents* and prev-derivatives
	                if (rparentsprev.test(name)) {
	                    matched.reverse();
	                }
	            }

	            return this.pushStack(matched);
	        };
	    });
	    var rnotwhite = /\S+/g;

	    // String to Object options format cache
	    var optionsCache = {};

	    // Convert String-formatted options into Object-formatted ones and store in cache
	    function createOptions(options) {
	        var object = optionsCache[options] = {};
	        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
	            object[flag] = true;
	        });
	        return object;
	    }

	    /*
	     * Create a callback list using the following parameters:
	     *
	     *	options: an optional list of space-separated options that will change how
	     *			the callback list behaves or a more traditional option object
	     *
	     * By default a callback list will act like an event callback list and can be
	     * "fired" multiple times.
	     *
	     * Possible options:
	     *
	     *	once:			will ensure the callback list can only be fired once (like a Deferred)
	     *
	     *	memory:			will keep track of previous values and will call any callback added
	     *					after the list has been fired right away with the latest "memorized"
	     *					values (like a Deferred)
	     *
	     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	     *
	     *	stopOnFalse:	interrupt callings when a callback returns false
	     *
	     */
	    jQuery.Callbacks = function (options) {

	        // Convert options from String-formatted to Object-formatted if needed
	        // (we check in cache first)
	        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);

	        var // Last fire value (for non-forgettable lists)
	        memory,

	        // Flag to know if list was already fired
	        _fired,

	        // Flag to know if list is currently firing
	        firing,

	        // First callback to fire (used internally by add and fireWith)
	        firingStart,

	        // End of the loop when firing
	        firingLength,

	        // Index of currently firing callback (modified by remove if needed)
	        firingIndex,

	        // Actual callback list
	        list = [],

	        // Stack of fire calls for repeatable lists
	        stack = !options.once && [],

	        // Fire callbacks
	        fire = function fire(data) {
	            memory = options.memory && data;
	            _fired = true;
	            firingIndex = firingStart || 0;
	            firingStart = 0;
	            firingLength = list.length;
	            firing = true;
	            for (; list && firingIndex < firingLength; firingIndex++) {
	                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
	                    memory = false; // To prevent further calls using add
	                    break;
	                }
	            }
	            firing = false;
	            if (list) {
	                if (stack) {
	                    if (stack.length) {
	                        fire(stack.shift());
	                    }
	                } else if (memory) {
	                    list = [];
	                } else {
	                    self.disable();
	                }
	            }
	        },

	        // Actual Callbacks object
	        self = {
	            // Add a callback or a collection of callbacks to the list
	            add: function add() {
	                if (list) {
	                    // First, we save the current length
	                    var start = list.length;
	                    (function add(args) {
	                        jQuery.each(args, function (_, arg) {
	                            var type = jQuery.type(arg);
	                            if (type === "function") {
	                                if (!options.unique || !self.has(arg)) {
	                                    list.push(arg);
	                                }
	                            } else if (arg && arg.length && type !== "string") {
	                                // Inspect recursively
	                                add(arg);
	                            }
	                        });
	                    })(arguments);
	                    // Do we need to add the callbacks to the
	                    // current firing batch?
	                    if (firing) {
	                        firingLength = list.length;
	                        // With memory, if we're not firing then
	                        // we should call right away
	                    } else if (memory) {
	                        firingStart = start;
	                        fire(memory);
	                    }
	                }
	                return this;
	            },
	            // Remove a callback from the list
	            remove: function remove() {
	                if (list) {
	                    jQuery.each(arguments, function (_, arg) {
	                        var index;
	                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
	                            list.splice(index, 1);
	                            // Handle firing indexes
	                            if (firing) {
	                                if (index <= firingLength) {
	                                    firingLength--;
	                                }
	                                if (index <= firingIndex) {
	                                    firingIndex--;
	                                }
	                            }
	                        }
	                    });
	                }
	                return this;
	            },
	            // Check if a given callback is in the list.
	            // If no argument is given, return whether or not list has callbacks attached.
	            has: function has(fn) {
	                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
	            },
	            // Remove all callbacks from the list
	            empty: function empty() {
	                list = [];
	                firingLength = 0;
	                return this;
	            },
	            // Have the list do nothing anymore
	            disable: function disable() {
	                list = stack = memory = undefined;
	                return this;
	            },
	            // Is it disabled?
	            disabled: function disabled() {
	                return !list;
	            },
	            // Lock the list in its current state
	            lock: function lock() {
	                stack = undefined;
	                if (!memory) {
	                    self.disable();
	                }
	                return this;
	            },
	            // Is it locked?
	            locked: function locked() {
	                return !stack;
	            },
	            // Call all callbacks with the given context and arguments
	            fireWith: function fireWith(context, args) {
	                if (list && (!_fired || stack)) {
	                    args = args || [];
	                    args = [context, args.slice ? args.slice() : args];
	                    if (firing) {
	                        stack.push(args);
	                    } else {
	                        fire(args);
	                    }
	                }
	                return this;
	            },
	            // Call all the callbacks with the given arguments
	            fire: function fire() {
	                self.fireWith(this, arguments);
	                return this;
	            },
	            // To know if the callbacks have already been called at least once
	            fired: function fired() {
	                return !!_fired;
	            }
	        };

	        return self;
	    };

	    jQuery.extend({

	        Deferred: function Deferred(func) {
	            var tuples = [
	            // action, add listener, listener list, final state
	            ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
	                _state = "pending",
	                _promise = {
	                state: function state() {
	                    return _state;
	                },
	                always: function always() {
	                    deferred.done(arguments).fail(arguments);
	                    return this;
	                },
	                then: function then() /* fnDone, fnFail, fnProgress */{
	                    var fns = arguments;
	                    return jQuery.Deferred(function (newDefer) {
	                        jQuery.each(tuples, function (i, tuple) {
	                            var fn = jQuery.isFunction(fns[i]) && fns[i];
	                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
	                            deferred[tuple[1]](function () {
	                                var returned = fn && fn.apply(this, arguments);
	                                if (returned && jQuery.isFunction(returned.promise)) {
	                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
	                                } else {
	                                    newDefer[tuple[0] + "With"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);
	                                }
	                            });
	                        });
	                        fns = null;
	                    }).promise();
	                },
	                // Get a promise for this deferred
	                // If obj is provided, the promise aspect is added to the object
	                promise: function promise(obj) {
	                    return obj != null ? jQuery.extend(obj, _promise) : _promise;
	                }
	            },
	                deferred = {};

	            // Keep pipe for back-compat
	            _promise.pipe = _promise.then;

	            // Add list-specific methods
	            jQuery.each(tuples, function (i, tuple) {
	                var list = tuple[2],
	                    stateString = tuple[3];

	                // promise[ done | fail | progress ] = list.add
	                _promise[tuple[1]] = list.add;

	                // Handle state
	                if (stateString) {
	                    list.add(function () {
	                        // state = [ resolved | rejected ]
	                        _state = stateString;

	                        // [ reject_list | resolve_list ].disable; progress_list.lock
	                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
	                }

	                // deferred[ resolve | reject | notify ]
	                deferred[tuple[0]] = function () {
	                    deferred[tuple[0] + "With"](this === deferred ? _promise : this, arguments);
	                    return this;
	                };
	                deferred[tuple[0] + "With"] = list.fireWith;
	            });

	            // Make the deferred a promise
	            _promise.promise(deferred);

	            // Call given func if any
	            if (func) {
	                func.call(deferred, deferred);
	            }

	            // All done!
	            return deferred;
	        },

	        // Deferred helper
	        when: function when(subordinate /* , ..., subordinateN */) {
	            var i = 0,
	                resolveValues = _slice.call(arguments),
	                length = resolveValues.length,


	            // the count of uncompleted subordinates
	            remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


	            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
	            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


	            // Update function for both resolve and progress values
	            updateFunc = function updateFunc(i, contexts, values) {
	                return function (value) {
	                    contexts[i] = this;
	                    values[i] = arguments.length > 1 ? _slice.call(arguments) : value;
	                    if (values === progressValues) {
	                        deferred.notifyWith(contexts, values);
	                    } else if (! --remaining) {
	                        deferred.resolveWith(contexts, values);
	                    }
	                };
	            },
	                progressValues,
	                progressContexts,
	                resolveContexts;

	            // add listeners to Deferred subordinates; treat others as resolved
	            if (length > 1) {
	                progressValues = new Array(length);
	                progressContexts = new Array(length);
	                resolveContexts = new Array(length);
	                for (; i < length; i++) {
	                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
	                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
	                    } else {
	                        --remaining;
	                    }
	                }
	            }

	            // if we're not waiting on anything, resolve the master
	            if (!remaining) {
	                deferred.resolveWith(resolveContexts, resolveValues);
	            }

	            return deferred.promise();
	        }
	    });

	    // The deferred used on DOM ready
	    var readyList;

	    jQuery.fn.ready = function (fn) {
	        // Add the callback
	        jQuery.ready.promise().done(fn);

	        return this;
	    };

	    jQuery.extend({
	        // Is the DOM ready to be used? Set to true once it occurs.
	        isReady: false,

	        // A counter to track how many items to wait for before
	        // the ready event fires. See #6781
	        readyWait: 1,

	        // Hold (or release) the ready event
	        holdReady: function holdReady(hold) {
	            if (hold) {
	                jQuery.readyWait++;
	            } else {
	                jQuery.ready(true);
	            }
	        },

	        // Handle when the DOM is ready
	        ready: function ready(wait) {

	            // Abort if there are pending holds or we're already ready
	            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
	                return;
	            }

	            // Remember that the DOM is ready
	            jQuery.isReady = true;

	            // If a normal DOM Ready event fired, decrement, and wait if need be
	            if (wait !== true && --jQuery.readyWait > 0) {
	                return;
	            }

	            // If there are functions bound, to execute
	            readyList.resolveWith(document, [jQuery]);

	            // Trigger any bound ready events
	            if (jQuery.fn.trigger) {
	                jQuery(document).trigger("ready").off("ready");
	            }
	        }
	    });

	    /**
	     * The ready event handler and self cleanup method
	     */
	    function completed() {
	        document.removeEventListener("DOMContentLoaded", completed, false);
	        window.removeEventListener("load", completed, false);
	        jQuery.ready();
	    }

	    jQuery.ready.promise = function (obj) {
	        if (!readyList) {

	            readyList = jQuery.Deferred();

	            // Catch cases where $(document).ready() is called after the browser event has already occurred.
	            // we once tried to use readyState "interactive" here, but it caused issues like the one
	            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
	            if (document.readyState === "complete") {
	                // Handle it asynchronously to allow scripts the opportunity to delay ready
	                setTimeout(jQuery.ready);
	            } else {

	                // Use the handy event callback
	                document.addEventListener("DOMContentLoaded", completed, false);

	                // A fallback to window.onload, that will always work
	                window.addEventListener("load", completed, false);
	            }
	        }
	        return readyList.promise(obj);
	    };

	    // Kick off the DOM ready check even if the user does not
	    jQuery.ready.promise();

	    // Multifunctional method to get and set values of a collection
	    // The value/s can optionally be executed if it's a function
	    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
	        var i = 0,
	            len = elems.length,
	            bulk = key == null;

	        // Sets many values
	        if (jQuery.type(key) === "object") {
	            chainable = true;
	            for (i in key) {
	                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
	            }

	            // Sets one value
	        } else if (value !== undefined) {
	            chainable = true;

	            if (!jQuery.isFunction(value)) {
	                raw = true;
	            }

	            if (bulk) {
	                // Bulk operations run against the entire set
	                if (raw) {
	                    fn.call(elems, value);
	                    fn = null;

	                    // ...except when executing function values
	                } else {
	                    bulk = fn;
	                    fn = function fn(elem, key, value) {
	                        return bulk.call(jQuery(elem), value);
	                    };
	                }
	            }

	            if (fn) {
	                for (; i < len; i++) {
	                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
	                }
	            }
	        }

	        return chainable ? elems :

	        // Gets
	        bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	    };

	    /**
	     * Determines whether an object can have data
	     */
	    jQuery.acceptData = function (owner) {
	        // Accepts only:
	        //  - Node
	        //    - Node.ELEMENT_NODE
	        //    - Node.DOCUMENT_NODE
	        //  - Object
	        //    - Any
	        /* jshint -W018 */
	        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	    };

	    function Data() {
	        // Support: Android < 4,
	        // Old WebKit does not have Object.preventExtensions/freeze method,
	        // return new empty object instead with no [[set]] accessor
	        Object.defineProperty(this.cache = {}, 0, {
	            get: function get() {
	                return {};
	            }
	        });

	        this.expando = jQuery.expando + Math.random();
	    }

	    Data.uid = 1;
	    Data.accepts = jQuery.acceptData;

	    Data.prototype = {
	        key: function key(owner) {
	            // We can accept data for non-element nodes in modern browsers,
	            // but we should not, see #8335.
	            // Always return the key for a frozen object.
	            if (!Data.accepts(owner)) {
	                return 0;
	            }

	            var descriptor = {},

	            // Check if the owner object already has a cache key
	            unlock = owner[this.expando];

	            // If not, create one
	            if (!unlock) {
	                unlock = Data.uid++;

	                // Secure it in a non-enumerable, non-writable property
	                try {
	                    descriptor[this.expando] = {
	                        value: unlock
	                    };
	                    Object.defineProperties(owner, descriptor);

	                    // Support: Android < 4
	                    // Fallback to a less secure definition
	                } catch (e) {
	                    descriptor[this.expando] = unlock;
	                    jQuery.extend(owner, descriptor);
	                }
	            }

	            // Ensure the cache object
	            if (!this.cache[unlock]) {
	                this.cache[unlock] = {};
	            }

	            return unlock;
	        },
	        set: function set(owner, data, value) {
	            var prop,

	            // There may be an unlock assigned to this node,
	            // if there is no entry for this "owner", create one inline
	            // and set the unlock as though an owner entry had always existed
	            unlock = this.key(owner),
	                cache = this.cache[unlock];

	            // Handle: [ owner, key, value ] args
	            if (typeof data === "string") {
	                cache[data] = value;

	                // Handle: [ owner, { properties } ] args
	            } else {
	                // Fresh assignments by object are shallow copied
	                if (jQuery.isEmptyObject(cache)) {
	                    jQuery.extend(this.cache[unlock], data);
	                    // Otherwise, copy the properties one-by-one to the cache object
	                } else {
	                    for (prop in data) {
	                        cache[prop] = data[prop];
	                    }
	                }
	            }
	            return cache;
	        },
	        get: function get(owner, key) {
	            // Either a valid cache is found, or will be created.
	            // New caches will be created and the unlock returned,
	            // allowing direct access to the newly created
	            // empty data object. A valid owner object must be provided.
	            var cache = this.cache[this.key(owner)];

	            return key === undefined ? cache : cache[key];
	        },
	        access: function access(owner, key, value) {
	            var stored;
	            // In cases where either:
	            //
	            //   1. No key was specified
	            //   2. A string key was specified, but no value provided
	            //
	            // Take the "read" path and allow the get method to determine
	            // which value to return, respectively either:
	            //
	            //   1. The entire cache object
	            //   2. The data stored at the key
	            //
	            if (key === undefined || key && typeof key === "string" && value === undefined) {

	                stored = this.get(owner, key);

	                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
	            }

	            // [*]When the key is not a string, or both a key and value
	            // are specified, set or extend (existing objects) with either:
	            //
	            //   1. An object of properties
	            //   2. A key and value
	            //
	            this.set(owner, key, value);

	            // Since the "set" path can have two possible entry points
	            // return the expected data based on which path was taken[*]
	            return value !== undefined ? value : key;
	        },
	        remove: function remove(owner, key) {
	            var i,
	                name,
	                camel,
	                unlock = this.key(owner),
	                cache = this.cache[unlock];

	            if (key === undefined) {
	                this.cache[unlock] = {};
	            } else {
	                // Support array or space separated string of keys
	                if (jQuery.isArray(key)) {
	                    // If "name" is an array of keys...
	                    // When data is initially created, via ("key", "val") signature,
	                    // keys will be converted to camelCase.
	                    // Since there is no way to tell _how_ a key was added, remove
	                    // both plain key and camelCase key. #12786
	                    // This will only penalize the array argument path.
	                    name = key.concat(key.map(jQuery.camelCase));
	                } else {
	                    camel = jQuery.camelCase(key);
	                    // Try the string as a key before any manipulation
	                    if (key in cache) {
	                        name = [key, camel];
	                    } else {
	                        // If a key with the spaces exists, use it.
	                        // Otherwise, create an array by matching non-whitespace
	                        name = camel;
	                        name = name in cache ? [name] : name.match(rnotwhite) || [];
	                    }
	                }

	                i = name.length;
	                while (i--) {
	                    delete cache[name[i]];
	                }
	            }
	        },
	        hasData: function hasData(owner) {
	            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
	        },
	        discard: function discard(owner) {
	            if (owner[this.expando]) {
	                delete this.cache[owner[this.expando]];
	            }
	        }
	    };
	    var data_priv = new Data();

	    var data_user = new Data();

	    /*
	     Implementation Summary
	       1. Enforce API surface and semantic compatibility with 1.9.x branch
	     2. Improve the module's maintainability by reducing the storage
	     paths to a single mechanism.
	     3. Use the same single mechanism to support "private" and "user" data.
	     4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	     5. Avoid exposing implementation details on user objects (eg. expando properties)
	     6. Provide a clear path for implementation upgrade to WeakMap in 2014
	     */
	    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	        rmultiDash = /([A-Z])/g;

	    function dataAttr(elem, key, data) {
	        var name;

	        // If nothing was found internally, try to fetch any
	        // data from the HTML5 data-* attribute
	        if (data === undefined && elem.nodeType === 1) {
	            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
	            data = elem.getAttribute(name);

	            if (typeof data === "string") {
	                try {
	                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null :
	                    // Only convert to a number if it doesn't change the string
	                    +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
	                } catch (e) {}

	                // Make sure we set the data so it isn't changed later
	                data_user.set(elem, key, data);
	            } else {
	                data = undefined;
	            }
	        }
	        return data;
	    }

	    jQuery.extend({
	        hasData: function hasData(elem) {
	            return data_user.hasData(elem) || data_priv.hasData(elem);
	        },

	        data: function data(elem, name, _data) {
	            return data_user.access(elem, name, _data);
	        },

	        removeData: function removeData(elem, name) {
	            data_user.remove(elem, name);
	        },

	        // TODO: Now that all calls to _data and _removeData have been replaced
	        // with direct calls to data_priv methods, these can be deprecated.
	        _data: function _data(elem, name, data) {
	            return data_priv.access(elem, name, data);
	        },

	        _removeData: function _removeData(elem, name) {
	            data_priv.remove(elem, name);
	        }
	    });

	    jQuery.fn.extend({
	        data: function data(key, value) {
	            var i,
	                name,
	                data,
	                elem = this[0],
	                attrs = elem && elem.attributes;

	            // Gets all values
	            if (key === undefined) {
	                if (this.length) {
	                    data = data_user.get(elem);

	                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
	                        i = attrs.length;
	                        while (i--) {
	                            name = attrs[i].name;

	                            if (name.indexOf("data-") === 0) {
	                                name = jQuery.camelCase(name.slice(5));
	                                dataAttr(elem, name, data[name]);
	                            }
	                        }
	                        data_priv.set(elem, "hasDataAttrs", true);
	                    }
	                }

	                return data;
	            }

	            // Sets multiple values
	            if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
	                return this.each(function () {
	                    data_user.set(this, key);
	                });
	            }

	            return access(this, function (value) {
	                var data,
	                    camelKey = jQuery.camelCase(key);

	                // The calling jQuery object (element matches) is not empty
	                // (and therefore has an element appears at this[ 0 ]) and the
	                // `value` parameter was not undefined. An empty jQuery object
	                // will result in `undefined` for elem = this[ 0 ] which will
	                // throw an exception if an attempt to read a data cache is made.
	                if (elem && value === undefined) {
	                    // Attempt to get data from the cache
	                    // with the key as-is
	                    data = data_user.get(elem, key);
	                    if (data !== undefined) {
	                        return data;
	                    }

	                    // Attempt to get data from the cache
	                    // with the key camelized
	                    data = data_user.get(elem, camelKey);
	                    if (data !== undefined) {
	                        return data;
	                    }

	                    // Attempt to "discover" the data in
	                    // HTML5 custom data-* attrs
	                    data = dataAttr(elem, camelKey, undefined);
	                    if (data !== undefined) {
	                        return data;
	                    }

	                    // We tried really hard, but the data doesn't exist.
	                    return;
	                }

	                // Set the data...
	                this.each(function () {
	                    // First, attempt to store a copy or reference of any
	                    // data that might've been store with a camelCased key.
	                    var data = data_user.get(this, camelKey);

	                    // For HTML5 data-* attribute interop, we have to
	                    // store property names with dashes in a camelCase form.
	                    // This might not apply to all properties...*
	                    data_user.set(this, camelKey, value);

	                    // *... In the case of properties that might _actually_
	                    // have dashes, we need to also store a copy of that
	                    // unchanged property.
	                    if (key.indexOf("-") !== -1 && data !== undefined) {
	                        data_user.set(this, key, value);
	                    }
	                });
	            }, null, value, arguments.length > 1, null, true);
	        },

	        removeData: function removeData(key) {
	            return this.each(function () {
	                data_user.remove(this, key);
	            });
	        }
	    });

	    jQuery.extend({
	        queue: function queue(elem, type, data) {
	            var queue;

	            if (elem) {
	                type = (type || "fx") + "queue";
	                queue = data_priv.get(elem, type);

	                // Speed up dequeue by getting out quickly if this is just a lookup
	                if (data) {
	                    if (!queue || jQuery.isArray(data)) {
	                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
	                    } else {
	                        queue.push(data);
	                    }
	                }
	                return queue || [];
	            }
	        },

	        dequeue: function dequeue(elem, type) {
	            type = type || "fx";

	            var queue = jQuery.queue(elem, type),
	                startLength = queue.length,
	                fn = queue.shift(),
	                hooks = jQuery._queueHooks(elem, type),
	                next = function next() {
	                jQuery.dequeue(elem, type);
	            };

	            // If the fx queue is dequeued, always remove the progress sentinel
	            if (fn === "inprogress") {
	                fn = queue.shift();
	                startLength--;
	            }

	            if (fn) {

	                // Add a progress sentinel to prevent the fx queue from being
	                // automatically dequeued
	                if (type === "fx") {
	                    queue.unshift("inprogress");
	                }

	                // clear up the last queue stop function
	                delete hooks.stop;
	                fn.call(elem, next, hooks);
	            }

	            if (!startLength && hooks) {
	                hooks.empty.fire();
	            }
	        },

	        // not intended for public consumption - generates a queueHooks object, or returns the current one
	        _queueHooks: function _queueHooks(elem, type) {
	            var key = type + "queueHooks";
	            return data_priv.get(elem, key) || data_priv.access(elem, key, {
	                empty: jQuery.Callbacks("once memory").add(function () {
	                    data_priv.remove(elem, [type + "queue", key]);
	                })
	            });
	        }
	    });

	    jQuery.fn.extend({
	        queue: function queue(type, data) {
	            var setter = 2;

	            if (typeof type !== "string") {
	                data = type;
	                type = "fx";
	                setter--;
	            }

	            if (arguments.length < setter) {
	                return jQuery.queue(this[0], type);
	            }

	            return data === undefined ? this : this.each(function () {
	                var queue = jQuery.queue(this, type, data);

	                // ensure a hooks for this queue
	                jQuery._queueHooks(this, type);

	                if (type === "fx" && queue[0] !== "inprogress") {
	                    jQuery.dequeue(this, type);
	                }
	            });
	        },
	        dequeue: function dequeue(type) {
	            return this.each(function () {
	                jQuery.dequeue(this, type);
	            });
	        },
	        clearQueue: function clearQueue(type) {
	            return this.queue(type || "fx", []);
	        },
	        // Get a promise resolved when queues of a certain type
	        // are emptied (fx is the type by default)
	        promise: function promise(type, obj) {
	            var tmp,
	                count = 1,
	                defer = jQuery.Deferred(),
	                elements = this,
	                i = this.length,
	                resolve = function resolve() {
	                if (! --count) {
	                    defer.resolveWith(elements, [elements]);
	                }
	            };

	            if (typeof type !== "string") {
	                obj = type;
	                type = undefined;
	            }
	            type = type || "fx";

	            while (i--) {
	                tmp = data_priv.get(elements[i], type + "queueHooks");
	                if (tmp && tmp.empty) {
	                    count++;
	                    tmp.empty.add(resolve);
	                }
	            }
	            resolve();
	            return defer.promise(obj);
	        }
	    });
	    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	    var cssExpand = ["Top", "Right", "Bottom", "Left"];

	    var isHidden = function isHidden(elem, el) {
	        // isHidden might be called from jQuery#filter function;
	        // in that case, element will be second argument
	        elem = el || elem;
	        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	    };

	    var rcheckableType = /^(?:checkbox|radio)$/i;

	    (function () {
	        var fragment = document.createDocumentFragment(),
	            div = fragment.appendChild(document.createElement("div"));

	        // #11217 - WebKit loses check when the name is after the checked attribute
	        div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	        // old WebKit doesn't clone checked state correctly in fragments
	        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

	        // Make sure textarea (and checkbox) defaultValue is properly cloned
	        // Support: IE9-IE11+
	        div.innerHTML = "<textarea>x</textarea>";
	        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	    })();
	    var strundefined =  true ? "undefined" : _typeof(undefined);

	    support.focusinBubbles = "onfocusin" in window;

	    var rkeyEvent = /^key/,
	        rmouseEvent = /^(?:mouse|contextmenu)|click/,
	        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	    function returnTrue() {
	        return true;
	    }

	    function returnFalse() {
	        return false;
	    }

	    function safeActiveElement() {
	        try {
	            return document.activeElement;
	        } catch (err) {}
	    }

	    /*
	     * Helper functions for managing events -- not part of the public interface.
	     * Props to Dean Edwards' addEvent library for many of the ideas.
	     */
	    jQuery.event = {

	        global: {},

	        add: function add(elem, types, handler, data, selector) {

	            var handleObjIn,
	                eventHandle,
	                tmp,
	                events,
	                t,
	                handleObj,
	                special,
	                handlers,
	                type,
	                namespaces,
	                origType,
	                elemData = data_priv.get(elem);

	            // Don't attach events to noData or text/comment nodes (but allow plain objects)
	            if (!elemData) {
	                return;
	            }

	            // Caller can pass in an object of custom data in lieu of the handler
	            if (handler.handler) {
	                handleObjIn = handler;
	                handler = handleObjIn.handler;
	                selector = handleObjIn.selector;
	            }

	            // Make sure that the handler has a unique ID, used to find/remove it later
	            if (!handler.guid) {
	                handler.guid = jQuery.guid++;
	            }

	            // Init the element's event structure and main handler, if this is the first
	            if (!(events = elemData.events)) {
	                events = elemData.events = {};
	            }
	            if (!(eventHandle = elemData.handle)) {
	                eventHandle = elemData.handle = function (e) {
	                    // Discard the second event of a jQuery.event.trigger() and
	                    // when an event is called after a page has unloaded
	                    return (typeof jQuery === "undefined" ? "undefined" : _typeof(jQuery)) !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
	                };
	            }

	            // Handle multiple events separated by a space
	            types = (types || "").match(rnotwhite) || [""];
	            t = types.length;
	            while (t--) {
	                tmp = rtypenamespace.exec(types[t]) || [];
	                type = origType = tmp[1];
	                namespaces = (tmp[2] || "").split(".").sort();

	                // There *must* be a type, no attaching namespace-only handlers
	                if (!type) {
	                    continue;
	                }

	                // If event changes its type, use the special event handlers for the changed type
	                special = jQuery.event.special[type] || {};

	                // If selector defined, determine special event api type, otherwise given type
	                type = (selector ? special.delegateType : special.bindType) || type;

	                // Update special based on newly reset type
	                special = jQuery.event.special[type] || {};

	                // handleObj is passed to all event handlers
	                handleObj = jQuery.extend({
	                    type: type,
	                    origType: origType,
	                    data: data,
	                    handler: handler,
	                    guid: handler.guid,
	                    selector: selector,
	                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
	                    namespace: namespaces.join(".")
	                }, handleObjIn);

	                // Init the event handler queue if we're the first
	                if (!(handlers = events[type])) {
	                    handlers = events[type] = [];
	                    handlers.delegateCount = 0;

	                    // Only use addEventListener if the special events handler returns false
	                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
	                        if (elem.addEventListener) {
	                            elem.addEventListener(type, eventHandle, false);
	                        }
	                    }
	                }

	                if (special.add) {
	                    special.add.call(elem, handleObj);

	                    if (!handleObj.handler.guid) {
	                        handleObj.handler.guid = handler.guid;
	                    }
	                }

	                // Add to the element's handler list, delegates in front
	                if (selector) {
	                    handlers.splice(handlers.delegateCount++, 0, handleObj);
	                } else {
	                    handlers.push(handleObj);
	                }

	                // Keep track of which events have ever been used, for event optimization
	                jQuery.event.global[type] = true;
	            }
	        },

	        // Detach an event or set of events from an element
	        remove: function remove(elem, types, handler, selector, mappedTypes) {

	            var j,
	                origCount,
	                tmp,
	                events,
	                t,
	                handleObj,
	                special,
	                handlers,
	                type,
	                namespaces,
	                origType,
	                elemData = data_priv.hasData(elem) && data_priv.get(elem);

	            if (!elemData || !(events = elemData.events)) {
	                return;
	            }

	            // Once for each type.namespace in types; type may be omitted
	            types = (types || "").match(rnotwhite) || [""];
	            t = types.length;
	            while (t--) {
	                tmp = rtypenamespace.exec(types[t]) || [];
	                type = origType = tmp[1];
	                namespaces = (tmp[2] || "").split(".").sort();

	                // Unbind all events (on this namespace, if provided) for the element
	                if (!type) {
	                    for (type in events) {
	                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
	                    }
	                    continue;
	                }

	                special = jQuery.event.special[type] || {};
	                type = (selector ? special.delegateType : special.bindType) || type;
	                handlers = events[type] || [];
	                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

	                // Remove matching events
	                origCount = j = handlers.length;
	                while (j--) {
	                    handleObj = handlers[j];

	                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
	                        handlers.splice(j, 1);

	                        if (handleObj.selector) {
	                            handlers.delegateCount--;
	                        }
	                        if (special.remove) {
	                            special.remove.call(elem, handleObj);
	                        }
	                    }
	                }

	                // Remove generic event handler if we removed something and no more handlers exist
	                // (avoids potential for endless recursion during removal of special event handlers)
	                if (origCount && !handlers.length) {
	                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
	                        jQuery.removeEvent(elem, type, elemData.handle);
	                    }

	                    delete events[type];
	                }
	            }

	            // Remove the expando if it's no longer used
	            if (jQuery.isEmptyObject(events)) {
	                delete elemData.handle;
	                data_priv.remove(elem, "events");
	            }
	        },

	        trigger: function trigger(event, data, elem, onlyHandlers) {

	            var i,
	                cur,
	                tmp,
	                bubbleType,
	                ontype,
	                handle,
	                special,
	                eventPath = [elem || document],
	                type = hasOwn.call(event, "type") ? event.type : event,
	                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

	            cur = tmp = elem = elem || document;

	            // Don't do events on text and comment nodes
	            if (elem.nodeType === 3 || elem.nodeType === 8) {
	                return;
	            }

	            // focus/blur morphs to focusin/out; ensure we're not firing them right now
	            if (rfocusMorph.test(type + jQuery.event.triggered)) {
	                return;
	            }

	            if (type.indexOf(".") >= 0) {
	                // Namespaced trigger; create a regexp to match event type in handle()
	                namespaces = type.split(".");
	                type = namespaces.shift();
	                namespaces.sort();
	            }
	            ontype = type.indexOf(":") < 0 && "on" + type;

	            // Caller can pass in a jQuery.Event object, Object, or just an event type string
	            event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);

	            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
	            event.isTrigger = onlyHandlers ? 2 : 3;
	            event.namespace = namespaces.join(".");
	            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

	            // Clean up the event in case it is being reused
	            event.result = undefined;
	            if (!event.target) {
	                event.target = elem;
	            }

	            // Clone any incoming data and prepend the event, creating the handler arg list
	            data = data == null ? [event] : jQuery.makeArray(data, [event]);

	            // Allow special events to draw outside the lines
	            special = jQuery.event.special[type] || {};
	            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
	                return;
	            }

	            // Determine event propagation path in advance, per W3C events spec (#9951)
	            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
	            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

	                bubbleType = special.delegateType || type;
	                if (!rfocusMorph.test(bubbleType + type)) {
	                    cur = cur.parentNode;
	                }
	                for (; cur; cur = cur.parentNode) {
	                    eventPath.push(cur);
	                    tmp = cur;
	                }

	                // Only add window if we got to document (e.g., not plain obj or detached DOM)
	                if (tmp === (elem.ownerDocument || document)) {
	                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
	                }
	            }

	            // Fire handlers on the event path
	            i = 0;
	            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

	                event.type = i > 1 ? bubbleType : special.bindType || type;

	                // jQuery handler
	                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
	                if (handle) {
	                    handle.apply(cur, data);
	                }

	                // Native handler
	                handle = ontype && cur[ontype];
	                if (handle && handle.apply && jQuery.acceptData(cur)) {
	                    event.result = handle.apply(cur, data);
	                    if (event.result === false) {
	                        event.preventDefault();
	                    }
	                }
	            }
	            event.type = type;

	            // If nobody prevented the default action, do it now
	            if (!onlyHandlers && !event.isDefaultPrevented()) {

	                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {

	                    // Call a native DOM method on the target with the same name name as the event.
	                    // Don't do default actions on window, that's where global variables be (#6170)
	                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

	                        // Don't re-trigger an onFOO event when we call its FOO() method
	                        tmp = elem[ontype];

	                        if (tmp) {
	                            elem[ontype] = null;
	                        }

	                        // Prevent re-triggering of the same event, since we already bubbled it above
	                        jQuery.event.triggered = type;
	                        elem[type]();
	                        jQuery.event.triggered = undefined;

	                        if (tmp) {
	                            elem[ontype] = tmp;
	                        }
	                    }
	                }
	            }

	            return event.result;
	        },

	        dispatch: function dispatch(event) {

	            // Make a writable jQuery.Event from the native event object
	            event = jQuery.event.fix(event);

	            var i,
	                j,
	                ret,
	                matched,
	                handleObj,
	                handlerQueue = [],
	                args = _slice.call(arguments),
	                handlers = (data_priv.get(this, "events") || {})[event.type] || [],
	                special = jQuery.event.special[event.type] || {};

	            // Use the fix-ed jQuery.Event rather than the (read-only) native event
	            args[0] = event;
	            event.delegateTarget = this;

	            // Call the preDispatch hook for the mapped type, and let it bail if desired
	            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
	                return;
	            }

	            // Determine handlers
	            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

	            // Run delegates first; they may want to stop propagation beneath us
	            i = 0;
	            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
	                event.currentTarget = matched.elem;

	                j = 0;
	                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

	                    // Triggered event must either 1) have no namespace, or
	                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
	                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

	                        event.handleObj = handleObj;
	                        event.data = handleObj.data;

	                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

	                        if (ret !== undefined) {
	                            if ((event.result = ret) === false) {
	                                event.preventDefault();
	                                event.stopPropagation();
	                            }
	                        }
	                    }
	                }
	            }

	            // Call the postDispatch hook for the mapped type
	            if (special.postDispatch) {
	                special.postDispatch.call(this, event);
	            }

	            return event.result;
	        },

	        handlers: function handlers(event, _handlers) {
	            var i,
	                matches,
	                sel,
	                handleObj,
	                handlerQueue = [],
	                delegateCount = _handlers.delegateCount,
	                cur = event.target;

	            // Find delegate handlers
	            // Black-hole SVG <use> instance trees (#13180)
	            // Avoid non-left-click bubbling in Firefox (#3861)
	            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

	                for (; cur !== this; cur = cur.parentNode || this) {

	                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
	                    if (cur.disabled !== true || event.type !== "click") {
	                        matches = [];
	                        for (i = 0; i < delegateCount; i++) {
	                            handleObj = _handlers[i];

	                            // Don't conflict with Object.prototype properties (#13203)
	                            sel = handleObj.selector + " ";

	                            if (matches[sel] === undefined) {
	                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
	                            }
	                            if (matches[sel]) {
	                                matches.push(handleObj);
	                            }
	                        }
	                        if (matches.length) {
	                            handlerQueue.push({
	                                elem: cur,
	                                handlers: matches
	                            });
	                        }
	                    }
	                }
	            }

	            // Add the remaining (directly-bound) handlers
	            if (delegateCount < _handlers.length) {
	                handlerQueue.push({
	                    elem: this,
	                    handlers: _handlers.slice(delegateCount)
	                });
	            }

	            return handlerQueue;
	        },

	        // Includes some event props shared by KeyEvent and MouseEvent
	        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	        fixHooks: {},

	        keyHooks: {
	            props: "char charCode key keyCode".split(" "),
	            filter: function filter(event, original) {

	                // Add which for key events
	                if (event.which == null) {
	                    event.which = original.charCode != null ? original.charCode : original.keyCode;
	                }

	                return event;
	            }
	        },

	        mouseHooks: {
	            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
	            filter: function filter(event, original) {
	                var eventDoc,
	                    doc,
	                    body,
	                    button = original.button;

	                // Calculate pageX/Y if missing and clientX/Y available
	                if (event.pageX == null && original.clientX != null) {
	                    eventDoc = event.target.ownerDocument || document;
	                    doc = eventDoc.documentElement;
	                    body = eventDoc.body;

	                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
	                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
	                }

	                // Add which for click: 1 === left; 2 === middle; 3 === right
	                // Note: button is not normalized, so don't use it
	                if (!event.which && button !== undefined) {
	                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	                }

	                return event;
	            }
	        },

	        fix: function fix(event) {
	            if (event[jQuery.expando]) {
	                return event;
	            }

	            // Create a writable copy of the event object and normalize some properties
	            var i,
	                prop,
	                copy,
	                type = event.type,
	                originalEvent = event,
	                fixHook = this.fixHooks[type];

	            if (!fixHook) {
	                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
	            }
	            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

	            event = new jQuery.Event(originalEvent);

	            i = copy.length;
	            while (i--) {
	                prop = copy[i];
	                event[prop] = originalEvent[prop];
	            }

	            // Support: Cordova 2.5 (WebKit) (#13255)
	            // All events should have a target; Cordova deviceready doesn't
	            if (!event.target) {
	                event.target = document;
	            }

	            // Support: Safari 6.0+, Chrome < 28
	            // Target should not be a text node (#504, #13143)
	            if (event.target.nodeType === 3) {
	                event.target = event.target.parentNode;
	            }

	            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
	        },

	        special: {
	            load: {
	                // Prevent triggered image.load events from bubbling to window.load
	                noBubble: true
	            },
	            focus: {
	                // Fire native event if possible so blur/focus sequence is correct
	                trigger: function trigger() {
	                    if (this !== safeActiveElement() && this.focus) {
	                        this.focus();
	                        return false;
	                    }
	                },
	                delegateType: "focusin"
	            },
	            blur: {
	                trigger: function trigger() {
	                    if (this === safeActiveElement() && this.blur) {
	                        this.blur();
	                        return false;
	                    }
	                },
	                delegateType: "focusout"
	            },
	            click: {
	                // For checkbox, fire native event so checked state will be right
	                trigger: function trigger() {
	                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
	                        this.click();
	                        return false;
	                    }
	                },

	                // For cross-browser consistency, don't fire native .click() on links
	                _default: function _default(event) {
	                    return jQuery.nodeName(event.target, "a");
	                }
	            },

	            beforeunload: {
	                postDispatch: function postDispatch(event) {

	                    // Support: Firefox 20+
	                    // Firefox doesn't alert if the returnValue field is not set.
	                    if (event.result !== undefined) {
	                        event.originalEvent.returnValue = event.result;
	                    }
	                }
	            }
	        },

	        simulate: function simulate(type, elem, event, bubble) {
	            // Piggyback on a donor event to simulate a different one.
	            // Fake originalEvent to avoid donor's stopPropagation, but if the
	            // simulated event prevents default then we do the same on the donor.
	            var e = jQuery.extend(new jQuery.Event(), event, {
	                type: type,
	                isSimulated: true,
	                originalEvent: {}
	            });
	            if (bubble) {
	                jQuery.event.trigger(e, null, elem);
	            } else {
	                jQuery.event.dispatch.call(elem, e);
	            }
	            if (e.isDefaultPrevented()) {
	                event.preventDefault();
	            }
	        }
	    };

	    jQuery.removeEvent = function (elem, type, handle) {
	        if (elem.removeEventListener) {
	            elem.removeEventListener(type, handle, false);
	        }
	    };

	    jQuery.Event = function (src, props) {
	        // Allow instantiation without the 'new' keyword
	        if (!(this instanceof jQuery.Event)) {
	            return new jQuery.Event(src, props);
	        }

	        // Event object
	        if (src && src.type) {
	            this.originalEvent = src;
	            this.type = src.type;

	            // Events bubbling up the document may have been marked as prevented
	            // by a handler lower down the tree; reflect the correct value.
	            this.isDefaultPrevented = src.defaultPrevented ||
	            // Support: Android < 4.0
	            src.defaultPrevented === undefined && src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;

	            // Event type
	        } else {
	            this.type = src;
	        }

	        // Put explicitly provided properties onto the event object
	        if (props) {
	            jQuery.extend(this, props);
	        }

	        // Create a timestamp if incoming event doesn't have one
	        this.timeStamp = src && src.timeStamp || jQuery.now();

	        // Mark it as fixed
	        this[jQuery.expando] = true;
	    };

	    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	    jQuery.Event.prototype = {
	        isDefaultPrevented: returnFalse,
	        isPropagationStopped: returnFalse,
	        isImmediatePropagationStopped: returnFalse,

	        preventDefault: function preventDefault() {
	            var e = this.originalEvent;

	            this.isDefaultPrevented = returnTrue;

	            if (e && e.preventDefault) {
	                e.preventDefault();
	            }
	        },
	        stopPropagation: function stopPropagation() {
	            var e = this.originalEvent;

	            this.isPropagationStopped = returnTrue;

	            if (e && e.stopPropagation) {
	                e.stopPropagation();
	            }
	        },
	        stopImmediatePropagation: function stopImmediatePropagation() {
	            this.isImmediatePropagationStopped = returnTrue;
	            this.stopPropagation();
	        }
	    };

	    // Create mouseenter/leave events using mouseover/out and event-time checks
	    // Support: Chrome 15+
	    jQuery.each({
	        mouseenter: "mouseover",
	        mouseleave: "mouseout"
	    }, function (orig, fix) {
	        jQuery.event.special[orig] = {
	            delegateType: fix,
	            bindType: fix,

	            handle: function handle(event) {
	                var ret,
	                    target = this,
	                    related = event.relatedTarget,
	                    handleObj = event.handleObj;

	                // For mousenter/leave call the handler if related is outside the target.
	                // NB: No relatedTarget if the mouse left/entered the browser window
	                if (!related || related !== target && !jQuery.contains(target, related)) {
	                    event.type = handleObj.origType;
	                    ret = handleObj.handler.apply(this, arguments);
	                    event.type = fix;
	                }
	                return ret;
	            }
	        };
	    });

	    // Create "bubbling" focus and blur events
	    // Support: Firefox, Chrome, Safari
	    if (!support.focusinBubbles) {
	        jQuery.each({
	            focus: "focusin",
	            blur: "focusout"
	        }, function (orig, fix) {

	            // Attach a single capturing handler on the document while someone wants focusin/focusout
	            var handler = function handler(event) {
	                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
	            };

	            jQuery.event.special[fix] = {
	                setup: function setup() {
	                    var doc = this.ownerDocument || this,
	                        attaches = data_priv.access(doc, fix);

	                    if (!attaches) {
	                        doc.addEventListener(orig, handler, true);
	                    }
	                    data_priv.access(doc, fix, (attaches || 0) + 1);
	                },
	                teardown: function teardown() {
	                    var doc = this.ownerDocument || this,
	                        attaches = data_priv.access(doc, fix) - 1;

	                    if (!attaches) {
	                        doc.removeEventListener(orig, handler, true);
	                        data_priv.remove(doc, fix);
	                    } else {
	                        data_priv.access(doc, fix, attaches);
	                    }
	                }
	            };
	        });
	    }

	    jQuery.fn.extend({

	        on: function on(types, selector, data, fn, /*INTERNAL*/one) {
	            var origFn, type;

	            // Types can be a map of types/handlers
	            if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
	                // ( types-Object, selector, data )
	                if (typeof selector !== "string") {
	                    // ( types-Object, data )
	                    data = data || selector;
	                    selector = undefined;
	                }
	                for (type in types) {
	                    this.on(type, selector, data, types[type], one);
	                }
	                return this;
	            }

	            if (data == null && fn == null) {
	                // ( types, fn )
	                fn = selector;
	                data = selector = undefined;
	            } else if (fn == null) {
	                if (typeof selector === "string") {
	                    // ( types, selector, fn )
	                    fn = data;
	                    data = undefined;
	                } else {
	                    // ( types, data, fn )
	                    fn = data;
	                    data = selector;
	                    selector = undefined;
	                }
	            }
	            if (fn === false) {
	                fn = returnFalse;
	            } else if (!fn) {
	                return this;
	            }

	            if (one === 1) {
	                origFn = fn;
	                fn = function fn(event) {
	                    // Can use an empty set, since event contains the info
	                    jQuery().off(event);
	                    return origFn.apply(this, arguments);
	                };
	                // Use same guid so caller can remove using origFn
	                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
	            }
	            return this.each(function () {
	                jQuery.event.add(this, types, fn, data, selector);
	            });
	        },
	        one: function one(types, selector, data, fn) {
	            return this.on(types, selector, data, fn, 1);
	        },
	        off: function off(types, selector, fn) {
	            var handleObj, type;
	            if (types && types.preventDefault && types.handleObj) {
	                // ( event )  dispatched jQuery.Event
	                handleObj = types.handleObj;
	                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
	                return this;
	            }
	            if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
	                // ( types-object [, selector] )
	                for (type in types) {
	                    this.off(type, selector, types[type]);
	                }
	                return this;
	            }
	            if (selector === false || typeof selector === "function") {
	                // ( types [, fn] )
	                fn = selector;
	                selector = undefined;
	            }
	            if (fn === false) {
	                fn = returnFalse;
	            }
	            return this.each(function () {
	                jQuery.event.remove(this, types, fn, selector);
	            });
	        },

	        trigger: function trigger(type, data) {
	            return this.each(function () {
	                jQuery.event.trigger(type, data, this);
	            });
	        },
	        triggerHandler: function triggerHandler(type, data) {
	            var elem = this[0];
	            if (elem) {
	                return jQuery.event.trigger(type, data, elem, true);
	            }
	        }
	    });

	    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	        rtagName = /<([\w:]+)/,
	        rhtml = /<|&#?\w+;/,
	        rnoInnerhtml = /<(?:script|style|link)/i,

	    // checked="checked" or checked
	    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	        rscriptType = /^$|\/(?:java|ecma)script/i,
	        rscriptTypeMasked = /^true\/(.*)/,
	        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,


	    // We have to close these tags to support XHTML (#13200)
	    wrapMap = {

	        // Support: IE 9
	        option: [1, "<select multiple='multiple'>", "</select>"],

	        thead: [1, "<table>", "</table>"],
	        col: [2, "<table><colgroup>", "</colgroup></table>"],
	        tr: [2, "<table><tbody>", "</tbody></table>"],
	        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

	        _default: [0, "", ""]
	    };

	    // Support: IE 9
	    wrapMap.optgroup = wrapMap.option;

	    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	    wrapMap.th = wrapMap.td;

	    // Support: 1.x compatibility
	    // Manipulating tables requires a tbody
	    function manipulationTarget(elem, content) {
	        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	    }

	    // Replace/restore the type attribute of script elements for safe DOM manipulation
	    function disableScript(elem) {
	        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	        return elem;
	    }

	    function restoreScript(elem) {
	        var match = rscriptTypeMasked.exec(elem.type);

	        if (match) {
	            elem.type = match[1];
	        } else {
	            elem.removeAttribute("type");
	        }

	        return elem;
	    }

	    // Mark scripts as having already been evaluated
	    function setGlobalEval(elems, refElements) {
	        var i = 0,
	            l = elems.length;

	        for (; i < l; i++) {
	            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
	        }
	    }

	    function cloneCopyEvent(src, dest) {
	        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	        if (dest.nodeType !== 1) {
	            return;
	        }

	        // 1. Copy private data: events, handlers, etc.
	        if (data_priv.hasData(src)) {
	            pdataOld = data_priv.access(src);
	            pdataCur = data_priv.set(dest, pdataOld);
	            events = pdataOld.events;

	            if (events) {
	                delete pdataCur.handle;
	                pdataCur.events = {};

	                for (type in events) {
	                    for (i = 0, l = events[type].length; i < l; i++) {
	                        jQuery.event.add(dest, type, events[type][i]);
	                    }
	                }
	            }
	        }

	        // 2. Copy user data
	        if (data_user.hasData(src)) {
	            udataOld = data_user.access(src);
	            udataCur = jQuery.extend({}, udataOld);

	            data_user.set(dest, udataCur);
	        }
	    }

	    function getAll(context, tag) {
	        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];

	        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	    }

	    // Support: IE >= 9
	    function fixInput(src, dest) {
	        var nodeName = dest.nodeName.toLowerCase();

	        // Fails to persist the checked state of a cloned checkbox or radio button.
	        if (nodeName === "input" && rcheckableType.test(src.type)) {
	            dest.checked = src.checked;

	            // Fails to return the selected option to the default selected state when cloning options
	        } else if (nodeName === "input" || nodeName === "textarea") {
	            dest.defaultValue = src.defaultValue;
	        }
	    }

	    jQuery.extend({
	        clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
	            var i,
	                l,
	                srcElements,
	                destElements,
	                clone = elem.cloneNode(true),
	                inPage = jQuery.contains(elem.ownerDocument, elem);

	            // Support: IE >= 9
	            // Fix Cloning issues
	            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

	                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
	                destElements = getAll(clone);
	                srcElements = getAll(elem);

	                for (i = 0, l = srcElements.length; i < l; i++) {
	                    fixInput(srcElements[i], destElements[i]);
	                }
	            }

	            // Copy the events from the original to the clone
	            if (dataAndEvents) {
	                if (deepDataAndEvents) {
	                    srcElements = srcElements || getAll(elem);
	                    destElements = destElements || getAll(clone);

	                    for (i = 0, l = srcElements.length; i < l; i++) {
	                        cloneCopyEvent(srcElements[i], destElements[i]);
	                    }
	                } else {
	                    cloneCopyEvent(elem, clone);
	                }
	            }

	            // Preserve script evaluation history
	            destElements = getAll(clone, "script");
	            if (destElements.length > 0) {
	                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
	            }

	            // Return the cloned set
	            return clone;
	        },

	        buildFragment: function buildFragment(elems, context, scripts, selection) {
	            var elem,
	                tmp,
	                tag,
	                wrap,
	                contains,
	                j,
	                fragment = context.createDocumentFragment(),
	                nodes = [],
	                i = 0,
	                l = elems.length;

	            for (; i < l; i++) {
	                elem = elems[i];

	                if (elem || elem === 0) {

	                    // Add nodes directly
	                    if (jQuery.type(elem) === "object") {
	                        // Support: QtWebKit
	                        // jQuery.merge because push.apply(_, arraylike) throws
	                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

	                        // Convert non-html into a text node
	                    } else if (!rhtml.test(elem)) {
	                        nodes.push(context.createTextNode(elem));

	                        // Convert html into DOM nodes
	                    } else {
	                        tmp = tmp || fragment.appendChild(context.createElement("div"));

	                        // Deserialize a standard representation
	                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
	                        wrap = wrapMap[tag] || wrapMap._default;
	                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

	                        // Descend through wrappers to the right content
	                        j = wrap[0];
	                        while (j--) {
	                            tmp = tmp.lastChild;
	                        }

	                        // Support: QtWebKit
	                        // jQuery.merge because push.apply(_, arraylike) throws
	                        jQuery.merge(nodes, tmp.childNodes);

	                        // Remember the top-level container
	                        tmp = fragment.firstChild;

	                        // Fixes #12346
	                        // Support: Webkit, IE
	                        tmp.textContent = "";
	                    }
	                }
	            }

	            // Remove wrapper from fragment
	            fragment.textContent = "";

	            i = 0;
	            while (elem = nodes[i++]) {

	                // #4087 - If origin and destination elements are the same, and this is
	                // that element, do not do anything
	                if (selection && jQuery.inArray(elem, selection) !== -1) {
	                    continue;
	                }

	                contains = jQuery.contains(elem.ownerDocument, elem);

	                // Append to fragment
	                tmp = getAll(fragment.appendChild(elem), "script");

	                // Preserve script evaluation history
	                if (contains) {
	                    setGlobalEval(tmp);
	                }

	                // Capture executables
	                if (scripts) {
	                    j = 0;
	                    while (elem = tmp[j++]) {
	                        if (rscriptType.test(elem.type || "")) {
	                            scripts.push(elem);
	                        }
	                    }
	                }
	            }

	            return fragment;
	        },

	        cleanData: function cleanData(elems) {
	            var data,
	                elem,
	                events,
	                type,
	                key,
	                j,
	                special = jQuery.event.special,
	                i = 0;

	            for (; (elem = elems[i]) !== undefined; i++) {
	                if (jQuery.acceptData(elem)) {
	                    key = elem[data_priv.expando];

	                    if (key && (data = data_priv.cache[key])) {
	                        events = Object.keys(data.events || {});
	                        if (events.length) {
	                            for (j = 0; (type = events[j]) !== undefined; j++) {
	                                if (special[type]) {
	                                    jQuery.event.remove(elem, type);

	                                    // This is a shortcut to avoid jQuery.event.remove's overhead
	                                } else {
	                                    jQuery.removeEvent(elem, type, data.handle);
	                                }
	                            }
	                        }
	                        if (data_priv.cache[key]) {
	                            // Discard any remaining `private` data
	                            delete data_priv.cache[key];
	                        }
	                    }
	                }
	                // Discard any remaining `user` data
	                delete data_user.cache[elem[data_user.expando]];
	            }
	        }
	    });

	    jQuery.fn.extend({
	        text: function text(value) {
	            return access(this, function (value) {
	                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
	                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	                        this.textContent = value;
	                    }
	                });
	            }, null, value, arguments.length);
	        },

	        append: function append() {
	            return this.domManip(arguments, function (elem) {
	                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	                    var target = manipulationTarget(this, elem);
	                    target.appendChild(elem);
	                }
	            });
	        },

	        prepend: function prepend() {
	            return this.domManip(arguments, function (elem) {
	                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	                    var target = manipulationTarget(this, elem);
	                    target.insertBefore(elem, target.firstChild);
	                }
	            });
	        },

	        before: function before() {
	            return this.domManip(arguments, function (elem) {
	                if (this.parentNode) {
	                    this.parentNode.insertBefore(elem, this);
	                }
	            });
	        },

	        after: function after() {
	            return this.domManip(arguments, function (elem) {
	                if (this.parentNode) {
	                    this.parentNode.insertBefore(elem, this.nextSibling);
	                }
	            });
	        },

	        remove: function remove(selector, keepData /* Internal Use Only */) {
	            var elem,
	                elems = selector ? jQuery.filter(selector, this) : this,
	                i = 0;

	            for (; (elem = elems[i]) != null; i++) {
	                if (!keepData && elem.nodeType === 1) {
	                    jQuery.cleanData(getAll(elem));
	                }

	                if (elem.parentNode) {
	                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
	                        setGlobalEval(getAll(elem, "script"));
	                    }
	                    elem.parentNode.removeChild(elem);
	                }
	            }

	            return this;
	        },

	        empty: function empty() {
	            var elem,
	                i = 0;

	            for (; (elem = this[i]) != null; i++) {
	                if (elem.nodeType === 1) {

	                    // Prevent memory leaks
	                    jQuery.cleanData(getAll(elem, false));

	                    // Remove any remaining nodes
	                    elem.textContent = "";
	                }
	            }

	            return this;
	        },

	        clone: function clone(dataAndEvents, deepDataAndEvents) {
	            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
	            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

	            return this.map(function () {
	                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
	            });
	        },

	        html: function html(value) {
	            return access(this, function (value) {
	                var elem = this[0] || {},
	                    i = 0,
	                    l = this.length;

	                if (value === undefined && elem.nodeType === 1) {
	                    return elem.innerHTML;
	                }

	                // See if we can take a shortcut and just use innerHTML
	                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

	                    value = value.replace(rxhtmlTag, "<$1></$2>");

	                    try {
	                        for (; i < l; i++) {
	                            elem = this[i] || {};

	                            // Remove element nodes and prevent memory leaks
	                            if (elem.nodeType === 1) {
	                                jQuery.cleanData(getAll(elem, false));
	                                elem.innerHTML = value;
	                            }
	                        }

	                        elem = 0;

	                        // If using innerHTML throws an exception, use the fallback method
	                    } catch (e) {}
	                }

	                if (elem) {
	                    this.empty().append(value);
	                }
	            }, null, value, arguments.length);
	        },

	        replaceWith: function replaceWith() {
	            var arg = arguments[0];

	            // Make the changes, replacing each context element with the new content
	            this.domManip(arguments, function (elem) {
	                arg = this.parentNode;

	                jQuery.cleanData(getAll(this));

	                if (arg) {
	                    arg.replaceChild(elem, this);
	                }
	            });

	            // Force removal if there was no new content (e.g., from empty arguments)
	            return arg && (arg.length || arg.nodeType) ? this : this.remove();
	        },

	        detach: function detach(selector) {
	            return this.remove(selector, true);
	        },

	        domManip: function domManip(args, callback) {

	            // Flatten any nested arrays
	            args = concat.apply([], args);

	            var fragment,
	                first,
	                scripts,
	                hasScripts,
	                node,
	                doc,
	                i = 0,
	                l = this.length,
	                set = this,
	                iNoClone = l - 1,
	                value = args[0],
	                isFunction = jQuery.isFunction(value);

	            // We can't cloneNode fragments that contain checked, in WebKit
	            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
	                return this.each(function (index) {
	                    var self = set.eq(index);
	                    if (isFunction) {
	                        args[0] = value.call(this, index, self.html());
	                    }
	                    self.domManip(args, callback);
	                });
	            }

	            if (l) {
	                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
	                first = fragment.firstChild;

	                if (fragment.childNodes.length === 1) {
	                    fragment = first;
	                }

	                if (first) {
	                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
	                    hasScripts = scripts.length;

	                    // Use the original fragment for the last item instead of the first because it can end up
	                    // being emptied incorrectly in certain situations (#8070).
	                    for (; i < l; i++) {
	                        node = fragment;

	                        if (i !== iNoClone) {
	                            node = jQuery.clone(node, true, true);

	                            // Keep references to cloned scripts for later restoration
	                            if (hasScripts) {
	                                // Support: QtWebKit
	                                // jQuery.merge because push.apply(_, arraylike) throws
	                                jQuery.merge(scripts, getAll(node, "script"));
	                            }
	                        }

	                        callback.call(this[i], node, i);
	                    }

	                    if (hasScripts) {
	                        doc = scripts[scripts.length - 1].ownerDocument;

	                        // Reenable scripts
	                        jQuery.map(scripts, restoreScript);

	                        // Evaluate executable scripts on first document insertion
	                        for (i = 0; i < hasScripts; i++) {
	                            node = scripts[i];
	                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

	                                if (node.src) {
	                                    // Optional AJAX dependency, but won't run scripts if not present
	                                    if (jQuery._evalUrl) {
	                                        jQuery._evalUrl(node.src);
	                                    }
	                                } else {
	                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
	                                }
	                            }
	                        }
	                    }
	                }
	            }

	            return this;
	        }
	    });

	    jQuery.each({
	        appendTo: "append",
	        prependTo: "prepend",
	        insertBefore: "before",
	        insertAfter: "after",
	        replaceAll: "replaceWith"
	    }, function (name, original) {
	        jQuery.fn[name] = function (selector) {
	            var elems,
	                ret = [],
	                insert = jQuery(selector),
	                last = insert.length - 1,
	                i = 0;

	            for (; i <= last; i++) {
	                elems = i === last ? this : this.clone(true);
	                jQuery(insert[i])[original](elems);

	                // Support: QtWebKit
	                // .get() because push.apply(_, arraylike) throws
	                push.apply(ret, elems.get());
	            }

	            return this.pushStack(ret);
	        };
	    });

	    var iframe,
	        elemdisplay = {};

	    /**
	     * Retrieve the actual display of a element
	     * @param {String} name nodeName of the element
	     * @param {Object} doc Document object
	     */
	    // Called only from within defaultDisplay
	    function actualDisplay(name, doc) {
	        var elem = jQuery(doc.createElement(name)).appendTo(doc.body),


	        // getDefaultComputedStyle might be reliably used only on attached element
	        display = window.getDefaultComputedStyle ?

	        // Use of this method is a temporary fix (more like optmization) until something better comes along,
	        // since it was removed from specification and supported only in FF
	        window.getDefaultComputedStyle(elem[0]).display : jQuery.css(elem[0], "display");

	        // We don't have any data stored on the element,
	        // so use "detach" method as fast way to get rid of the element
	        elem.detach();

	        return display;
	    }

	    /**
	     * Try to determine the default display value of an element
	     * @param {String} nodeName
	     */
	    function defaultDisplay(nodeName) {
	        var doc = document,
	            display = elemdisplay[nodeName];

	        if (!display) {
	            display = actualDisplay(nodeName, doc);

	            // If the simple way fails, read from inside an iframe
	            if (display === "none" || !display) {

	                // Use the already-created iframe if possible
	                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

	                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
	                doc = iframe[0].contentDocument;

	                // Support: IE
	                doc.write();
	                doc.close();

	                display = actualDisplay(nodeName, doc);
	                iframe.detach();
	            }

	            // Store the correct default display
	            elemdisplay[nodeName] = display;
	        }

	        return display;
	    }
	    var rmargin = /^margin/;

	    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	    var getStyles = function getStyles(elem) {
	        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
	    };

	    function curCSS(elem, name, computed) {
	        var width,
	            minWidth,
	            maxWidth,
	            ret,
	            style = elem.style;

	        computed = computed || getStyles(elem);

	        // Support: IE9
	        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
	        if (computed) {
	            ret = computed.getPropertyValue(name) || computed[name];
	        }

	        if (computed) {

	            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
	                ret = jQuery.style(elem, name);
	            }

	            // Support: iOS < 6
	            // A tribute to the "awesome hack by Dean Edwards"
	            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
	            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
	            if (rnumnonpx.test(ret) && rmargin.test(name)) {

	                // Remember the original values
	                width = style.width;
	                minWidth = style.minWidth;
	                maxWidth = style.maxWidth;

	                // Put in the new values to get a computed value out
	                style.minWidth = style.maxWidth = style.width = ret;
	                ret = computed.width;

	                // Revert the changed values
	                style.width = width;
	                style.minWidth = minWidth;
	                style.maxWidth = maxWidth;
	            }
	        }

	        return ret !== undefined ?
	        // Support: IE
	        // IE returns zIndex value as an integer.
	        ret + "" : ret;
	    }

	    function addGetHookIf(conditionFn, hookFn) {
	        // Define the hook, we'll check on the first run if it's really needed.
	        return {
	            get: function get() {
	                if (conditionFn()) {
	                    // Hook not needed (or it's not possible to use it due to missing dependency),
	                    // remove it.
	                    // Since there are no other hooks for marginRight, remove the whole object.
	                    delete this.get;
	                    return;
	                }

	                // Hook needed; redefine it so that the support test is not executed again.

	                return (this.get = hookFn).apply(this, arguments);
	            }
	        };
	    }

	    (function () {
	        var pixelPositionVal,
	            boxSizingReliableVal,

	        // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
	        divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;" + "-moz-box-sizing:content-box;box-sizing:content-box",
	            docElem = document.documentElement,
	            container = document.createElement("div"),
	            div = document.createElement("div");

	        div.style.backgroundClip = "content-box";
	        div.cloneNode(true).style.backgroundClip = "";
	        support.clearCloneStyle = div.style.backgroundClip === "content-box";

	        container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;" + "margin-top:1px";
	        container.appendChild(div);

	        // Executing both pixelPosition & boxSizingReliable tests require only one layout
	        // so they're executed at the same time to save the second computation.
	        function computePixelPositionAndBoxSizingReliable() {
	            // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
	            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;" + "position:absolute;top:1%";
	            docElem.appendChild(container);

	            var divStyle = window.getComputedStyle(div, null);
	            pixelPositionVal = divStyle.top !== "1%";
	            boxSizingReliableVal = divStyle.width === "4px";

	            docElem.removeChild(container);
	        }

	        // Use window.getComputedStyle because jsdom on node.js will break without it.
	        if (window.getComputedStyle) {
	            jQuery.extend(support, {
	                pixelPosition: function pixelPosition() {
	                    // This test is executed only once but we still do memoizing
	                    // since we can use the boxSizingReliable pre-computing.
	                    // No need to check if the test was already performed, though.
	                    computePixelPositionAndBoxSizingReliable();
	                    return pixelPositionVal;
	                },
	                boxSizingReliable: function boxSizingReliable() {
	                    if (boxSizingReliableVal == null) {
	                        computePixelPositionAndBoxSizingReliable();
	                    }
	                    return boxSizingReliableVal;
	                },
	                reliableMarginRight: function reliableMarginRight() {
	                    // Support: Android 2.3
	                    // Check if div with explicit width and no margin-right incorrectly
	                    // gets computed margin-right based on width of container. (#3333)
	                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	                    // This support function is only executed once so no memoizing is needed.
	                    var ret,
	                        marginDiv = div.appendChild(document.createElement("div"));
	                    marginDiv.style.cssText = div.style.cssText = divReset;
	                    marginDiv.style.marginRight = marginDiv.style.width = "0";
	                    div.style.width = "1px";
	                    docElem.appendChild(container);

	                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

	                    docElem.removeChild(container);

	                    // Clean up the div for other support tests.
	                    div.innerHTML = "";

	                    return ret;
	                }
	            });
	        }
	    })();

	    // A method for quickly swapping in/out CSS properties to get correct calculations.
	    jQuery.swap = function (elem, options, callback, args) {
	        var ret,
	            name,
	            old = {};

	        // Remember the old values, and insert the new ones
	        for (name in options) {
	            old[name] = elem.style[name];
	            elem.style[name] = options[name];
	        }

	        ret = callback.apply(elem, args || []);

	        // Revert the old values
	        for (name in options) {
	            elem.style[name] = old[name];
	        }

	        return ret;
	    };

	    var
	    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	        rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
	        rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
	        cssShow = {
	        position: "absolute",
	        visibility: "hidden",
	        display: "block"
	    },
	        cssNormalTransform = {
	        letterSpacing: 0,
	        fontWeight: 400
	    },
	        cssPrefixes = ["Webkit", "O", "Moz", "ms"];

	    // return a css property mapped to a potentially vendor prefixed property
	    function vendorPropName(style, name) {

	        // shortcut for names that are not vendor prefixed
	        if (name in style) {
	            return name;
	        }

	        // check for vendor prefixed names
	        var capName = name[0].toUpperCase() + name.slice(1),
	            origName = name,
	            i = cssPrefixes.length;

	        while (i--) {
	            name = cssPrefixes[i] + capName;
	            if (name in style) {
	                return name;
	            }
	        }

	        return origName;
	    }

	    function setPositiveNumber(elem, value, subtract) {
	        var matches = rnumsplit.exec(value);
	        return matches ?
	        // Guard against undefined "subtract", e.g., when used as in cssHooks
	        Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
	    }

	    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
	        var i = extra === (isBorderBox ? "border" : "content") ?
	        // If we already have the right measurement, avoid augmentation
	        4 :
	        // Otherwise initialize for horizontal or vertical properties
	        name === "width" ? 1 : 0,
	            val = 0;

	        for (; i < 4; i += 2) {
	            // both box models exclude margin, so add it if we want it
	            if (extra === "margin") {
	                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
	            }

	            if (isBorderBox) {
	                // border-box includes padding, so remove it if we want content
	                if (extra === "content") {
	                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
	                }

	                // at this point, extra isn't border nor margin, so remove border
	                if (extra !== "margin") {
	                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	                }
	            } else {
	                // at this point, extra isn't content, so add padding
	                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

	                // at this point, extra isn't content nor padding, so add border
	                if (extra !== "padding") {
	                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	                }
	            }
	        }

	        return val;
	    }

	    function getWidthOrHeight(elem, name, extra) {

	        // Start with offset property, which is equivalent to the border-box value
	        var valueIsBorderBox = true,
	            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
	            styles = getStyles(elem),
	            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

	        // some non-html elements return undefined for offsetWidth, so check for null/undefined
	        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	        if (val <= 0 || val == null) {
	            // Fall back to computed then uncomputed css if necessary
	            val = curCSS(elem, name, styles);
	            if (val < 0 || val == null) {
	                val = elem.style[name];
	            }

	            // Computed unit is not pixels. Stop here and return.
	            if (rnumnonpx.test(val)) {
	                return val;
	            }

	            // we need the check for style in case a browser which returns unreliable values
	            // for getComputedStyle silently falls back to the reliable elem.style
	            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

	            // Normalize "", auto, and prepare for extra
	            val = parseFloat(val) || 0;
	        }

	        // use the active box-sizing model to add/subtract irrelevant styles
	        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	    }

	    function showHide(elements, show) {
	        var display,
	            elem,
	            hidden,
	            values = [],
	            index = 0,
	            length = elements.length;

	        for (; index < length; index++) {
	            elem = elements[index];
	            if (!elem.style) {
	                continue;
	            }

	            values[index] = data_priv.get(elem, "olddisplay");
	            display = elem.style.display;
	            if (show) {
	                // Reset the inline display of this element to learn if it is
	                // being hidden by cascaded rules or not
	                if (!values[index] && display === "none") {
	                    elem.style.display = "";
	                }

	                // Set elements which have been overridden with display: none
	                // in a stylesheet to whatever the default browser style is
	                // for such an element
	                if (elem.style.display === "" && isHidden(elem)) {
	                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
	                }
	            } else {

	                if (!values[index]) {
	                    hidden = isHidden(elem);

	                    if (display && display !== "none" || !hidden) {
	                        data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
	                    }
	                }
	            }
	        }

	        // Set the display of most of the elements in a second loop
	        // to avoid the constant reflow
	        for (index = 0; index < length; index++) {
	            elem = elements[index];
	            if (!elem.style) {
	                continue;
	            }
	            if (!show || elem.style.display === "none" || elem.style.display === "") {
	                elem.style.display = show ? values[index] || "" : "none";
	            }
	        }

	        return elements;
	    }

	    jQuery.extend({
	        // Add in style property hooks for overriding the default
	        // behavior of getting and setting a style property
	        cssHooks: {
	            opacity: {
	                get: function get(elem, computed) {
	                    if (computed) {
	                        // We should always get a number back from opacity
	                        var ret = curCSS(elem, "opacity");
	                        return ret === "" ? "1" : ret;
	                    }
	                }
	            }
	        },

	        // Don't automatically add "px" to these possibly-unitless properties
	        cssNumber: {
	            "columnCount": true,
	            "fillOpacity": true,
	            "fontWeight": true,
	            "lineHeight": true,
	            "opacity": true,
	            "order": true,
	            "orphans": true,
	            "widows": true,
	            "zIndex": true,
	            "zoom": true
	        },

	        // Add in properties whose names you wish to fix before
	        // setting or getting the value
	        cssProps: {
	            // normalize float css property
	            "float": "cssFloat"
	        },

	        // Get and set the style property on a DOM Node
	        style: function style(elem, name, value, extra) {
	            // Don't set styles on text and comment nodes
	            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
	                return;
	            }

	            // Make sure that we're working with the right name
	            var ret,
	                type,
	                hooks,
	                origName = jQuery.camelCase(name),
	                style = elem.style;

	            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

	            // gets hook for the prefixed version
	            // followed by the unprefixed version
	            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

	            // Check if we're setting a value
	            if (value !== undefined) {
	                type = typeof value === "undefined" ? "undefined" : _typeof(value);

	                // convert relative number strings (+= or -=) to relative numbers. #7345
	                if (type === "string" && (ret = rrelNum.exec(value))) {
	                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
	                    // Fixes bug #9237
	                    type = "number";
	                }

	                // Make sure that null and NaN values aren't set. See: #7116
	                if (value == null || value !== value) {
	                    return;
	                }

	                // If a number was passed in, add 'px' to the (except for certain CSS properties)
	                if (type === "number" && !jQuery.cssNumber[origName]) {
	                    value += "px";
	                }

	                // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
	                // but it would mean to define eight (for every problematic property) identical functions
	                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
	                    style[name] = "inherit";
	                }

	                // If a hook was provided, use that value, otherwise just set the specified value
	                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
	                    // Support: Chrome, Safari
	                    // Setting style to blank string required to delete "style: x !important;"
	                    style[name] = "";
	                    style[name] = value;
	                }
	            } else {
	                // If a hook was provided get the non-computed value from there
	                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
	                    return ret;
	                }

	                // Otherwise just get the value from the style object
	                return style[name];
	            }
	        },

	        css: function css(elem, name, extra, styles) {
	            var val,
	                num,
	                hooks,
	                origName = jQuery.camelCase(name);

	            // Make sure that we're working with the right name
	            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

	            // gets hook for the prefixed version
	            // followed by the unprefixed version
	            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

	            // If a hook was provided get the computed value from there
	            if (hooks && "get" in hooks) {
	                val = hooks.get(elem, true, extra);
	            }

	            // Otherwise, if a way to get the computed value exists, use that
	            if (val === undefined) {
	                val = curCSS(elem, name, styles);
	            }

	            //convert "normal" to computed value
	            if (val === "normal" && name in cssNormalTransform) {
	                val = cssNormalTransform[name];
	            }

	            // Return, converting to number if forced or a qualifier was provided and val looks numeric
	            if (extra === "" || extra) {
	                num = parseFloat(val);
	                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
	            }
	            return val;
	        }
	    });

	    jQuery.each(["height", "width"], function (i, name) {
	        jQuery.cssHooks[name] = {
	            get: function get(elem, computed, extra) {
	                if (computed) {
	                    // certain elements can have dimension info if we invisibly show them
	                    // however, it must have a current display style that would benefit from this
	                    return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, "display")) ? jQuery.swap(elem, cssShow, function () {
	                        return getWidthOrHeight(elem, name, extra);
	                    }) : getWidthOrHeight(elem, name, extra);
	                }
	            },

	            set: function set(elem, value, extra) {
	                var styles = extra && getStyles(elem);
	                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
	            }
	        };
	    });

	    // Support: Android 2.3
	    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
	        if (computed) {
	            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	            // Work around by temporarily setting element display to inline-block
	            return jQuery.swap(elem, {
	                "display": "inline-block"
	            }, curCSS, [elem, "marginRight"]);
	        }
	    });

	    // These hooks are used by animate to expand properties
	    jQuery.each({
	        margin: "",
	        padding: "",
	        border: "Width"
	    }, function (prefix, suffix) {
	        jQuery.cssHooks[prefix + suffix] = {
	            expand: function expand(value) {
	                var i = 0,
	                    expanded = {},


	                // assumes a single number if not a string
	                parts = typeof value === "string" ? value.split(" ") : [value];

	                for (; i < 4; i++) {
	                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
	                }

	                return expanded;
	            }
	        };

	        if (!rmargin.test(prefix)) {
	            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
	        }
	    });

	    jQuery.fn.extend({
	        css: function css(name, value) {
	            return access(this, function (elem, name, value) {
	                var styles,
	                    len,
	                    map = {},
	                    i = 0;

	                if (jQuery.isArray(name)) {
	                    styles = getStyles(elem);
	                    len = name.length;

	                    for (; i < len; i++) {
	                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
	                    }

	                    return map;
	                }

	                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
	            }, name, value, arguments.length > 1);
	        },
	        show: function show() {
	            return showHide(this, true);
	        },
	        hide: function hide() {
	            return showHide(this);
	        },
	        toggle: function toggle(state) {
	            if (typeof state === "boolean") {
	                return state ? this.show() : this.hide();
	            }

	            return this.each(function () {
	                if (isHidden(this)) {
	                    jQuery(this).show();
	                } else {
	                    jQuery(this).hide();
	                }
	            });
	        }
	    });

	    function Tween(elem, options, prop, end, easing) {
	        return new Tween.prototype.init(elem, options, prop, end, easing);
	    }
	    jQuery.Tween = Tween;

	    Tween.prototype = {
	        constructor: Tween,
	        init: function init(elem, options, prop, end, easing, unit) {
	            this.elem = elem;
	            this.prop = prop;
	            this.easing = easing || "swing";
	            this.options = options;
	            this.start = this.now = this.cur();
	            this.end = end;
	            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
	        },
	        cur: function cur() {
	            var hooks = Tween.propHooks[this.prop];

	            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
	        },
	        run: function run(percent) {
	            var eased,
	                hooks = Tween.propHooks[this.prop];

	            if (this.options.duration) {
	                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
	            } else {
	                this.pos = eased = percent;
	            }
	            this.now = (this.end - this.start) * eased + this.start;

	            if (this.options.step) {
	                this.options.step.call(this.elem, this.now, this);
	            }

	            if (hooks && hooks.set) {
	                hooks.set(this);
	            } else {
	                Tween.propHooks._default.set(this);
	            }
	            return this;
	        }
	    };

	    Tween.prototype.init.prototype = Tween.prototype;

	    Tween.propHooks = {
	        _default: {
	            get: function get(tween) {
	                var result;

	                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
	                    return tween.elem[tween.prop];
	                }

	                // passing an empty string as a 3rd parameter to .css will automatically
	                // attempt a parseFloat and fallback to a string if the parse fails
	                // so, simple values such as "10px" are parsed to Float.
	                // complex values such as "rotate(1rad)" are returned as is.
	                result = jQuery.css(tween.elem, tween.prop, "");
	                // Empty strings, null, undefined and "auto" are converted to 0.
	                return !result || result === "auto" ? 0 : result;
	            },
	            set: function set(tween) {
	                // use step hook for back compat - use cssHook if its there - use .style if its
	                // available and use plain properties where available
	                if (jQuery.fx.step[tween.prop]) {
	                    jQuery.fx.step[tween.prop](tween);
	                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
	                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
	                } else {
	                    tween.elem[tween.prop] = tween.now;
	                }
	            }
	        }
	    };

	    // Support: IE9
	    // Panic based approach to setting things on disconnected nodes

	    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	        set: function set(tween) {
	            if (tween.elem.nodeType && tween.elem.parentNode) {
	                tween.elem[tween.prop] = tween.now;
	            }
	        }
	    };

	    jQuery.easing = {
	        linear: function linear(p) {
	            return p;
	        },
	        swing: function swing(p) {
	            return 0.5 - Math.cos(p * Math.PI) / 2;
	        }
	    };

	    jQuery.fx = Tween.prototype.init;

	    // Back Compat <1.8 extension point
	    jQuery.fx.step = {};

	    var fxNow,
	        timerId,
	        rfxtypes = /^(?:toggle|show|hide)$/,
	        rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
	        rrun = /queueHooks$/,
	        animationPrefilters = [defaultPrefilter],
	        tweeners = {
	        "*": [function (prop, value) {
	            var tween = this.createTween(prop, value),
	                target = tween.cur(),
	                parts = rfxnum.exec(value),
	                unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


	            // Starting value computation is required for potential unit mismatches
	            start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
	                scale = 1,
	                maxIterations = 20;

	            if (start && start[3] !== unit) {
	                // Trust units reported by jQuery.css
	                unit = unit || start[3];

	                // Make sure we update the tween properties later on
	                parts = parts || [];

	                // Iteratively approximate from a nonzero starting point
	                start = +target || 1;

	                do {
	                    // If previous iteration zeroed out, double until we get *something*
	                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below
	                    scale = scale || ".5";

	                    // Adjust and apply
	                    start = start / scale;
	                    jQuery.style(tween.elem, prop, start + unit);

	                    // Update scale, tolerating zero or NaN from tween.cur()
	                    // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
	                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
	            }

	            // Update tween properties
	            if (parts) {
	                start = tween.start = +start || +target || 0;
	                tween.unit = unit;
	                // If a +=/-= token was provided, we're doing a relative animation
	                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
	            }

	            return tween;
	        }]
	    };

	    // Animations created synchronously will run synchronously
	    function createFxNow() {
	        setTimeout(function () {
	            fxNow = undefined;
	        });
	        return fxNow = jQuery.now();
	    }

	    // Generate parameters to create a standard animation
	    function genFx(type, includeWidth) {
	        var which,
	            i = 0,
	            attrs = {
	            height: type
	        };

	        // if we include width, step value is 1 to do all cssExpand values,
	        // if we don't include width, step value is 2 to skip over Left and Right
	        includeWidth = includeWidth ? 1 : 0;
	        for (; i < 4; i += 2 - includeWidth) {
	            which = cssExpand[i];
	            attrs["margin" + which] = attrs["padding" + which] = type;
	        }

	        if (includeWidth) {
	            attrs.opacity = attrs.width = type;
	        }

	        return attrs;
	    }

	    function createTween(value, prop, animation) {
	        var tween,
	            collection = (tweeners[prop] || []).concat(tweeners["*"]),
	            index = 0,
	            length = collection.length;
	        for (; index < length; index++) {
	            if (tween = collection[index].call(animation, prop, value)) {

	                // we're done with this property
	                return tween;
	            }
	        }
	    }

	    function defaultPrefilter(elem, props, opts) {
	        /* jshint validthis: true */
	        var prop,
	            value,
	            toggle,
	            tween,
	            hooks,
	            oldfire,
	            display,
	            anim = this,
	            orig = {},
	            style = elem.style,
	            hidden = elem.nodeType && isHidden(elem),
	            dataShow = data_priv.get(elem, "fxshow");

	        // handle queue: false promises
	        if (!opts.queue) {
	            hooks = jQuery._queueHooks(elem, "fx");
	            if (hooks.unqueued == null) {
	                hooks.unqueued = 0;
	                oldfire = hooks.empty.fire;
	                hooks.empty.fire = function () {
	                    if (!hooks.unqueued) {
	                        oldfire();
	                    }
	                };
	            }
	            hooks.unqueued++;

	            anim.always(function () {
	                // doing this makes sure that the complete handler will be called
	                // before this completes
	                anim.always(function () {
	                    hooks.unqueued--;
	                    if (!jQuery.queue(elem, "fx").length) {
	                        hooks.empty.fire();
	                    }
	                });
	            });
	        }

	        // height/width overflow pass
	        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
	            // Make sure that nothing sneaks out
	            // Record all 3 overflow attributes because IE9-10 do not
	            // change the overflow attribute when overflowX and
	            // overflowY are set to the same value
	            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

	            // Set display property to inline-block for height/width
	            // animations on inline elements that are having width/height animated
	            display = jQuery.css(elem, "display");
	            // Get default display if display is currently "none"
	            if (display === "none") {
	                display = defaultDisplay(elem.nodeName);
	            }
	            if (display === "inline" && jQuery.css(elem, "float") === "none") {

	                style.display = "inline-block";
	            }
	        }

	        if (opts.overflow) {
	            style.overflow = "hidden";
	            anim.always(function () {
	                style.overflow = opts.overflow[0];
	                style.overflowX = opts.overflow[1];
	                style.overflowY = opts.overflow[2];
	            });
	        }

	        // show/hide pass
	        for (prop in props) {
	            value = props[prop];
	            if (rfxtypes.exec(value)) {
	                delete props[prop];
	                toggle = toggle || value === "toggle";
	                if (value === (hidden ? "hide" : "show")) {

	                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
	                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
	                        hidden = true;
	                    } else {
	                        continue;
	                    }
	                }
	                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
	            }
	        }

	        if (!jQuery.isEmptyObject(orig)) {
	            if (dataShow) {
	                if ("hidden" in dataShow) {
	                    hidden = dataShow.hidden;
	                }
	            } else {
	                dataShow = data_priv.access(elem, "fxshow", {});
	            }

	            // store state if its toggle - enables .stop().toggle() to "reverse"
	            if (toggle) {
	                dataShow.hidden = !hidden;
	            }
	            if (hidden) {
	                jQuery(elem).show();
	            } else {
	                anim.done(function () {
	                    jQuery(elem).hide();
	                });
	            }
	            anim.done(function () {
	                var prop;

	                data_priv.remove(elem, "fxshow");
	                for (prop in orig) {
	                    jQuery.style(elem, prop, orig[prop]);
	                }
	            });
	            for (prop in orig) {
	                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

	                if (!(prop in dataShow)) {
	                    dataShow[prop] = tween.start;
	                    if (hidden) {
	                        tween.end = tween.start;
	                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
	                    }
	                }
	            }
	        }
	    }

	    function propFilter(props, specialEasing) {
	        var index, name, easing, value, hooks;

	        // camelCase, specialEasing and expand cssHook pass
	        for (index in props) {
	            name = jQuery.camelCase(index);
	            easing = specialEasing[name];
	            value = props[index];
	            if (jQuery.isArray(value)) {
	                easing = value[1];
	                value = props[index] = value[0];
	            }

	            if (index !== name) {
	                props[name] = value;
	                delete props[index];
	            }

	            hooks = jQuery.cssHooks[name];
	            if (hooks && "expand" in hooks) {
	                value = hooks.expand(value);
	                delete props[name];

	                // not quite $.extend, this wont overwrite keys already present.
	                // also - reusing 'index' from above because we have the correct "name"
	                for (index in value) {
	                    if (!(index in props)) {
	                        props[index] = value[index];
	                        specialEasing[index] = easing;
	                    }
	                }
	            } else {
	                specialEasing[name] = easing;
	            }
	        }
	    }

	    function Animation(elem, properties, options) {
	        var result,
	            stopped,
	            index = 0,
	            length = animationPrefilters.length,
	            deferred = jQuery.Deferred().always(function () {
	            // don't match elem in the :animated selector
	            delete tick.elem;
	        }),
	            tick = function tick() {
	            if (stopped) {
	                return false;
	            }
	            var currentTime = fxNow || createFxNow(),
	                remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

	            // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
	            temp = remaining / animation.duration || 0,
	                percent = 1 - temp,
	                index = 0,
	                length = animation.tweens.length;

	            for (; index < length; index++) {
	                animation.tweens[index].run(percent);
	            }

	            deferred.notifyWith(elem, [animation, percent, remaining]);

	            if (percent < 1 && length) {
	                return remaining;
	            } else {
	                deferred.resolveWith(elem, [animation]);
	                return false;
	            }
	        },
	            animation = deferred.promise({
	            elem: elem,
	            props: jQuery.extend({}, properties),
	            opts: jQuery.extend(true, {
	                specialEasing: {}
	            }, options),
	            originalProperties: properties,
	            originalOptions: options,
	            startTime: fxNow || createFxNow(),
	            duration: options.duration,
	            tweens: [],
	            createTween: function createTween(prop, end) {
	                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
	                animation.tweens.push(tween);
	                return tween;
	            },
	            stop: function stop(gotoEnd) {
	                var index = 0,

	                // if we are going to the end, we want to run all the tweens
	                // otherwise we skip this part
	                length = gotoEnd ? animation.tweens.length : 0;
	                if (stopped) {
	                    return this;
	                }
	                stopped = true;
	                for (; index < length; index++) {
	                    animation.tweens[index].run(1);
	                }

	                // resolve when we played the last frame
	                // otherwise, reject
	                if (gotoEnd) {
	                    deferred.resolveWith(elem, [animation, gotoEnd]);
	                } else {
	                    deferred.rejectWith(elem, [animation, gotoEnd]);
	                }
	                return this;
	            }
	        }),
	            props = animation.props;

	        propFilter(props, animation.opts.specialEasing);

	        for (; index < length; index++) {
	            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
	            if (result) {
	                return result;
	            }
	        }

	        jQuery.map(props, createTween, animation);

	        if (jQuery.isFunction(animation.opts.start)) {
	            animation.opts.start.call(elem, animation);
	        }

	        jQuery.fx.timer(jQuery.extend(tick, {
	            elem: elem,
	            anim: animation,
	            queue: animation.opts.queue
	        }));

	        // attach callbacks from options
	        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	    }

	    jQuery.Animation = jQuery.extend(Animation, {

	        tweener: function tweener(props, callback) {
	            if (jQuery.isFunction(props)) {
	                callback = props;
	                props = ["*"];
	            } else {
	                props = props.split(" ");
	            }

	            var prop,
	                index = 0,
	                length = props.length;

	            for (; index < length; index++) {
	                prop = props[index];
	                tweeners[prop] = tweeners[prop] || [];
	                tweeners[prop].unshift(callback);
	            }
	        },

	        prefilter: function prefilter(callback, prepend) {
	            if (prepend) {
	                animationPrefilters.unshift(callback);
	            } else {
	                animationPrefilters.push(callback);
	            }
	        }
	    });

	    jQuery.speed = function (speed, easing, fn) {
	        var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
	            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
	            duration: speed,
	            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
	        };

	        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

	        // normalize opt.queue - true/undefined/null -> "fx"
	        if (opt.queue == null || opt.queue === true) {
	            opt.queue = "fx";
	        }

	        // Queueing
	        opt.old = opt.complete;

	        opt.complete = function () {
	            if (jQuery.isFunction(opt.old)) {
	                opt.old.call(this);
	            }

	            if (opt.queue) {
	                jQuery.dequeue(this, opt.queue);
	            }
	        };

	        return opt;
	    };

	    jQuery.fn.extend({
	        fadeTo: function fadeTo(speed, to, easing, callback) {

	            // show any hidden elements after setting opacity to 0
	            return this.filter(isHidden).css("opacity", 0).show()

	            // animate to the value specified
	            .end().animate({
	                opacity: to
	            }, speed, easing, callback);
	        },
	        animate: function animate(prop, speed, easing, callback) {
	            var empty = jQuery.isEmptyObject(prop),
	                optall = jQuery.speed(speed, easing, callback),
	                doAnimation = function doAnimation() {
	                // Operate on a copy of prop so per-property easing won't be lost
	                var anim = Animation(this, jQuery.extend({}, prop), optall);

	                // Empty animations, or finishing resolves immediately
	                if (empty || data_priv.get(this, "finish")) {
	                    anim.stop(true);
	                }
	            };
	            doAnimation.finish = doAnimation;

	            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
	        },
	        stop: function stop(type, clearQueue, gotoEnd) {
	            var stopQueue = function stopQueue(hooks) {
	                var stop = hooks.stop;
	                delete hooks.stop;
	                stop(gotoEnd);
	            };

	            if (typeof type !== "string") {
	                gotoEnd = clearQueue;
	                clearQueue = type;
	                type = undefined;
	            }
	            if (clearQueue && type !== false) {
	                this.queue(type || "fx", []);
	            }

	            return this.each(function () {
	                var dequeue = true,
	                    index = type != null && type + "queueHooks",
	                    timers = jQuery.timers,
	                    data = data_priv.get(this);

	                if (index) {
	                    if (data[index] && data[index].stop) {
	                        stopQueue(data[index]);
	                    }
	                } else {
	                    for (index in data) {
	                        if (data[index] && data[index].stop && rrun.test(index)) {
	                            stopQueue(data[index]);
	                        }
	                    }
	                }

	                for (index = timers.length; index--;) {
	                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
	                        timers[index].anim.stop(gotoEnd);
	                        dequeue = false;
	                        timers.splice(index, 1);
	                    }
	                }

	                // start the next in the queue if the last step wasn't forced
	                // timers currently will call their complete callbacks, which will dequeue
	                // but only if they were gotoEnd
	                if (dequeue || !gotoEnd) {
	                    jQuery.dequeue(this, type);
	                }
	            });
	        },
	        finish: function finish(type) {
	            if (type !== false) {
	                type = type || "fx";
	            }
	            return this.each(function () {
	                var index,
	                    data = data_priv.get(this),
	                    queue = data[type + "queue"],
	                    hooks = data[type + "queueHooks"],
	                    timers = jQuery.timers,
	                    length = queue ? queue.length : 0;

	                // enable finishing flag on private data
	                data.finish = true;

	                // empty the queue first
	                jQuery.queue(this, type, []);

	                if (hooks && hooks.stop) {
	                    hooks.stop.call(this, true);
	                }

	                // look for any active animations, and finish them
	                for (index = timers.length; index--;) {
	                    if (timers[index].elem === this && timers[index].queue === type) {
	                        timers[index].anim.stop(true);
	                        timers.splice(index, 1);
	                    }
	                }

	                // look for any animations in the old queue and finish them
	                for (index = 0; index < length; index++) {
	                    if (queue[index] && queue[index].finish) {
	                        queue[index].finish.call(this);
	                    }
	                }

	                // turn off finishing flag
	                delete data.finish;
	            });
	        }
	    });

	    jQuery.each(["toggle", "show", "hide"], function (i, name) {
	        var cssFn = jQuery.fn[name];
	        jQuery.fn[name] = function (speed, easing, callback) {
	            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
	        };
	    });

	    // Generate shortcuts for custom animations
	    jQuery.each({
	        slideDown: genFx("show"),
	        slideUp: genFx("hide"),
	        slideToggle: genFx("toggle"),
	        fadeIn: {
	            opacity: "show"
	        },
	        fadeOut: {
	            opacity: "hide"
	        },
	        fadeToggle: {
	            opacity: "toggle"
	        }
	    }, function (name, props) {
	        jQuery.fn[name] = function (speed, easing, callback) {
	            return this.animate(props, speed, easing, callback);
	        };
	    });

	    jQuery.timers = [];
	    jQuery.fx.tick = function () {
	        var timer,
	            i = 0,
	            timers = jQuery.timers;

	        fxNow = jQuery.now();

	        for (; i < timers.length; i++) {
	            timer = timers[i];
	            // Checks the timer has not already been removed
	            if (!timer() && timers[i] === timer) {
	                timers.splice(i--, 1);
	            }
	        }

	        if (!timers.length) {
	            jQuery.fx.stop();
	        }
	        fxNow = undefined;
	    };

	    jQuery.fx.timer = function (timer) {
	        jQuery.timers.push(timer);
	        if (timer()) {
	            jQuery.fx.start();
	        } else {
	            jQuery.timers.pop();
	        }
	    };

	    jQuery.fx.interval = 13;

	    jQuery.fx.start = function () {
	        if (!timerId) {
	            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
	        }
	    };

	    jQuery.fx.stop = function () {
	        clearInterval(timerId);
	        timerId = null;
	    };

	    jQuery.fx.speeds = {
	        slow: 600,
	        fast: 200,
	        // Default speed
	        _default: 400
	    };

	    // Based off of the plugin by Clint Helfers, with permission.
	    // http://blindsignals.com/index.php/2009/07/jquery-delay/
	    jQuery.fn.delay = function (time, type) {
	        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
	        type = type || "fx";

	        return this.queue(type, function (next, hooks) {
	            var timeout = setTimeout(next, time);
	            hooks.stop = function () {
	                clearTimeout(timeout);
	            };
	        });
	    };

	    (function () {
	        var input = document.createElement("input"),
	            select = document.createElement("select"),
	            opt = select.appendChild(document.createElement("option"));

	        input.type = "checkbox";

	        // Support: iOS 5.1, Android 4.x, Android 2.3
	        // Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	        support.checkOn = input.value !== "";

	        // Must access the parent to make an option select properly
	        // Support: IE9, IE10
	        support.optSelected = opt.selected;

	        // Make sure that the options inside disabled selects aren't marked as disabled
	        // (WebKit marks them as disabled)
	        select.disabled = true;
	        support.optDisabled = !opt.disabled;

	        // Check if an input maintains its value after becoming a radio
	        // Support: IE9, IE10
	        input = document.createElement("input");
	        input.value = "t";
	        input.type = "radio";
	        support.radioValue = input.value === "t";
	    })();

	    var nodeHook,
	        boolHook,
	        attrHandle = jQuery.expr.attrHandle;

	    jQuery.fn.extend({
	        attr: function attr(name, value) {
	            return access(this, jQuery.attr, name, value, arguments.length > 1);
	        },

	        removeAttr: function removeAttr(name) {
	            return this.each(function () {
	                jQuery.removeAttr(this, name);
	            });
	        }
	    });

	    jQuery.extend({
	        attr: function attr(elem, name, value) {
	            var hooks,
	                ret,
	                nType = elem.nodeType;

	            // don't get/set attributes on text, comment and attribute nodes
	            if (!elem || nType === 3 || nType === 8 || nType === 2) {
	                return;
	            }

	            // Fallback to prop when attributes are not supported
	            if (_typeof(elem.getAttribute) === strundefined) {
	                return jQuery.prop(elem, name, value);
	            }

	            // All attributes are lowercase
	            // Grab necessary hook if one is defined
	            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	                name = name.toLowerCase();
	                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
	            }

	            if (value !== undefined) {

	                if (value === null) {
	                    jQuery.removeAttr(elem, name);
	                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	                    return ret;
	                } else {
	                    elem.setAttribute(name, value + "");
	                    return value;
	                }
	            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	                return ret;
	            } else {
	                ret = jQuery.find.attr(elem, name);

	                // Non-existent attributes return null, we normalize to undefined
	                return ret == null ? undefined : ret;
	            }
	        },

	        removeAttr: function removeAttr(elem, value) {
	            var name,
	                propName,
	                i = 0,
	                attrNames = value && value.match(rnotwhite);

	            if (attrNames && elem.nodeType === 1) {
	                while (name = attrNames[i++]) {
	                    propName = jQuery.propFix[name] || name;

	                    // Boolean attributes get special treatment (#10870)
	                    if (jQuery.expr.match.bool.test(name)) {
	                        // Set corresponding property to false
	                        elem[propName] = false;
	                    }

	                    elem.removeAttribute(name);
	                }
	            }
	        },

	        attrHooks: {
	            type: {
	                set: function set(elem, value) {
	                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
	                        // Setting the type on a radio button after the value resets the value in IE6-9
	                        // Reset value to default in case type is set after value during creation
	                        var val = elem.value;
	                        elem.setAttribute("type", value);
	                        if (val) {
	                            elem.value = val;
	                        }
	                        return value;
	                    }
	                }
	            }
	        }
	    });

	    // Hooks for boolean attributes
	    boolHook = {
	        set: function set(elem, value, name) {
	            if (value === false) {
	                // Remove boolean attributes when set to false
	                jQuery.removeAttr(elem, name);
	            } else {
	                elem.setAttribute(name, name);
	            }
	            return name;
	        }
	    };
	    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
	        var getter = attrHandle[name] || jQuery.find.attr;

	        attrHandle[name] = function (elem, name, isXML) {
	            var ret, handle;
	            if (!isXML) {
	                // Avoid an infinite loop by temporarily removing this function from the getter
	                handle = attrHandle[name];
	                attrHandle[name] = ret;
	                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
	                attrHandle[name] = handle;
	            }
	            return ret;
	        };
	    });

	    var rfocusable = /^(?:input|select|textarea|button)$/i;

	    jQuery.fn.extend({
	        prop: function prop(name, value) {
	            return access(this, jQuery.prop, name, value, arguments.length > 1);
	        },

	        removeProp: function removeProp(name) {
	            return this.each(function () {
	                delete this[jQuery.propFix[name] || name];
	            });
	        }
	    });

	    jQuery.extend({
	        propFix: {
	            "for": "htmlFor",
	            "class": "className"
	        },

	        prop: function prop(elem, name, value) {
	            var ret,
	                hooks,
	                notxml,
	                nType = elem.nodeType;

	            // don't get/set properties on text, comment and attribute nodes
	            if (!elem || nType === 3 || nType === 8 || nType === 2) {
	                return;
	            }

	            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

	            if (notxml) {
	                // Fix name and attach hooks
	                name = jQuery.propFix[name] || name;
	                hooks = jQuery.propHooks[name];
	            }

	            if (value !== undefined) {
	                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
	            } else {
	                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
	            }
	        },

	        propHooks: {
	            tabIndex: {
	                get: function get(elem) {
	                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
	                }
	            }
	        }
	    });

	    // Support: IE9+
	    // Selectedness for an option in an optgroup can be inaccurate
	    if (!support.optSelected) {
	        jQuery.propHooks.selected = {
	            get: function get(elem) {
	                var parent = elem.parentNode;
	                if (parent && parent.parentNode) {
	                    parent.parentNode.selectedIndex;
	                }
	                return null;
	            }
	        };
	    }

	    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	        jQuery.propFix[this.toLowerCase()] = this;
	    });

	    var rclass = /[\t\r\n\f]/g;

	    jQuery.fn.extend({
	        addClass: function addClass(value) {
	            var classes,
	                elem,
	                cur,
	                clazz,
	                j,
	                finalValue,
	                proceed = typeof value === "string" && value,
	                i = 0,
	                len = this.length;

	            if (jQuery.isFunction(value)) {
	                return this.each(function (j) {
	                    jQuery(this).addClass(value.call(this, j, this.className));
	                });
	            }

	            if (proceed) {
	                // The disjunction here is for better compressibility (see removeClass)
	                classes = (value || "").match(rnotwhite) || [];

	                for (; i < len; i++) {
	                    elem = this[i];
	                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");

	                    if (cur) {
	                        j = 0;
	                        while (clazz = classes[j++]) {
	                            if (cur.indexOf(" " + clazz + " ") < 0) {
	                                cur += clazz + " ";
	                            }
	                        }

	                        // only assign if different to avoid unneeded rendering.
	                        finalValue = jQuery.trim(cur);
	                        if (elem.className !== finalValue) {
	                            elem.className = finalValue;
	                        }
	                    }
	                }
	            }

	            return this;
	        },

	        removeClass: function removeClass(value) {
	            var classes,
	                elem,
	                cur,
	                clazz,
	                j,
	                finalValue,
	                proceed = arguments.length === 0 || typeof value === "string" && value,
	                i = 0,
	                len = this.length;

	            if (jQuery.isFunction(value)) {
	                return this.each(function (j) {
	                    jQuery(this).removeClass(value.call(this, j, this.className));
	                });
	            }
	            if (proceed) {
	                classes = (value || "").match(rnotwhite) || [];

	                for (; i < len; i++) {
	                    elem = this[i];
	                    // This expression is here for better compressibility (see addClass)
	                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");

	                    if (cur) {
	                        j = 0;
	                        while (clazz = classes[j++]) {
	                            // Remove *all* instances
	                            while (cur.indexOf(" " + clazz + " ") >= 0) {
	                                cur = cur.replace(" " + clazz + " ", " ");
	                            }
	                        }

	                        // only assign if different to avoid unneeded rendering.
	                        finalValue = value ? jQuery.trim(cur) : "";
	                        if (elem.className !== finalValue) {
	                            elem.className = finalValue;
	                        }
	                    }
	                }
	            }

	            return this;
	        },

	        toggleClass: function toggleClass(value, stateVal) {
	            var type = typeof value === "undefined" ? "undefined" : _typeof(value);

	            if (typeof stateVal === "boolean" && type === "string") {
	                return stateVal ? this.addClass(value) : this.removeClass(value);
	            }

	            if (jQuery.isFunction(value)) {
	                return this.each(function (i) {
	                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
	                });
	            }

	            return this.each(function () {
	                if (type === "string") {
	                    // toggle individual class names
	                    var className,
	                        i = 0,
	                        self = jQuery(this),
	                        classNames = value.match(rnotwhite) || [];

	                    while (className = classNames[i++]) {
	                        // check each className given, space separated list
	                        if (self.hasClass(className)) {
	                            self.removeClass(className);
	                        } else {
	                            self.addClass(className);
	                        }
	                    }

	                    // Toggle whole class name
	                } else if (type === strundefined || type === "boolean") {
	                    if (this.className) {
	                        // store className if set
	                        data_priv.set(this, "__className__", this.className);
	                    }

	                    // If the element has a class name or if we're passed "false",
	                    // then remove the whole classname (if there was one, the above saved it).
	                    // Otherwise bring back whatever was previously saved (if anything),
	                    // falling back to the empty string if nothing was stored.
	                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
	                }
	            });
	        },

	        hasClass: function hasClass(selector) {
	            var className = " " + selector + " ",
	                i = 0,
	                l = this.length;
	            for (; i < l; i++) {
	                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
	                    return true;
	                }
	            }

	            return false;
	        }
	    });

	    var rreturn = /\r/g;

	    jQuery.fn.extend({
	        val: function val(value) {
	            var hooks,
	                ret,
	                isFunction,
	                elem = this[0];

	            if (!arguments.length) {
	                if (elem) {
	                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

	                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
	                        return ret;
	                    }

	                    ret = elem.value;

	                    return typeof ret === "string" ?
	                    // handle most common string cases
	                    ret.replace(rreturn, "") :
	                    // handle cases where value is null/undef or number
	                    ret == null ? "" : ret;
	                }

	                return;
	            }

	            isFunction = jQuery.isFunction(value);

	            return this.each(function (i) {
	                var val;

	                if (this.nodeType !== 1) {
	                    return;
	                }

	                if (isFunction) {
	                    val = value.call(this, i, jQuery(this).val());
	                } else {
	                    val = value;
	                }

	                // Treat null/undefined as ""; convert numbers to string
	                if (val == null) {
	                    val = "";
	                } else if (typeof val === "number") {
	                    val += "";
	                } else if (jQuery.isArray(val)) {
	                    val = jQuery.map(val, function (value) {
	                        return value == null ? "" : value + "";
	                    });
	                }

	                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

	                // If set returns undefined, fall back to normal setting
	                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
	                    this.value = val;
	                }
	            });
	        }
	    });

	    jQuery.extend({
	        valHooks: {
	            select: {
	                get: function get(elem) {
	                    var value,
	                        option,
	                        options = elem.options,
	                        index = elem.selectedIndex,
	                        one = elem.type === "select-one" || index < 0,
	                        values = one ? null : [],
	                        max = one ? index + 1 : options.length,
	                        i = index < 0 ? max : one ? index : 0;

	                    // Loop through all the selected options
	                    for (; i < max; i++) {
	                        option = options[i];

	                        // IE6-9 doesn't update selected after form reset (#2551)
	                        if ((option.selected || i === index) && (
	                        // Don't return options that are disabled or in a disabled optgroup
	                        support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

	                            // Get the specific value for the option
	                            value = jQuery(option).val();

	                            // We don't need an array for one selects
	                            if (one) {
	                                return value;
	                            }

	                            // Multi-Selects return an array
	                            values.push(value);
	                        }
	                    }

	                    return values;
	                },

	                set: function set(elem, value) {
	                    var optionSet,
	                        option,
	                        options = elem.options,
	                        values = jQuery.makeArray(value),
	                        i = options.length;

	                    while (i--) {
	                        option = options[i];
	                        if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
	                            optionSet = true;
	                        }
	                    }

	                    // force browsers to behave consistently when non-matching value is set
	                    if (!optionSet) {
	                        elem.selectedIndex = -1;
	                    }
	                    return values;
	                }
	            }
	        }
	    });

	    // Radios and checkboxes getter/setter
	    jQuery.each(["radio", "checkbox"], function () {
	        jQuery.valHooks[this] = {
	            set: function set(elem, value) {
	                if (jQuery.isArray(value)) {
	                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
	                }
	            }
	        };
	        if (!support.checkOn) {
	            jQuery.valHooks[this].get = function (elem) {
	                // Support: Webkit
	                // "" is returned instead of "on" if a value isn't specified
	                return elem.getAttribute("value") === null ? "on" : elem.value;
	            };
	        }
	    });

	    // Return jQuery for attributes-only inclusion


	    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

	        // Handle event binding
	        jQuery.fn[name] = function (data, fn) {
	            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
	        };
	    });

	    jQuery.fn.extend({
	        hover: function hover(fnOver, fnOut) {
	            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
	        },

	        bind: function bind(types, data, fn) {
	            return this.on(types, null, data, fn);
	        },
	        unbind: function unbind(types, fn) {
	            return this.off(types, null, fn);
	        },

	        delegate: function delegate(selector, types, data, fn) {
	            return this.on(types, selector, data, fn);
	        },
	        undelegate: function undelegate(selector, types, fn) {
	            // ( namespace ) or ( selector, types [, fn] )
	            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
	        }
	    });

	    var nonce = jQuery.now();

	    var rquery = /\?/;

	    // Support: Android 2.3
	    // Workaround failure to string-cast null input
	    jQuery.parseJSON = function (data) {
	        return JSON.parse(data + "");
	    };

	    // Cross-browser xml parsing
	    jQuery.parseXML = function (data) {
	        var xml, tmp;
	        if (!data || typeof data !== "string") {
	            return null;
	        }

	        // Support: IE9
	        try {
	            tmp = new DOMParser();
	            xml = tmp.parseFromString(data, "text/xml");
	        } catch (e) {
	            xml = undefined;
	        }

	        if (!xml || xml.getElementsByTagName("parsererror").length) {
	            jQuery.error("Invalid XML: " + data);
	        }
	        return xml;
	    };

	    var
	    // Document location
	    ajaxLocParts,
	        ajaxLocation,
	        rhash = /#.*$/,
	        rts = /([?&])_=[^&]*/,
	        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	    // #7653, #8125, #8152: local protocol detection
	    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	        rnoContent = /^(?:GET|HEAD)$/,
	        rprotocol = /^\/\//,
	        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,


	    /* Prefilters
	     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	     * 2) These are called:
	     *    - BEFORE asking for a transport
	     *    - AFTER param serialization (s.data is a string if s.processData is true)
	     * 3) key is the dataType
	     * 4) the catchall symbol "*" can be used
	     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	     */
	    prefilters = {},


	    /* Transports bindings
	     * 1) key is the dataType
	     * 2) the catchall symbol "*" can be used
	     * 3) selection will start with transport dataType and THEN go to "*" if needed
	     */
	    transports = {},


	    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	    allTypes = "*/".concat("*");

	    // #8138, IE may throw an exception when accessing
	    // a field from window.location if document.domain has been set
	    try {
	        ajaxLocation = location.href;
	    } catch (e) {
	        // Use the href attribute of an A element
	        // since IE will modify it given document.location
	        ajaxLocation = document.createElement("a");
	        ajaxLocation.href = "";
	        ajaxLocation = ajaxLocation.href;
	    }

	    // Segment location into parts
	    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

	    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	    function addToPrefiltersOrTransports(structure) {

	        // dataTypeExpression is optional and defaults to "*"
	        return function (dataTypeExpression, func) {

	            if (typeof dataTypeExpression !== "string") {
	                func = dataTypeExpression;
	                dataTypeExpression = "*";
	            }

	            var dataType,
	                i = 0,
	                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

	            if (jQuery.isFunction(func)) {
	                // For each dataType in the dataTypeExpression
	                while (dataType = dataTypes[i++]) {
	                    // Prepend if requested
	                    if (dataType[0] === "+") {
	                        dataType = dataType.slice(1) || "*";
	                        (structure[dataType] = structure[dataType] || []).unshift(func);

	                        // Otherwise append
	                    } else {
	                        (structure[dataType] = structure[dataType] || []).push(func);
	                    }
	                }
	            }
	        };
	    }

	    // Base inspection function for prefilters and transports
	    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

	        var inspected = {},
	            seekingTransport = structure === transports;

	        function inspect(dataType) {
	            var selected;
	            inspected[dataType] = true;
	            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
	                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
	                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
	                    options.dataTypes.unshift(dataTypeOrTransport);
	                    inspect(dataTypeOrTransport);
	                    return false;
	                } else if (seekingTransport) {
	                    return !(selected = dataTypeOrTransport);
	                }
	            });
	            return selected;
	        }

	        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	    }

	    // A special extend for ajax options
	    // that takes "flat" options (not to be deep extended)
	    // Fixes #9887
	    function ajaxExtend(target, src) {
	        var key,
	            deep,
	            flatOptions = jQuery.ajaxSettings.flatOptions || {};

	        for (key in src) {
	            if (src[key] !== undefined) {
	                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
	            }
	        }
	        if (deep) {
	            jQuery.extend(true, target, deep);
	        }

	        return target;
	    }

	    /* Handles responses to an ajax request:
	     * - finds the right dataType (mediates between content-type and expected dataType)
	     * - returns the corresponding response
	     */
	    function ajaxHandleResponses(s, jqXHR, responses) {

	        var ct,
	            type,
	            finalDataType,
	            firstDataType,
	            contents = s.contents,
	            dataTypes = s.dataTypes;

	        // Remove auto dataType and get content-type in the process
	        while (dataTypes[0] === "*") {
	            dataTypes.shift();
	            if (ct === undefined) {
	                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
	            }
	        }

	        // Check if we're dealing with a known content-type
	        if (ct) {
	            for (type in contents) {
	                if (contents[type] && contents[type].test(ct)) {
	                    dataTypes.unshift(type);
	                    break;
	                }
	            }
	        }

	        // Check to see if we have a response for the expected dataType
	        if (dataTypes[0] in responses) {
	            finalDataType = dataTypes[0];
	        } else {
	            // Try convertible dataTypes
	            for (type in responses) {
	                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
	                    finalDataType = type;
	                    break;
	                }
	                if (!firstDataType) {
	                    firstDataType = type;
	                }
	            }
	            // Or just use first one
	            finalDataType = finalDataType || firstDataType;
	        }

	        // If we found a dataType
	        // We add the dataType to the list if needed
	        // and return the corresponding response
	        if (finalDataType) {
	            if (finalDataType !== dataTypes[0]) {
	                dataTypes.unshift(finalDataType);
	            }
	            return responses[finalDataType];
	        }
	    }

	    /* Chain conversions given the request and the original response
	     * Also sets the responseXXX fields on the jqXHR instance
	     */
	    function ajaxConvert(s, response, jqXHR, isSuccess) {
	        var conv2,
	            current,
	            conv,
	            tmp,
	            prev,
	            converters = {},

	        // Work with a copy of dataTypes in case we need to modify it for conversion
	        dataTypes = s.dataTypes.slice();

	        // Create converters map with lowercased keys
	        if (dataTypes[1]) {
	            for (conv in s.converters) {
	                converters[conv.toLowerCase()] = s.converters[conv];
	            }
	        }

	        current = dataTypes.shift();

	        // Convert to each sequential dataType
	        while (current) {

	            if (s.responseFields[current]) {
	                jqXHR[s.responseFields[current]] = response;
	            }

	            // Apply the dataFilter if provided
	            if (!prev && isSuccess && s.dataFilter) {
	                response = s.dataFilter(response, s.dataType);
	            }

	            prev = current;
	            current = dataTypes.shift();

	            if (current) {

	                // There's only work to do if current dataType is non-auto
	                if (current === "*") {

	                    current = prev;

	                    // Convert response if prev dataType is non-auto and differs from current
	                } else if (prev !== "*" && prev !== current) {

	                    // Seek a direct converter
	                    conv = converters[prev + " " + current] || converters["* " + current];

	                    // If none found, seek a pair
	                    if (!conv) {
	                        for (conv2 in converters) {

	                            // If conv2 outputs current
	                            tmp = conv2.split(" ");
	                            if (tmp[1] === current) {

	                                // If prev can be converted to accepted input
	                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
	                                if (conv) {
	                                    // Condense equivalence converters
	                                    if (conv === true) {
	                                        conv = converters[conv2];

	                                        // Otherwise, insert the intermediate dataType
	                                    } else if (converters[conv2] !== true) {
	                                        current = tmp[0];
	                                        dataTypes.unshift(tmp[1]);
	                                    }
	                                    break;
	                                }
	                            }
	                        }
	                    }

	                    // Apply converter (if not an equivalence)
	                    if (conv !== true) {

	                        // Unless errors are allowed to bubble, catch and return them
	                        if (conv && s["throws"]) {
	                            response = conv(response);
	                        } else {
	                            try {
	                                response = conv(response);
	                            } catch (e) {
	                                return {
	                                    state: "parsererror",
	                                    error: conv ? e : "No conversion from " + prev + " to " + current
	                                };
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        return {
	            state: "success",
	            data: response
	        };
	    }

	    jQuery.extend({

	        // Counter for holding the number of active queries
	        active: 0,

	        // Last-Modified header cache for next request
	        lastModified: {},
	        etag: {},

	        ajaxSettings: {
	            url: ajaxLocation,
	            type: "GET",
	            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
	            global: true,
	            processData: true,
	            async: true,
	            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	            /*
	             timeout: 0,
	             data: null,
	             dataType: null,
	             username: null,
	             password: null,
	             cache: null,
	             throws: false,
	             traditional: false,
	             headers: {},
	             */

	            accepts: {
	                "*": allTypes,
	                text: "text/plain",
	                html: "text/html",
	                xml: "application/xml, text/xml",
	                json: "application/json, text/javascript"
	            },

	            contents: {
	                xml: /xml/,
	                html: /html/,
	                json: /json/
	            },

	            responseFields: {
	                xml: "responseXML",
	                text: "responseText",
	                json: "responseJSON"
	            },

	            // Data converters
	            // Keys separate source (or catchall "*") and destination types with a single space
	            converters: {

	                // Convert anything to text
	                "* text": String,

	                // Text to html (true = no transformation)
	                "text html": true,

	                // Evaluate text as a json expression
	                "text json": jQuery.parseJSON,

	                // Parse text as xml
	                "text xml": jQuery.parseXML
	            },

	            // For options that shouldn't be deep extended:
	            // you can add your own custom options here if
	            // and when you create one that shouldn't be
	            // deep extended (see ajaxExtend)
	            flatOptions: {
	                url: true,
	                context: true
	            }
	        },

	        // Creates a full fledged settings object into target
	        // with both ajaxSettings and settings fields.
	        // If target is omitted, writes into ajaxSettings.
	        ajaxSetup: function ajaxSetup(target, settings) {
	            return settings ?

	            // Building a settings object
	            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

	            // Extending ajaxSettings
	            ajaxExtend(jQuery.ajaxSettings, target);
	        },

	        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
	        ajaxTransport: addToPrefiltersOrTransports(transports),

	        // Main method
	        ajax: function ajax(url, options) {

	            // If url is an object, simulate pre-1.5 signature
	            if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
	                options = url;
	                url = undefined;
	            }

	            // Force options to be an object
	            options = options || {};

	            var transport,

	            // URL without anti-cache param
	            cacheURL,

	            // Response headers
	            responseHeadersString,
	                responseHeaders,

	            // timeout handle
	            timeoutTimer,

	            // Cross-domain detection vars
	            parts,

	            // To know if global events are to be dispatched
	            fireGlobals,

	            // Loop variable
	            i,

	            // Create the final options object
	            s = jQuery.ajaxSetup({}, options),

	            // Callbacks context
	            callbackContext = s.context || s,

	            // Context for global events is callbackContext if it is a DOM node or jQuery collection
	            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,

	            // Deferreds
	            deferred = jQuery.Deferred(),
	                completeDeferred = jQuery.Callbacks("once memory"),

	            // Status-dependent callbacks
	            _statusCode = s.statusCode || {},

	            // Headers (they are sent all at once)
	            requestHeaders = {},
	                requestHeadersNames = {},

	            // The jqXHR state
	            state = 0,

	            // Default abort message
	            strAbort = "canceled",

	            // Fake xhr
	            jqXHR = {
	                readyState: 0,

	                // Builds headers hashtable if needed
	                getResponseHeader: function getResponseHeader(key) {
	                    var match;
	                    if (state === 2) {
	                        if (!responseHeaders) {
	                            responseHeaders = {};
	                            while (match = rheaders.exec(responseHeadersString)) {
	                                responseHeaders[match[1].toLowerCase()] = match[2];
	                            }
	                        }
	                        match = responseHeaders[key.toLowerCase()];
	                    }
	                    return match == null ? null : match;
	                },

	                // Raw string
	                getAllResponseHeaders: function getAllResponseHeaders() {
	                    return state === 2 ? responseHeadersString : null;
	                },

	                // Caches the header
	                setRequestHeader: function setRequestHeader(name, value) {
	                    var lname = name.toLowerCase();
	                    if (!state) {
	                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
	                        requestHeaders[name] = value;
	                    }
	                    return this;
	                },

	                // Overrides response content-type header
	                overrideMimeType: function overrideMimeType(type) {
	                    if (!state) {
	                        s.mimeType = type;
	                    }
	                    return this;
	                },

	                // Status-dependent callbacks
	                statusCode: function statusCode(map) {
	                    var code;
	                    if (map) {
	                        if (state < 2) {
	                            for (code in map) {
	                                // Lazy-add the new callback in a way that preserves old ones
	                                _statusCode[code] = [_statusCode[code], map[code]];
	                            }
	                        } else {
	                            // Execute the appropriate callbacks
	                            jqXHR.always(map[jqXHR.status]);
	                        }
	                    }
	                    return this;
	                },

	                // Cancel the request
	                abort: function abort(statusText) {
	                    var finalText = statusText || strAbort;
	                    if (transport) {
	                        transport.abort(finalText);
	                    }
	                    done(0, finalText);
	                    return this;
	                }
	            };

	            // Attach deferreds
	            deferred.promise(jqXHR).complete = completeDeferred.add;
	            jqXHR.success = jqXHR.done;
	            jqXHR.error = jqXHR.fail;

	            // Remove hash character (#7531: and string promotion)
	            // Add protocol if not provided (prefilters might expect it)
	            // Handle falsy url in the settings object (#10093: consistency with old signature)
	            // We also use the url parameter if available
	            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

	            // Alias method option to type as per ticket #12004
	            s.type = options.method || options.type || s.method || s.type;

	            // Extract dataTypes list
	            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

	            // A cross-domain request is in order when we have a protocol:host:port mismatch
	            if (s.crossDomain == null) {
	                parts = rurl.exec(s.url.toLowerCase());
	                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
	            }

	            // Convert data if not already a string
	            if (s.data && s.processData && typeof s.data !== "string") {
	                s.data = jQuery.param(s.data, s.traditional);
	            }

	            // Apply prefilters
	            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

	            // If request was aborted inside a prefilter, stop there
	            if (state === 2) {
	                return jqXHR;
	            }

	            // We can fire global events as of now if asked to
	            fireGlobals = s.global;

	            // Watch for a new set of requests
	            if (fireGlobals && jQuery.active++ === 0) {
	                jQuery.event.trigger("ajaxStart");
	            }

	            // Uppercase the type
	            s.type = s.type.toUpperCase();

	            // Determine if request has content
	            s.hasContent = !rnoContent.test(s.type);

	            // Save the URL in case we're toying with the If-Modified-Since
	            // and/or If-None-Match header later on
	            cacheURL = s.url;

	            // More options handling for requests with no content
	            if (!s.hasContent) {

	                // If data is available, append data to url
	                if (s.data) {
	                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
	                    // #9682: remove data so that it's not used in an eventual retry
	                    delete s.data;
	                }

	                // Add anti-cache in url if needed
	                if (s.cache === false) {
	                    s.url = rts.test(cacheURL) ?

	                    // If there is already a '_' parameter, set its value
	                    cacheURL.replace(rts, "$1_=" + nonce++) :

	                    // Otherwise add one to the end
	                    cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
	                }
	            }

	            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	            if (s.ifModified) {
	                if (jQuery.lastModified[cacheURL]) {
	                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
	                }
	                if (jQuery.etag[cacheURL]) {
	                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
	                }
	            }

	            // Set the correct header, if data is being sent
	            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
	                jqXHR.setRequestHeader("Content-Type", s.contentType);
	            }

	            // Set the Accepts header for the server, depending on the dataType
	            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

	            // Check for headers option
	            for (i in s.headers) {
	                jqXHR.setRequestHeader(i, s.headers[i]);
	            }

	            // Allow custom headers/mimetypes and early abort
	            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
	                // Abort if not done already and return
	                return jqXHR.abort();
	            }

	            // aborting is no longer a cancellation
	            strAbort = "abort";

	            // Install callbacks on deferreds
	            for (i in {
	                success: 1,
	                error: 1,
	                complete: 1
	            }) {
	                jqXHR[i](s[i]);
	            }

	            // Get transport
	            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

	            // If no transport, we auto-abort
	            if (!transport) {
	                done(-1, "No Transport");
	            } else {
	                jqXHR.readyState = 1;

	                // Send global event
	                if (fireGlobals) {
	                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
	                }
	                // Timeout
	                if (s.async && s.timeout > 0) {
	                    timeoutTimer = setTimeout(function () {
	                        jqXHR.abort("timeout");
	                    }, s.timeout);
	                }

	                try {
	                    state = 1;
	                    transport.send(requestHeaders, done);
	                } catch (e) {
	                    // Propagate exception as error if not done
	                    if (state < 2) {
	                        done(-1, e);
	                        // Simply rethrow otherwise
	                    } else {
	                        throw e;
	                    }
	                }
	            }

	            // Callback for when everything is done
	            function done(status, nativeStatusText, responses, headers) {
	                var isSuccess,
	                    success,
	                    error,
	                    response,
	                    modified,
	                    statusText = nativeStatusText;

	                // Called once
	                if (state === 2) {
	                    return;
	                }

	                // State is "done" now
	                state = 2;

	                // Clear timeout if it exists
	                if (timeoutTimer) {
	                    clearTimeout(timeoutTimer);
	                }

	                // Dereference transport for early garbage collection
	                // (no matter how long the jqXHR object will be used)
	                transport = undefined;

	                // Cache response headers
	                responseHeadersString = headers || "";

	                // Set readyState
	                jqXHR.readyState = status > 0 ? 4 : 0;

	                // Determine if successful
	                isSuccess = status >= 200 && status < 300 || status === 304;

	                // Get response data
	                if (responses) {
	                    response = ajaxHandleResponses(s, jqXHR, responses);
	                }

	                // Convert no matter what (that way responseXXX fields are always set)
	                response = ajaxConvert(s, response, jqXHR, isSuccess);

	                // If successful, handle type chaining
	                if (isSuccess) {

	                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	                    if (s.ifModified) {
	                        modified = jqXHR.getResponseHeader("Last-Modified");
	                        if (modified) {
	                            jQuery.lastModified[cacheURL] = modified;
	                        }
	                        modified = jqXHR.getResponseHeader("etag");
	                        if (modified) {
	                            jQuery.etag[cacheURL] = modified;
	                        }
	                    }

	                    // if no content
	                    if (status === 204 || s.type === "HEAD") {
	                        statusText = "nocontent";

	                        // if not modified
	                    } else if (status === 304) {
	                        statusText = "notmodified";

	                        // If we have data, let's convert it
	                    } else {
	                        statusText = response.state;
	                        success = response.data;
	                        error = response.error;
	                        isSuccess = !error;
	                    }
	                } else {
	                    // We extract error from statusText
	                    // then normalize statusText and status for non-aborts
	                    error = statusText;
	                    if (status || !statusText) {
	                        statusText = "error";
	                        if (status < 0) {
	                            status = 0;
	                        }
	                    }
	                }

	                // Set data for the fake xhr object
	                jqXHR.status = status;
	                jqXHR.statusText = (nativeStatusText || statusText) + "";

	                // Success/Error
	                if (isSuccess) {
	                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
	                } else {
	                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
	                }

	                // Status-dependent callbacks
	                jqXHR.statusCode(_statusCode);
	                _statusCode = undefined;

	                if (fireGlobals) {
	                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
	                }

	                // Complete
	                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

	                if (fireGlobals) {
	                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
	                    // Handle the global AJAX counter
	                    if (! --jQuery.active) {
	                        jQuery.event.trigger("ajaxStop");
	                    }
	                }
	            }

	            return jqXHR;
	        },

	        getJSON: function getJSON(url, data, callback) {
	            return jQuery.get(url, data, callback, "json");
	        },

	        getScript: function getScript(url, callback) {
	            return jQuery.get(url, undefined, callback, "script");
	        }
	    });

	    jQuery.each(["get", "post"], function (i, method) {
	        jQuery[method] = function (url, data, callback, type) {
	            // shift arguments if data argument was omitted
	            if (jQuery.isFunction(data)) {
	                type = type || callback;
	                callback = data;
	                data = undefined;
	            }

	            return jQuery.ajax({
	                url: url,
	                type: method,
	                dataType: type,
	                data: data,
	                success: callback
	            });
	        };
	    });

	    // Attach a bunch of functions for handling common AJAX events
	    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
	        jQuery.fn[type] = function (fn) {
	            return this.on(type, fn);
	        };
	    });

	    jQuery._evalUrl = function (url) {
	        return jQuery.ajax({
	            url: url,
	            type: "GET",
	            dataType: "script",
	            async: false,
	            global: false,
	            "throws": true
	        });
	    };

	    jQuery.fn.extend({
	        wrapAll: function wrapAll(html) {
	            var wrap;

	            if (jQuery.isFunction(html)) {
	                return this.each(function (i) {
	                    jQuery(this).wrapAll(html.call(this, i));
	                });
	            }

	            if (this[0]) {

	                // The elements to wrap the target around
	                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

	                if (this[0].parentNode) {
	                    wrap.insertBefore(this[0]);
	                }

	                wrap.map(function () {
	                    var elem = this;

	                    while (elem.firstElementChild) {
	                        elem = elem.firstElementChild;
	                    }

	                    return elem;
	                }).append(this);
	            }

	            return this;
	        },

	        wrapInner: function wrapInner(html) {
	            if (jQuery.isFunction(html)) {
	                return this.each(function (i) {
	                    jQuery(this).wrapInner(html.call(this, i));
	                });
	            }

	            return this.each(function () {
	                var self = jQuery(this),
	                    contents = self.contents();

	                if (contents.length) {
	                    contents.wrapAll(html);
	                } else {
	                    self.append(html);
	                }
	            });
	        },

	        wrap: function wrap(html) {
	            var isFunction = jQuery.isFunction(html);

	            return this.each(function (i) {
	                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
	            });
	        },

	        unwrap: function unwrap() {
	            return this.parent().each(function () {
	                if (!jQuery.nodeName(this, "body")) {
	                    jQuery(this).replaceWith(this.childNodes);
	                }
	            }).end();
	        }
	    });

	    jQuery.expr.filters.hidden = function (elem) {
	        // Support: Opera <= 12.12
	        // Opera reports offsetWidths and offsetHeights less than zero on some elements
	        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	    };
	    jQuery.expr.filters.visible = function (elem) {
	        return !jQuery.expr.filters.hidden(elem);
	    };

	    var r20 = /%20/g,
	        rbracket = /\[\]$/,
	        rCRLF = /\r?\n/g,
	        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	        rsubmittable = /^(?:input|select|textarea|keygen)/i;

	    function buildParams(prefix, obj, traditional, add) {
	        var name;

	        if (jQuery.isArray(obj)) {
	            // Serialize array item.
	            jQuery.each(obj, function (i, v) {
	                if (traditional || rbracket.test(prefix)) {
	                    // Treat each array item as a scalar.
	                    add(prefix, v);
	                } else {
	                    // Item is non-scalar (array or object), encode its numeric index.
	                    buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" ? i : "") + "]", v, traditional, add);
	                }
	            });
	        } else if (!traditional && jQuery.type(obj) === "object") {
	            // Serialize object item.
	            for (name in obj) {
	                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
	            }
	        } else {
	            // Serialize scalar item.
	            add(prefix, obj);
	        }
	    }

	    // Serialize an array of form elements or a set of
	    // key/values into a query string
	    jQuery.param = function (a, traditional) {
	        var prefix,
	            s = [],
	            add = function add(key, value) {
	            // If value is a function, invoke it and return its value
	            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
	            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
	        };

	        // Set traditional to true for jQuery <= 1.3.2 behavior.
	        if (traditional === undefined) {
	            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	        }

	        // If an array was passed in, assume that it is an array of form elements.
	        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
	            // Serialize the form elements
	            jQuery.each(a, function () {
	                add(this.name, this.value);
	            });
	        } else {
	            // If traditional, encode the "old" way (the way 1.3.2 or older
	            // did it), otherwise encode params recursively.
	            for (prefix in a) {
	                buildParams(prefix, a[prefix], traditional, add);
	            }
	        }

	        // Return the resulting serialization
	        return s.join("&").replace(r20, "+");
	    };

	    jQuery.fn.extend({
	        serialize: function serialize() {
	            return jQuery.param(this.serializeArray());
	        },
	        serializeArray: function serializeArray() {
	            return this.map(function () {
	                // Can add propHook for "elements" to filter or add form elements
	                var elements = jQuery.prop(this, "elements");
	                return elements ? jQuery.makeArray(elements) : this;
	            }).filter(function () {
	                var type = this.type;

	                // Use .is( ":disabled" ) so that fieldset[disabled] works
	                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
	            }).map(function (i, elem) {
	                var val = jQuery(this).val();

	                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
	                    return {
	                        name: elem.name,
	                        value: val.replace(rCRLF, "\r\n")
	                    };
	                }) : {
	                    name: elem.name,
	                    value: val.replace(rCRLF, "\r\n")
	                };
	            }).get();
	        }
	    });

	    jQuery.ajaxSettings.xhr = function () {
	        try {
	            return new XMLHttpRequest();
	        } catch (e) {}
	    };

	    var xhrId = 0,
	        xhrCallbacks = {},
	        xhrSuccessStatus = {
	        // file protocol always yields status code 0, assume 200
	        0: 200,
	        // Support: IE9
	        // #1450: sometimes IE returns 1223 when it should be 204
	        1223: 204
	    },
	        xhrSupported = jQuery.ajaxSettings.xhr();

	    // Support: IE9
	    // Open requests must be manually aborted on unload (#5280)
	    if (window.ActiveXObject) {
	        jQuery(window).on("unload", function () {
	            for (var key in xhrCallbacks) {
	                xhrCallbacks[key]();
	            }
	        });
	    }

	    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	    support.ajax = xhrSupported = !!xhrSupported;

	    jQuery.ajaxTransport(function (options) {
	        var _callback;

	        // Cross domain only allowed if supported through XMLHttpRequest
	        if (support.cors || xhrSupported && !options.crossDomain) {
	            return {
	                send: function send(headers, complete) {
	                    var i,
	                        xhr = options.xhr(),
	                        id = ++xhrId;

	                    xhr.open(options.type, options.url, options.async, options.username, options.password);

	                    // Apply custom fields if provided
	                    if (options.xhrFields) {
	                        for (i in options.xhrFields) {
	                            xhr[i] = options.xhrFields[i];
	                        }
	                    }

	                    // Override mime type if needed
	                    if (options.mimeType && xhr.overrideMimeType) {
	                        xhr.overrideMimeType(options.mimeType);
	                    }

	                    // X-Requested-With header
	                    // For cross-domain requests, seeing as conditions for a preflight are
	                    // akin to a jigsaw puzzle, we simply never set it to be sure.
	                    // (it can always be set on a per-request basis or even using ajaxSetup)
	                    // For same-domain requests, won't change header if already provided.
	                    if (!options.crossDomain && !headers["X-Requested-With"]) {
	                        headers["X-Requested-With"] = "XMLHttpRequest";
	                    }

	                    // Set headers
	                    for (i in headers) {
	                        xhr.setRequestHeader(i, headers[i]);
	                    }

	                    // Callback
	                    _callback = function callback(type) {
	                        return function () {
	                            if (_callback) {
	                                delete xhrCallbacks[id];
	                                _callback = xhr.onload = xhr.onerror = null;

	                                if (type === "abort") {
	                                    xhr.abort();
	                                } else if (type === "error") {
	                                    complete(
	                                    // file: protocol always yields status 0; see #8605, #14207
	                                    xhr.status, xhr.statusText);
	                                } else {
	                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,
	                                    // Support: IE9
	                                    // Accessing binary-data responseText throws an exception
	                                    // (#11426)
	                                    typeof xhr.responseText === "string" ? {
	                                        text: xhr.responseText
	                                    } : undefined, xhr.getAllResponseHeaders());
	                                }
	                            }
	                        };
	                    };

	                    // Listen to events
	                    xhr.onload = _callback();
	                    xhr.onerror = _callback("error");

	                    // Create the abort callback
	                    _callback = xhrCallbacks[id] = _callback("abort");

	                    // Do send the request
	                    // This may raise an exception which is actually
	                    // handled in jQuery.ajax (so no try/catch here)
	                    xhr.send(options.hasContent && options.data || null);
	                },

	                abort: function abort() {
	                    if (_callback) {
	                        _callback();
	                    }
	                }
	            };
	        }
	    });

	    // Install script dataType
	    jQuery.ajaxSetup({
	        accepts: {
	            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	        },
	        contents: {
	            script: /(?:java|ecma)script/
	        },
	        converters: {
	            "text script": function textScript(text) {
	                jQuery.globalEval(text);
	                return text;
	            }
	        }
	    });

	    // Handle cache's special case and crossDomain
	    jQuery.ajaxPrefilter("script", function (s) {
	        if (s.cache === undefined) {
	            s.cache = false;
	        }
	        if (s.crossDomain) {
	            s.type = "GET";
	        }
	    });

	    // Bind script tag hack transport
	    jQuery.ajaxTransport("script", function (s) {
	        // This transport only deals with cross domain requests
	        if (s.crossDomain) {
	            var script, _callback2;
	            return {
	                send: function send(_, complete) {
	                    script = jQuery("<script>").prop({
	                        async: true,
	                        charset: s.scriptCharset,
	                        src: s.url
	                    }).on("load error", _callback2 = function callback(evt) {
	                        script.remove();
	                        _callback2 = null;
	                        if (evt) {
	                            complete(evt.type === "error" ? 404 : 200, evt.type);
	                        }
	                    });
	                    document.head.appendChild(script[0]);
	                },
	                abort: function abort() {
	                    if (_callback2) {
	                        _callback2();
	                    }
	                }
	            };
	        }
	    });

	    var oldCallbacks = [],
	        rjsonp = /(=)\?(?=&|$)|\?\?/;

	    // Default jsonp settings
	    jQuery.ajaxSetup({
	        jsonp: "callback",
	        jsonpCallback: function jsonpCallback() {
	            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
	            this[callback] = true;
	            return callback;
	        }
	    });

	    // Detect, normalize options and install callbacks for jsonp requests
	    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

	        var callbackName,
	            overwritten,
	            responseContainer,
	            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");

	        // Handle iff the expected data type is "jsonp" or we have a parameter to set
	        if (jsonProp || s.dataTypes[0] === "jsonp") {

	            // Get callback name, remembering preexisting value associated with it
	            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

	            // Insert callback into url or form data
	            if (jsonProp) {
	                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
	            } else if (s.jsonp !== false) {
	                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
	            }

	            // Use data converter to retrieve json after script execution
	            s.converters["script json"] = function () {
	                if (!responseContainer) {
	                    jQuery.error(callbackName + " was not called");
	                }
	                return responseContainer[0];
	            };

	            // force json dataType
	            s.dataTypes[0] = "json";

	            // Install callback
	            overwritten = window[callbackName];
	            window[callbackName] = function () {
	                responseContainer = arguments;
	            };

	            // Clean-up function (fires after converters)
	            jqXHR.always(function () {
	                // Restore preexisting value
	                window[callbackName] = overwritten;

	                // Save back as free
	                if (s[callbackName]) {
	                    // make sure that re-using the options doesn't screw things around
	                    s.jsonpCallback = originalSettings.jsonpCallback;

	                    // save the callback name for future use
	                    oldCallbacks.push(callbackName);
	                }

	                // Call if it was a function and we have a response
	                if (responseContainer && jQuery.isFunction(overwritten)) {
	                    overwritten(responseContainer[0]);
	                }

	                responseContainer = overwritten = undefined;
	            });

	            // Delegate to script
	            return "script";
	        }
	    });

	    // data: string of html
	    // context (optional): If specified, the fragment will be created in this context, defaults to document
	    // keepScripts (optional): If true, will include scripts passed in the html string
	    jQuery.parseHTML = function (data, context, keepScripts) {
	        if (!data || typeof data !== "string") {
	            return null;
	        }
	        if (typeof context === "boolean") {
	            keepScripts = context;
	            context = false;
	        }
	        context = context || document;

	        var parsed = rsingleTag.exec(data),
	            scripts = !keepScripts && [];

	        // Single tag
	        if (parsed) {
	            return [context.createElement(parsed[1])];
	        }

	        parsed = jQuery.buildFragment([data], context, scripts);

	        if (scripts && scripts.length) {
	            jQuery(scripts).remove();
	        }

	        return jQuery.merge([], parsed.childNodes);
	    };

	    // Keep a copy of the old load method
	    var _load = jQuery.fn.load;

	    /**
	     * Load a url into a page
	     */
	    jQuery.fn.load = function (url, params, callback) {
	        if (typeof url !== "string" && _load) {
	            return _load.apply(this, arguments);
	        }

	        var selector,
	            type,
	            response,
	            self = this,
	            off = url.indexOf(" ");

	        if (off >= 0) {
	            selector = url.slice(off);
	            url = url.slice(0, off);
	        }

	        // If it's a function
	        if (jQuery.isFunction(params)) {

	            // We assume that it's the callback
	            callback = params;
	            params = undefined;

	            // Otherwise, build a param string
	        } else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
	            type = "POST";
	        }

	        // If we have elements to modify, make the request
	        if (self.length > 0) {
	            jQuery.ajax({
	                url: url,

	                // if "type" variable is undefined, then "GET" method will be used
	                type: type,
	                dataType: "html",
	                data: params
	            }).done(function (responseText) {

	                // Save response for use in complete callback
	                response = arguments;

	                self.html(selector ?

	                // If a selector was specified, locate the right elements in a dummy div
	                // Exclude scripts to avoid IE 'Permission Denied' errors
	                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

	                // Otherwise use the full result
	                responseText);
	            }).complete(callback && function (jqXHR, status) {
	                self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
	            });
	        }

	        return this;
	    };

	    jQuery.expr.filters.animated = function (elem) {
	        return jQuery.grep(jQuery.timers, function (fn) {
	            return elem === fn.elem;
	        }).length;
	    };

	    var docElem = window.document.documentElement;

	    /**
	     * Gets a window from an element
	     */
	    function getWindow(elem) {
	        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	    }

	    jQuery.offset = {
	        setOffset: function setOffset(elem, options, i) {
	            var curPosition,
	                curLeft,
	                curCSSTop,
	                curTop,
	                curOffset,
	                curCSSLeft,
	                calculatePosition,
	                position = jQuery.css(elem, "position"),
	                curElem = jQuery(elem),
	                props = {};

	            // Set position first, in-case top/left are set even on static elem
	            if (position === "static") {
	                elem.style.position = "relative";
	            }

	            curOffset = curElem.offset();
	            curCSSTop = jQuery.css(elem, "top");
	            curCSSLeft = jQuery.css(elem, "left");
	            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

	            // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
	            if (calculatePosition) {
	                curPosition = curElem.position();
	                curTop = curPosition.top;
	                curLeft = curPosition.left;
	            } else {
	                curTop = parseFloat(curCSSTop) || 0;
	                curLeft = parseFloat(curCSSLeft) || 0;
	            }

	            if (jQuery.isFunction(options)) {
	                options = options.call(elem, i, curOffset);
	            }

	            if (options.top != null) {
	                props.top = options.top - curOffset.top + curTop;
	            }
	            if (options.left != null) {
	                props.left = options.left - curOffset.left + curLeft;
	            }

	            if ("using" in options) {
	                options.using.call(elem, props);
	            } else {
	                curElem.css(props);
	            }
	        }
	    };

	    jQuery.fn.extend({
	        offset: function offset(options) {
	            if (arguments.length) {
	                return options === undefined ? this : this.each(function (i) {
	                    jQuery.offset.setOffset(this, options, i);
	                });
	            }

	            var docElem,
	                win,
	                elem = this[0],
	                box = {
	                top: 0,
	                left: 0
	            },
	                doc = elem && elem.ownerDocument;

	            if (!doc) {
	                return;
	            }

	            docElem = doc.documentElement;

	            // Make sure it's not a disconnected DOM node
	            if (!jQuery.contains(docElem, elem)) {
	                return box;
	            }

	            // If we don't have gBCR, just use 0,0 rather than error
	            // BlackBerry 5, iOS 3 (original iPhone)
	            if (_typeof(elem.getBoundingClientRect) !== strundefined) {
	                box = elem.getBoundingClientRect();
	            }
	            win = getWindow(doc);
	            return {
	                top: box.top + win.pageYOffset - docElem.clientTop,
	                left: box.left + win.pageXOffset - docElem.clientLeft
	            };
	        },

	        position: function position() {
	            if (!this[0]) {
	                return;
	            }

	            var offsetParent,
	                offset,
	                elem = this[0],
	                parentOffset = {
	                top: 0,
	                left: 0
	            };

	            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
	            if (jQuery.css(elem, "position") === "fixed") {
	                // We assume that getBoundingClientRect is available when computed position is fixed
	                offset = elem.getBoundingClientRect();
	            } else {
	                // Get *real* offsetParent
	                offsetParent = this.offsetParent();

	                // Get correct offsets
	                offset = this.offset();
	                if (!jQuery.nodeName(offsetParent[0], "html")) {
	                    parentOffset = offsetParent.offset();
	                }

	                // Add offsetParent borders
	                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
	                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
	            }

	            // Subtract parent offsets and element margins
	            return {
	                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
	                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
	            };
	        },

	        offsetParent: function offsetParent() {
	            return this.map(function () {
	                var offsetParent = this.offsetParent || docElem;

	                while (offsetParent && !jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static") {
	                    offsetParent = offsetParent.offsetParent;
	                }

	                return offsetParent || docElem;
	            });
	        }
	    });

	    // Create scrollLeft and scrollTop methods
	    jQuery.each({
	        scrollLeft: "pageXOffset",
	        scrollTop: "pageYOffset"
	    }, function (method, prop) {
	        var top = "pageYOffset" === prop;

	        jQuery.fn[method] = function (val) {
	            return access(this, function (elem, method, val) {
	                var win = getWindow(elem);

	                if (val === undefined) {
	                    return win ? win[prop] : elem[method];
	                }

	                if (win) {
	                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
	                } else {
	                    elem[method] = val;
	                }
	            }, method, val, arguments.length, null);
	        };
	    });

	    // Add the top/left cssHooks using jQuery.fn.position
	    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	    // getComputedStyle returns percent when specified for top/left/bottom/right
	    // rather than make the css module depend on the offset module, we just check for it here
	    jQuery.each(["top", "left"], function (i, prop) {
	        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
	            if (computed) {
	                computed = curCSS(elem, prop);
	                // if curCSS returns percentage, fallback to offset
	                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
	            }
	        });
	    });

	    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	    jQuery.each({
	        Height: "height",
	        Width: "width"
	    }, function (name, type) {
	        jQuery.each({
	            padding: "inner" + name,
	            content: type,
	            "": "outer" + name
	        }, function (defaultExtra, funcName) {
	            // margin is only for outerHeight, outerWidth
	            jQuery.fn[funcName] = function (margin, value) {
	                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
	                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

	                return access(this, function (elem, type, value) {
	                    var doc;

	                    if (jQuery.isWindow(elem)) {
	                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
	                        // isn't a whole lot we can do. See pull request at this URL for discussion:
	                        // https://github.com/jquery/jquery/pull/764
	                        return elem.document.documentElement["client" + name];
	                    }

	                    // Get document width or height
	                    if (elem.nodeType === 9) {
	                        doc = elem.documentElement;

	                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
	                        // whichever is greatest
	                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
	                    }

	                    return value === undefined ?
	                    // Get width or height on the element, requesting but not forcing parseFloat
	                    jQuery.css(elem, type, extra) :

	                    // Set width or height on the element
	                    jQuery.style(elem, type, value, extra);
	                }, type, chainable ? margin : undefined, chainable, null);
	            };
	        });
	    });

	    // The number of elements contained in the matched element set
	    jQuery.fn.size = function () {
	        return this.length;
	    };

	    jQuery.fn.andSelf = jQuery.fn.addBack;

	    // Register as a named AMD module, since jQuery can be concatenated with other
	    // files that may use define, but not via a proper concatenation script that
	    // understands anonymous AMD modules. A named AMD is safest and most robust
	    // way to register. Lowercase jquery is used because AMD module names are
	    // derived from file names, and jQuery is normally delivered in a lowercase
	    // file name. Do this after creating the global so that if an AMD module wants
	    // to call noConflict to hide this version of jQuery, it will work.
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return jQuery;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }

	    var
	    // Map over jQuery in case of overwrite
	    _jQuery = window.jQuery,


	    // Map over the $ in case of overwrite
	    _$ = window.$;

	    jQuery.noConflict = function (deep) {
	        if (window.$ === jQuery) {
	            window.$ = _$;
	        }

	        if (deep && window.jQuery === jQuery) {
	            window.jQuery = _jQuery;
	        }

	        return jQuery;
	    };

	    // Expose jQuery and $ identifiers, even in
	    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	    // and CommonJS for browser emulators (#13566)
	    // if (typeof noGlobal === strundefined) {
	    window.jQuery = window.$ = jQuery;
	    // }

	    return jQuery;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module)))

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/* jquery.nicescroll
	-- version 3.6.0
	-- copyright 2014-11-21 InuYaksa*2014
	-- licensed under the MIT
	--
	-- http://nicescroll.areaaperta.com/
	-- https://github.com/inuyaksa/jquery.nicescroll
	--
	*/

	// (function(factory) {
	//   if (typeof define === 'function' && define.amd) {
	//     // AMD. Register as anonymous module.
	//     define(['jquery'], factory);
	//   } else {
	//     // Browser globals.
	//     factory(jQuery);
	//   }
	// }(function(jQuery) {
	//   "use strict";

	// globals
	var domfocus = false;
	var mousefocus = false;
	var tabindexcounter = 0;
	var ascrailcounter = 2000;
	var globalmaxzindex = 0;

	var $ = jQuery; // sandbox

	// http://stackoverflow.com/questions/2161159/get-script-path
	function getScriptPath() {
	  var scripts = document.getElementsByTagName('script');
	  var path = scripts[scripts.length - 1].src.split('?')[0];
	  return path.split('/').length > 0 ? path.split('/').slice(0, -1).join('/') + '/' : '';
	}

	var vendors = ['webkit', 'ms', 'moz', 'o'];

	var setAnimationFrame = window.requestAnimationFrame || false;
	var clearAnimationFrame = window.cancelAnimationFrame || false;

	if (!setAnimationFrame) {
	  // legacy detection
	  for (var vx in vendors) {
	    var v = vendors[vx];
	    if (!setAnimationFrame) setAnimationFrame = window[v + 'RequestAnimationFrame'];
	    if (!clearAnimationFrame) clearAnimationFrame = window[v + 'CancelAnimationFrame'] || window[v + 'CancelRequestAnimationFrame'];
	  }
	}

	var ClsMutationObserver = window.MutationObserver || window.WebKitMutationObserver || false;

	var _globaloptions = {
	  zindex: "auto",
	  cursoropacitymin: 0,
	  cursoropacitymax: 1,
	  cursorcolor: "#424242",
	  cursorwidth: "5px",
	  cursorborder: "1px solid #fff",
	  cursorborderradius: "5px",
	  scrollspeed: 60,
	  mousescrollstep: 8 * 3,
	  touchbehavior: false,
	  hwacceleration: true,
	  usetransition: true,
	  boxzoom: false,
	  dblclickzoom: true,
	  gesturezoom: true,
	  grabcursorenabled: true,
	  autohidemode: true,
	  background: "",
	  iframeautoresize: true,
	  cursorminheight: 32,
	  preservenativescrolling: true,
	  railoffset: false,
	  railhoffset: false,
	  bouncescroll: true,
	  spacebarenabled: true,
	  railpadding: {
	    top: 0,
	    right: 0,
	    left: 0,
	    bottom: 0
	  },
	  disableoutline: true,
	  horizrailenabled: true,
	  railalign: "right",
	  railvalign: "bottom",
	  enabletranslate3d: true,
	  enablemousewheel: true,
	  enablekeyboard: true,
	  smoothscroll: true,
	  sensitiverail: true,
	  enablemouselockapi: true,
	  //      cursormaxheight:false,
	  cursorfixedheight: false,
	  directionlockdeadzone: 6,
	  hidecursordelay: 400,
	  nativeparentscrolling: true,
	  enablescrollonselection: true,
	  overflowx: true,
	  overflowy: true,
	  cursordragspeed: 0.3,
	  rtlmode: "auto",
	  cursordragontouch: false,
	  oneaxismousemode: "auto",
	  scriptpath: getScriptPath(),
	  preventmultitouchscrolling: true
	};

	var browserdetected = false;

	var getBrowserDetection = function getBrowserDetection() {

	  if (browserdetected) return browserdetected;

	  var _el = document.createElement('DIV'),
	      _style = _el.style,
	      _agent = navigator.userAgent,
	      _platform = navigator.platform,
	      d = {};

	  d.haspointerlock = "pointerLockElement" in document || "webkitPointerLockElement" in document || "mozPointerLockElement" in document;

	  d.isopera = "opera" in window; // 12-
	  d.isopera12 = d.isopera && "getUserMedia" in navigator;
	  d.isoperamini = Object.prototype.toString.call(window.operamini) === "[object OperaMini]";

	  d.isie = "all" in document && "attachEvent" in _el && !d.isopera; //IE10-
	  d.isieold = d.isie && !("msInterpolationMode" in _style); // IE6 and older
	  d.isie7 = d.isie && !d.isieold && (!("documentMode" in document) || document.documentMode == 7);
	  d.isie8 = d.isie && "documentMode" in document && document.documentMode == 8;
	  d.isie9 = d.isie && "performance" in window && document.documentMode >= 9;
	  d.isie10 = d.isie && "performance" in window && document.documentMode == 10;
	  d.isie11 = "msRequestFullscreen" in _el && document.documentMode >= 11; // IE11+

	  d.isie9mobile = /iemobile.9/i.test(_agent); //wp 7.1 mango
	  if (d.isie9mobile) d.isie9 = false;
	  d.isie7mobile = !d.isie9mobile && d.isie7 && /iemobile/i.test(_agent); //wp 7.0

	  d.ismozilla = "MozAppearance" in _style;

	  d.iswebkit = "WebkitAppearance" in _style;

	  d.ischrome = "chrome" in window;
	  d.ischrome22 = d.ischrome && d.haspointerlock;
	  d.ischrome26 = d.ischrome && "transition" in _style; // issue with transform detection (maintain prefix)

	  d.cantouch = "ontouchstart" in document.documentElement || "ontouchstart" in window; // detection for Chrome Touch Emulation
	  d.hasmstouch = window.MSPointerEvent || false; // IE10 pointer events
	  d.hasw3ctouch = window.PointerEvent || false; //IE11 pointer events, following W3C Pointer Events spec

	  d.ismac = /^mac$/i.test(_platform);

	  d.isios = d.cantouch && /iphone|ipad|ipod/i.test(_platform);
	  d.isios4 = d.isios && !("seal" in Object);
	  d.isios7 = d.isios && "webkitHidden" in document; //iOS 7+

	  d.isandroid = /android/i.test(_agent);

	  d.haseventlistener = "addEventListener" in _el;

	  d.trstyle = false;
	  d.hastransform = false;
	  d.hastranslate3d = false;
	  d.transitionstyle = false;
	  d.hastransition = false;
	  d.transitionend = false;

	  var a;
	  var check = ['transform', 'msTransform', 'webkitTransform', 'MozTransform', 'OTransform'];
	  for (a = 0; a < check.length; a++) {
	    if (typeof _style[check[a]] != "undefined") {
	      d.trstyle = check[a];
	      break;
	    }
	  }
	  d.hastransform = !!d.trstyle;
	  if (d.hastransform) {
	    _style[d.trstyle] = "translate3d(1px,2px,3px)";
	    d.hastranslate3d = /translate3d/.test(_style[d.trstyle]);
	  }

	  d.transitionstyle = false;
	  d.prefixstyle = '';
	  d.transitionend = false;
	  check = ['transition', 'webkitTransition', 'msTransition', 'MozTransition', 'OTransition', 'OTransition', 'KhtmlTransition'];
	  var prefix = ['', '-webkit-', '-ms-', '-moz-', '-o-', '-o', '-khtml-'];
	  var evs = ['transitionend', 'webkitTransitionEnd', 'msTransitionEnd', 'transitionend', 'otransitionend', 'oTransitionEnd', 'KhtmlTransitionEnd'];
	  for (a = 0; a < check.length; a++) {
	    if (check[a] in _style) {
	      d.transitionstyle = check[a];
	      d.prefixstyle = prefix[a];
	      d.transitionend = evs[a];
	      break;
	    }
	  }
	  if (d.ischrome26) {
	    // always use prefix
	    d.prefixstyle = prefix[1];
	  }

	  d.hastransition = d.transitionstyle;

	  function detectCursorGrab() {
	    var lst = ['-webkit-grab', '-moz-grab', 'grab'];
	    if (d.ischrome && !d.ischrome22 || d.isie) lst = []; // force setting for IE returns false positive and chrome cursor bug
	    for (var a = 0; a < lst.length; a++) {
	      var p = lst[a];
	      _style.cursor = p;
	      if (_style.cursor == p) return p;
	    }
	    return 'url(//mail.google.com/mail/images/2/openhand.cur),n-resize'; // thank you google for custom cursor!
	  }
	  d.cursorgrabvalue = detectCursorGrab();

	  d.hasmousecapture = "setCapture" in _el;

	  d.hasMutationObserver = ClsMutationObserver !== false;

	  _el = null; //memory released

	  browserdetected = d;

	  return d;
	};

	var NiceScrollClass = function NiceScrollClass(myopt, me) {

	  var self = this;

	  this.version = '3.6.0';
	  this.name = 'nicescroll';

	  this.me = me;

	  this.opt = {
	    doc: $("body"),
	    win: false
	  };

	  $.extend(this.opt, _globaloptions); // clone opts

	  // Options for internal use
	  this.opt.snapbackspeed = 80;

	  if (myopt || false) {
	    for (var a in self.opt) {
	      if (typeof myopt[a] != "undefined") self.opt[a] = myopt[a];
	    }
	  }

	  this.doc = self.opt.doc;
	  this.iddoc = this.doc && this.doc[0] ? this.doc[0].id || '' : '';
	  this.ispage = /^BODY|HTML/.test(self.opt.win ? self.opt.win[0].nodeName : this.doc[0].nodeName);
	  this.haswrapper = self.opt.win !== false;
	  this.win = self.opt.win || (this.ispage ? $(window) : this.doc);
	  this.docscroll = this.ispage && !this.haswrapper ? $(window) : this.win;
	  this.body = $("body");
	  this.viewport = false;

	  this.isfixed = false;

	  this.iframe = false;
	  this.isiframe = this.doc[0].nodeName == 'IFRAME' && this.win[0].nodeName == 'IFRAME';

	  this.istextarea = this.win[0].nodeName == 'TEXTAREA';

	  this.forcescreen = false; //force to use screen position on events

	  this.canshowonmouseevent = self.opt.autohidemode != "scroll";

	  // Events jump table    
	  this.onmousedown = false;
	  this.onmouseup = false;
	  this.onmousemove = false;
	  this.onmousewheel = false;
	  this.onkeypress = false;
	  this.ongesturezoom = false;
	  this.onclick = false;

	  // Nicescroll custom events
	  this.onscrollstart = false;
	  this.onscrollend = false;
	  this.onscrollcancel = false;

	  this.onzoomin = false;
	  this.onzoomout = false;

	  // Let's start!  
	  this.view = false;
	  this.page = false;

	  this.scroll = {
	    x: 0,
	    y: 0
	  };
	  this.scrollratio = {
	    x: 0,
	    y: 0
	  };
	  this.cursorheight = 20;
	  this.scrollvaluemax = 0;

	  this.isrtlmode = this.opt.rtlmode == "auto" ? (this.win[0] == window ? this.body : this.win).css("direction") == "rtl" : this.opt.rtlmode === true;
	  //    this.checkrtlmode = false;

	  this.scrollrunning = false;

	  this.scrollmom = false;

	  this.observer = false; // observer div changes
	  this.observerremover = false; // observer on parent for remove detection
	  this.observerbody = false; // observer on body for position change

	  do {
	    this.id = "ascrail" + ascrailcounter++;
	  } while (document.getElementById(this.id));

	  this.rail = false;
	  this.cursor = false;
	  this.cursorfreezed = false;
	  this.selectiondrag = false;

	  this.zoom = false;
	  this.zoomactive = false;

	  this.hasfocus = false;
	  this.hasmousefocus = false;

	  this.visibility = true;
	  this.railslocked = false; // locked by resize
	  this.locked = false; // prevent lost of locked status sets by user
	  this.hidden = false; // rails always hidden
	  this.cursoractive = true; // user can interact with cursors

	  this.wheelprevented = false; //prevent mousewheel event

	  this.overflowx = self.opt.overflowx;
	  this.overflowy = self.opt.overflowy;

	  this.nativescrollingarea = false;
	  this.checkarea = 0;

	  this.events = []; // event list for unbind

	  this.saved = {}; // style saved

	  this.delaylist = {};
	  this.synclist = {};

	  this.lastdeltax = 0;
	  this.lastdeltay = 0;

	  this.detected = getBrowserDetection();

	  var cap = $.extend({}, this.detected);

	  this.canhwscroll = cap.hastransform && self.opt.hwacceleration;
	  this.ishwscroll = this.canhwscroll && self.haswrapper;

	  this.hasreversehr = this.isrtlmode && !cap.iswebkit; //RTL mode with reverse horizontal axis

	  this.istouchcapable = false; // desktop devices with touch screen support

	  //## Check WebKit-based desktop with touch support
	  //## + Firefox 18 nightly build (desktop) false positive (or desktop with touch support)
	  if (cap.cantouch && !cap.isios && !cap.isandroid && (cap.iswebkit || cap.ismozilla)) {
	    this.istouchcapable = true;
	    cap.cantouch = false; // parse normal desktop events
	  }

	  //## disable MouseLock API on user request
	  if (!self.opt.enablemouselockapi) {
	    cap.hasmousecapture = false;
	    cap.haspointerlock = false;
	  }

	  /* deprecated
	      this.delayed = function(name, fn, tm, lazy) {
	      };
	  */

	  this.debounced = function (name, fn, tm) {
	    var dd = self.delaylist[name];
	    self.delaylist[name] = fn;
	    if (!dd) {
	      setTimeout(function () {
	        var fn = self.delaylist[name];
	        self.delaylist[name] = false;
	        fn.call(self);
	      }, tm);
	    }
	  };

	  var _onsync = false;

	  this.synched = function (name, fn) {

	    function requestSync() {
	      if (_onsync) return;
	      setAnimationFrame(function () {
	        _onsync = false;
	        for (var nn in self.synclist) {
	          var fn = self.synclist[nn];
	          if (fn) fn.call(self);
	          self.synclist[nn] = false;
	        }
	      });
	      _onsync = true;
	    }

	    self.synclist[name] = fn;
	    requestSync();
	    return name;
	  };

	  this.unsynched = function (name) {
	    if (self.synclist[name]) self.synclist[name] = false;
	  };

	  this.css = function (el, pars) {
	    // save & set
	    for (var n in pars) {
	      self.saved.css.push([el, n, el.css(n)]);
	      el.css(n, pars[n]);
	    }
	  };

	  this.scrollTop = function (val) {
	    return typeof val == "undefined" ? self.getScrollTop() : self.setScrollTop(val);
	  };

	  this.scrollLeft = function (val) {
	    return typeof val == "undefined" ? self.getScrollLeft() : self.setScrollLeft(val);
	  };

	  // derived by by Dan Pupius www.pupius.net
	  var BezierClass = function BezierClass(st, ed, spd, p1, p2, p3, p4) {

	    this.st = st;
	    this.ed = ed;
	    this.spd = spd;

	    this.p1 = p1 || 0;
	    this.p2 = p2 || 1;
	    this.p3 = p3 || 0;
	    this.p4 = p4 || 1;

	    this.ts = new Date().getTime();
	    this.df = this.ed - this.st;
	  };
	  BezierClass.prototype = {
	    B2: function B2(t) {
	      return 3 * t * t * (1 - t);
	    },
	    B3: function B3(t) {
	      return 3 * t * (1 - t) * (1 - t);
	    },
	    B4: function B4(t) {
	      return (1 - t) * (1 - t) * (1 - t);
	    },
	    getNow: function getNow() {
	      var nw = new Date().getTime();
	      var pc = 1 - (nw - this.ts) / this.spd;
	      var bz = this.B2(pc) + this.B3(pc) + this.B4(pc);
	      return pc < 0 ? this.ed : this.st + Math.round(this.df * bz);
	    },
	    update: function update(ed, spd) {
	      this.st = this.getNow();
	      this.ed = ed;
	      this.spd = spd;
	      this.ts = new Date().getTime();
	      this.df = this.ed - this.st;
	      return this;
	    }
	  };

	  //derived from http://stackoverflow.com/questions/11236090/
	  function getMatrixValues() {
	    var tr = self.doc.css(cap.trstyle);
	    if (tr && tr.substr(0, 6) == "matrix") {
	      return tr.replace(/^.*\((.*)\)$/g, "$1").replace(/px/g, '').split(/, +/);
	    }
	    return false;
	  }

	  if (this.ishwscroll) {
	    // hw accelerated scroll
	    this.doc.translate = {
	      x: 0,
	      y: 0,
	      tx: "0px",
	      ty: "0px"
	    };

	    //this one can help to enable hw accel on ios6 http://indiegamr.com/ios6-html-hardware-acceleration-changes-and-how-to-fix-them/
	    if (cap.hastranslate3d && cap.isios) this.doc.css("-webkit-backface-visibility", "hidden"); // prevent flickering http://stackoverflow.com/questions/3461441/      

	    this.getScrollTop = function (last) {
	      if (!last) {
	        var mtx = getMatrixValues();
	        if (mtx) return mtx.length == 16 ? -mtx[13] : -mtx[5]; //matrix3d 16 on IE10
	        if (self.timerscroll && self.timerscroll.bz) return self.timerscroll.bz.getNow();
	      }
	      return self.doc.translate.y;
	    };

	    this.getScrollLeft = function (last) {
	      if (!last) {
	        var mtx = getMatrixValues();
	        if (mtx) return mtx.length == 16 ? -mtx[12] : -mtx[4]; //matrix3d 16 on IE10
	        if (self.timerscroll && self.timerscroll.bh) return self.timerscroll.bh.getNow();
	      }
	      return self.doc.translate.x;
	    };

	    this.notifyScrollEvent = function (el) {
	      var e = document.createEvent("UIEvents");
	      e.initUIEvent("scroll", false, true, window, 1);
	      e.niceevent = true;
	      el.dispatchEvent(e);
	    };

	    var cxscrollleft = this.isrtlmode ? 1 : -1;

	    if (cap.hastranslate3d && self.opt.enabletranslate3d) {
	      this.setScrollTop = function (val, silent) {
	        self.doc.translate.y = val;
	        self.doc.translate.ty = val * -1 + "px";
	        self.doc.css(cap.trstyle, "translate3d(" + self.doc.translate.tx + "," + self.doc.translate.ty + ",0px)");
	        if (!silent) self.notifyScrollEvent(self.win[0]);
	      };
	      this.setScrollLeft = function (val, silent) {
	        self.doc.translate.x = val;
	        self.doc.translate.tx = val * cxscrollleft + "px";
	        self.doc.css(cap.trstyle, "translate3d(" + self.doc.translate.tx + "," + self.doc.translate.ty + ",0px)");
	        if (!silent) self.notifyScrollEvent(self.win[0]);
	      };
	    } else {
	      this.setScrollTop = function (val, silent) {
	        self.doc.translate.y = val;
	        self.doc.translate.ty = val * -1 + "px";
	        self.doc.css(cap.trstyle, "translate(" + self.doc.translate.tx + "," + self.doc.translate.ty + ")");
	        if (!silent) self.notifyScrollEvent(self.win[0]);
	      };
	      this.setScrollLeft = function (val, silent) {
	        self.doc.translate.x = val;
	        self.doc.translate.tx = val * cxscrollleft + "px";
	        self.doc.css(cap.trstyle, "translate(" + self.doc.translate.tx + "," + self.doc.translate.ty + ")");
	        if (!silent) self.notifyScrollEvent(self.win[0]);
	      };
	    }
	  } else {
	    // native scroll
	    this.getScrollTop = function () {
	      return self.docscroll.scrollTop();
	    };
	    this.setScrollTop = function (val) {
	      return self.docscroll.scrollTop(val);
	    };
	    this.getScrollLeft = function () {
	      if (self.detected.ismozilla && self.isrtlmode) return Math.abs(self.docscroll.scrollLeft());
	      return self.docscroll.scrollLeft();
	    };
	    this.setScrollLeft = function (val) {
	      return self.docscroll.scrollLeft(self.detected.ismozilla && self.isrtlmode ? -val : val);
	    };
	  }

	  this.getTarget = function (e) {
	    if (!e) return false;
	    if (e.target) return e.target;
	    if (e.srcElement) return e.srcElement;
	    return false;
	  };

	  this.hasParent = function (e, id) {
	    if (!e) return false;
	    var el = e.target || e.srcElement || e || false;
	    while (el && el.id != id) {
	      el = el.parentNode || false;
	    }
	    return el !== false;
	  };

	  function getZIndex() {
	    var dom = self.win;
	    if ("zIndex" in dom) return dom.zIndex(); // use jQuery UI method when available
	    while (dom.length > 0) {
	      if (dom[0].nodeType == 9) return false;
	      var zi = dom.css('zIndex');
	      if (!isNaN(zi) && zi != 0) return parseInt(zi);
	      dom = dom.parent();
	    }
	    return false;
	  }

	  //inspired by http://forum.jquery.com/topic/width-includes-border-width-when-set-to-thin-medium-thick-in-ie
	  var _convertBorderWidth = {
	    "thin": 1,
	    "medium": 3,
	    "thick": 5
	  };

	  function getWidthToPixel(dom, prop, chkheight) {
	    var wd = dom.css(prop);
	    var px = parseFloat(wd);
	    if (isNaN(px)) {
	      px = _convertBorderWidth[wd] || 0;
	      var brd = px == 3 ? chkheight ? self.win.outerHeight() - self.win.innerHeight() : self.win.outerWidth() - self.win.innerWidth() : 1; //DON'T TRUST CSS
	      if (self.isie8 && px) px += 1;
	      return brd ? px : 0;
	    }
	    return px;
	  }

	  this.getDocumentScrollOffset = function () {
	    return { top: window.pageYOffset || document.documentElement.scrollTop,
	      left: window.pageXOffset || document.documentElement.scrollLeft };
	  };

	  this.getOffset = function () {
	    if (self.isfixed) {
	      var ofs = self.win.offset(); // fix Chrome auto issue (when right/bottom props only)
	      var scrl = self.getDocumentScrollOffset();
	      ofs.top -= scrl.top;
	      ofs.left -= scrl.left;
	      return ofs;
	    }
	    var ww = self.win.offset();
	    if (!self.viewport) return ww;
	    var vp = self.viewport.offset();
	    return {
	      top: ww.top - vp.top, // + self.viewport.scrollTop(),
	      left: ww.left - vp.left // + self.viewport.scrollLeft()
	    };
	  };

	  this.updateScrollBar = function (len) {
	    if (self.ishwscroll) {
	      self.rail.css({ //**
	        height: self.win.innerHeight() - (self.opt.railpadding.top + self.opt.railpadding.bottom)
	      });
	      if (self.railh) self.railh.css({ //**
	        width: self.win.innerWidth() - (self.opt.railpadding.left + self.opt.railpadding.right)
	      });
	    } else {
	      var wpos = self.getOffset();
	      var pos = {
	        top: wpos.top,
	        left: wpos.left - (self.opt.railpadding.left + self.opt.railpadding.right)
	      };
	      pos.top += getWidthToPixel(self.win, 'border-top-width', true);
	      pos.left += self.rail.align ? self.win.outerWidth() - getWidthToPixel(self.win, 'border-right-width') - self.rail.width : getWidthToPixel(self.win, 'border-left-width');

	      var off = self.opt.railoffset;
	      if (off) {
	        if (off.top) pos.top += off.top;
	        if (self.rail.align && off.left) pos.left += off.left;
	      }

	      if (!self.railslocked) self.rail.css({
	        top: pos.top,
	        left: pos.left,
	        height: (len ? len.h : self.win.innerHeight()) - (self.opt.railpadding.top + self.opt.railpadding.bottom)
	      });

	      if (self.zoom) {
	        self.zoom.css({
	          top: pos.top + 1,
	          left: self.rail.align == 1 ? pos.left - 20 : pos.left + self.rail.width + 4
	        });
	      }

	      if (self.railh && !self.railslocked) {
	        var pos = {
	          top: wpos.top,
	          left: wpos.left
	        };
	        var off = self.opt.railhoffset;
	        if (!!off) {
	          if (!!off.top) pos.top += off.top;
	          if (!!off.left) pos.left += off.left;
	        }
	        var y = self.railh.align ? pos.top + getWidthToPixel(self.win, 'border-top-width', true) + self.win.innerHeight() - self.railh.height : pos.top + getWidthToPixel(self.win, 'border-top-width', true);
	        var x = pos.left + getWidthToPixel(self.win, 'border-left-width');
	        self.railh.css({
	          top: y - (self.opt.railpadding.top + self.opt.railpadding.bottom),
	          left: x,
	          width: self.railh.width
	        });
	      }
	    }
	  };

	  this.doRailClick = function (e, dbl, hr) {
	    var fn, pg, cur, pos;

	    if (self.railslocked) return;
	    self.cancelEvent(e);

	    if (dbl) {
	      fn = hr ? self.doScrollLeft : self.doScrollTop;
	      cur = hr ? (e.pageX - self.railh.offset().left - self.cursorwidth / 2) * self.scrollratio.x : (e.pageY - self.rail.offset().top - self.cursorheight / 2) * self.scrollratio.y;
	      fn(cur);
	    } else {
	      fn = hr ? self.doScrollLeftBy : self.doScrollBy;
	      cur = hr ? self.scroll.x : self.scroll.y;
	      pos = hr ? e.pageX - self.railh.offset().left : e.pageY - self.rail.offset().top;
	      pg = hr ? self.view.w : self.view.h;
	      fn(cur >= pos ? pg : -pg); //   (cur >= pos) ? fn(pg): fn(-pg);
	    }
	  };

	  self.hasanimationframe = setAnimationFrame;
	  self.hascancelanimationframe = clearAnimationFrame;

	  if (!self.hasanimationframe) {
	    setAnimationFrame = function setAnimationFrame(fn) {
	      return setTimeout(fn, 15 - Math.floor(+new Date() / 1000) % 16);
	    }; // 1000/60)};
	    clearAnimationFrame = clearInterval;
	  } else if (!self.hascancelanimationframe) clearAnimationFrame = function clearAnimationFrame() {
	    self.cancelAnimationFrame = true;
	  };

	  this.init = function () {

	    self.saved.css = [];

	    if (cap.isie7mobile) return true; // SORRY, DO NOT WORK!
	    if (cap.isoperamini) return true; // SORRY, DO NOT WORK!

	    if (cap.hasmstouch) self.css(self.ispage ? $("html") : self.win, {
	      '-ms-touch-action': 'none'
	    });

	    self.zindex = "auto";
	    if (!self.ispage && self.opt.zindex == "auto") {
	      self.zindex = getZIndex() || "auto";
	    } else {
	      self.zindex = self.opt.zindex;
	    }

	    if (!self.ispage && self.zindex != "auto") {
	      if (self.zindex > globalmaxzindex) globalmaxzindex = self.zindex;
	    }

	    if (self.isie && self.zindex == 0 && self.opt.zindex == "auto") {
	      // fix IE auto == 0
	      self.zindex = "auto";
	    }

	    if (!self.ispage || !cap.cantouch && !cap.isieold && !cap.isie9mobile) {

	      var cont = self.docscroll;
	      if (self.ispage) cont = self.haswrapper ? self.win : self.doc;

	      if (!cap.isie9mobile) self.css(cont, {
	        'overflow-y': 'hidden'
	      });

	      if (self.ispage && cap.isie7) {
	        if (self.doc[0].nodeName == 'BODY') self.css($("html"), {
	          'overflow-y': 'hidden'
	        }); //IE7 double scrollbar issue
	        else if (self.doc[0].nodeName == 'HTML') self.css($("body"), {
	            'overflow-y': 'hidden'
	          }); //IE7 double scrollbar issue
	      }

	      if (cap.isios && !self.ispage && !self.haswrapper) self.css($("body"), {
	        "-webkit-overflow-scrolling": "touch"
	      }); //force hw acceleration

	      var cursor = $(document.createElement('div'));
	      cursor.css({
	        position: "relative",
	        top: 0,
	        "float": "right",
	        width: self.opt.cursorwidth,
	        height: "0px",
	        'background-color': self.opt.cursorcolor,
	        border: self.opt.cursorborder,
	        'background-clip': 'padding-box',
	        '-webkit-border-radius': self.opt.cursorborderradius,
	        '-moz-border-radius': self.opt.cursorborderradius,
	        'border-radius': self.opt.cursorborderradius
	      });

	      cursor.hborder = parseFloat(cursor.outerHeight() - cursor.innerHeight());

	      cursor.addClass('nicescroll-cursors');

	      self.cursor = cursor;

	      var rail = $(document.createElement('div'));
	      rail.attr('id', self.id);
	      rail.addClass('nicescroll-rails nicescroll-rails-vr');

	      var v,
	          a,
	          kp = ["left", "right", "top", "bottom"]; //**
	      for (var n in kp) {
	        a = kp[n];
	        v = self.opt.railpadding[a];
	        v ? rail.css("padding-" + a, v + "px") : self.opt.railpadding[a] = 0;
	      }

	      rail.append(cursor);

	      rail.width = Math.max(parseFloat(self.opt.cursorwidth), cursor.outerWidth());
	      rail.css({
	        width: rail.width + "px",
	        'zIndex': self.zindex,
	        "background": self.opt.background,
	        cursor: "default"
	      });

	      rail.visibility = true;
	      rail.scrollable = true;

	      rail.align = self.opt.railalign == "left" ? 0 : 1;

	      self.rail = rail;

	      self.rail.drag = false;

	      var zoom = false;
	      if (self.opt.boxzoom && !self.ispage && !cap.isieold) {
	        zoom = document.createElement('div');

	        self.bind(zoom, "click", self.doZoom);
	        self.bind(zoom, "mouseenter", function () {
	          self.zoom.css('opacity', self.opt.cursoropacitymax);
	        });
	        self.bind(zoom, "mouseleave", function () {
	          self.zoom.css('opacity', self.opt.cursoropacitymin);
	        });

	        self.zoom = $(zoom);
	        self.zoom.css({
	          "cursor": "pointer",
	          'z-index': self.zindex,
	          'backgroundImage': 'url(' + self.opt.scriptpath + 'zoomico.png)',
	          'height': 18,
	          'width': 18,
	          'backgroundPosition': '0px 0px'
	        });
	        if (self.opt.dblclickzoom) self.bind(self.win, "dblclick", self.doZoom);
	        if (cap.cantouch && self.opt.gesturezoom) {
	          self.ongesturezoom = function (e) {
	            if (e.scale > 1.5) self.doZoomIn(e);
	            if (e.scale < 0.8) self.doZoomOut(e);
	            return self.cancelEvent(e);
	          };
	          self.bind(self.win, "gestureend", self.ongesturezoom);
	        }
	      }

	      // init HORIZ

	      self.railh = false;
	      var railh;

	      if (self.opt.horizrailenabled) {

	        self.css(cont, {
	          'overflow-x': 'hidden'
	        });

	        var cursor = $(document.createElement('div'));
	        cursor.css({
	          position: "absolute",
	          top: 0,
	          height: self.opt.cursorwidth,
	          width: "0px",
	          'background-color': self.opt.cursorcolor,
	          border: self.opt.cursorborder,
	          'background-clip': 'padding-box',
	          '-webkit-border-radius': self.opt.cursorborderradius,
	          '-moz-border-radius': self.opt.cursorborderradius,
	          'border-radius': self.opt.cursorborderradius
	        });

	        if (cap.isieold) cursor.css({ 'overflow': 'hidden' }); //IE6 horiz scrollbar issue

	        cursor.wborder = parseFloat(cursor.outerWidth() - cursor.innerWidth());

	        cursor.addClass('nicescroll-cursors');

	        self.cursorh = cursor;

	        railh = $(document.createElement('div'));
	        railh.attr('id', self.id + '-hr');
	        railh.addClass('nicescroll-rails nicescroll-rails-hr');
	        railh.height = Math.max(parseFloat(self.opt.cursorwidth), cursor.outerHeight());
	        railh.css({
	          height: railh.height + "px",
	          'zIndex': self.zindex,
	          "background": self.opt.background
	        });

	        railh.append(cursor);

	        railh.visibility = true;
	        railh.scrollable = true;

	        railh.align = self.opt.railvalign == "top" ? 0 : 1;

	        self.railh = railh;

	        self.railh.drag = false;
	      }

	      //        

	      if (self.ispage) {
	        rail.css({
	          position: "fixed",
	          top: "0px",
	          height: "100%"
	        });
	        rail.align ? rail.css({
	          right: "0px"
	        }) : rail.css({
	          left: "0px"
	        });
	        self.body.append(rail);
	        if (self.railh) {
	          railh.css({
	            position: "fixed",
	            left: "0px",
	            width: "100%"
	          });
	          railh.align ? railh.css({
	            bottom: "0px"
	          }) : railh.css({
	            top: "0px"
	          });
	          self.body.append(railh);
	        }
	      } else {
	        if (self.ishwscroll) {
	          if (self.win.css('position') == 'static') self.css(self.win, {
	            'position': 'relative'
	          });
	          var bd = self.win[0].nodeName == 'HTML' ? self.body : self.win;
	          $(bd).scrollTop(0).scrollLeft(0); // fix rail position if content already scrolled
	          if (self.zoom) {
	            self.zoom.css({
	              position: "absolute",
	              top: 1,
	              right: 0,
	              "margin-right": rail.width + 4
	            });
	            bd.append(self.zoom);
	          }
	          rail.css({
	            position: "absolute",
	            top: 0
	          });
	          rail.align ? rail.css({
	            right: 0
	          }) : rail.css({
	            left: 0
	          });
	          bd.append(rail);
	          if (railh) {
	            railh.css({
	              position: "absolute",
	              left: 0,
	              bottom: 0
	            });
	            railh.align ? railh.css({
	              bottom: 0
	            }) : railh.css({
	              top: 0
	            });
	            bd.append(railh);
	          }
	        } else {
	          self.isfixed = self.win.css("position") == "fixed";
	          var rlpos = self.isfixed ? "fixed" : "absolute";

	          if (!self.isfixed) self.viewport = self.getViewport(self.win[0]);
	          if (self.viewport) {
	            self.body = self.viewport;
	            if (/fixed|absolute/.test(self.viewport.css("position")) == false) self.css(self.viewport, {
	              "position": "relative"
	            });
	          }

	          rail.css({
	            position: rlpos
	          });
	          if (self.zoom) self.zoom.css({
	            position: rlpos
	          });
	          self.updateScrollBar();
	          self.body.append(rail);
	          if (self.zoom) self.body.append(self.zoom);
	          if (self.railh) {
	            railh.css({
	              position: rlpos
	            });
	            self.body.append(railh);
	          }
	        }

	        if (cap.isios) self.css(self.win, {
	          '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
	          '-webkit-touch-callout': 'none'
	        }); // prevent grey layer on click

	        if (cap.isie && self.opt.disableoutline) self.win.attr("hideFocus", "true"); // IE, prevent dotted rectangle on focused div
	        if (cap.iswebkit && self.opt.disableoutline) self.win.css({ "outline": "none" }); // Webkit outline
	        //if (cap.isopera&&self.opt.disableoutline) self.win.css({"outline":"0"});  // Opera 12- to test [TODO]
	      }

	      if (self.opt.autohidemode === false) {
	        self.autohidedom = false;
	        self.rail.css({
	          opacity: self.opt.cursoropacitymax
	        });
	        if (self.railh) self.railh.css({
	          opacity: self.opt.cursoropacitymax
	        });
	      } else if (self.opt.autohidemode === true || self.opt.autohidemode === "leave") {
	        self.autohidedom = $().add(self.rail);
	        if (cap.isie8) self.autohidedom = self.autohidedom.add(self.cursor);
	        if (self.railh) self.autohidedom = self.autohidedom.add(self.railh);
	        if (self.railh && cap.isie8) self.autohidedom = self.autohidedom.add(self.cursorh);
	      } else if (self.opt.autohidemode == "scroll") {
	        self.autohidedom = $().add(self.rail);
	        if (self.railh) self.autohidedom = self.autohidedom.add(self.railh);
	      } else if (self.opt.autohidemode == "cursor") {
	        self.autohidedom = $().add(self.cursor);
	        if (self.railh) self.autohidedom = self.autohidedom.add(self.cursorh);
	      } else if (self.opt.autohidemode == "hidden") {
	        self.autohidedom = false;
	        self.hide();
	        self.railslocked = false;
	      }

	      if (cap.isie9mobile) {

	        self.scrollmom = new ScrollMomentumClass2D(self);

	        self.onmangotouch = function () {
	          var py = self.getScrollTop();
	          var px = self.getScrollLeft();

	          if (py == self.scrollmom.lastscrolly && px == self.scrollmom.lastscrollx) return true;

	          var dfy = py - self.mangotouch.sy;
	          var dfx = px - self.mangotouch.sx;
	          var df = Math.round(Math.sqrt(Math.pow(dfx, 2) + Math.pow(dfy, 2)));
	          if (df == 0) return;

	          var dry = dfy < 0 ? -1 : 1;
	          var drx = dfx < 0 ? -1 : 1;

	          var tm = +new Date();
	          if (self.mangotouch.lazy) clearTimeout(self.mangotouch.lazy);

	          if (tm - self.mangotouch.tm > 80 || self.mangotouch.dry != dry || self.mangotouch.drx != drx) {
	            self.scrollmom.stop();
	            self.scrollmom.reset(px, py);
	            self.mangotouch.sy = py;
	            self.mangotouch.ly = py;
	            self.mangotouch.sx = px;
	            self.mangotouch.lx = px;
	            self.mangotouch.dry = dry;
	            self.mangotouch.drx = drx;
	            self.mangotouch.tm = tm;
	          } else {

	            self.scrollmom.stop();
	            self.scrollmom.update(self.mangotouch.sx - dfx, self.mangotouch.sy - dfy);
	            self.mangotouch.tm = tm;

	            var ds = Math.max(Math.abs(self.mangotouch.ly - py), Math.abs(self.mangotouch.lx - px));
	            self.mangotouch.ly = py;
	            self.mangotouch.lx = px;

	            if (ds > 2) {
	              self.mangotouch.lazy = setTimeout(function () {
	                self.mangotouch.lazy = false;
	                self.mangotouch.dry = 0;
	                self.mangotouch.drx = 0;
	                self.mangotouch.tm = 0;
	                self.scrollmom.doMomentum(30);
	              }, 100);
	            }
	          }
	        };

	        var top = self.getScrollTop();
	        var lef = self.getScrollLeft();
	        self.mangotouch = {
	          sy: top,
	          ly: top,
	          dry: 0,
	          sx: lef,
	          lx: lef,
	          drx: 0,
	          lazy: false,
	          tm: 0
	        };

	        self.bind(self.docscroll, "scroll", self.onmangotouch);
	      } else {

	        if (cap.cantouch || self.istouchcapable || self.opt.touchbehavior || cap.hasmstouch) {

	          self.scrollmom = new ScrollMomentumClass2D(self);

	          self.ontouchstart = function (e) {
	            if (e.pointerType && e.pointerType != 2 && e.pointerType != "touch") return false;

	            self.hasmoving = false;

	            if (!self.railslocked) {

	              var tg;
	              if (cap.hasmstouch) {
	                tg = e.target ? e.target : false;
	                while (tg) {
	                  var nc = $(tg).getNiceScroll();
	                  if (nc.length > 0 && nc[0].me == self.me) break;
	                  if (nc.length > 0) return false;
	                  if (tg.nodeName == 'DIV' && tg.id == self.id) break;
	                  tg = tg.parentNode ? tg.parentNode : false;
	                }
	              }

	              self.cancelScroll();

	              tg = self.getTarget(e);

	              if (tg) {
	                var skp = /INPUT/i.test(tg.nodeName) && /range/i.test(tg.type);
	                if (skp) return self.stopPropagation(e);
	              }

	              if (!("clientX" in e) && "changedTouches" in e) {
	                e.clientX = e.changedTouches[0].clientX;
	                e.clientY = e.changedTouches[0].clientY;
	              }

	              if (self.forcescreen) {
	                var le = e;
	                e = {
	                  "original": e.original ? e.original : e
	                };
	                e.clientX = le.screenX;
	                e.clientY = le.screenY;
	              }

	              self.rail.drag = {
	                x: e.clientX,
	                y: e.clientY,
	                sx: self.scroll.x,
	                sy: self.scroll.y,
	                st: self.getScrollTop(),
	                sl: self.getScrollLeft(),
	                pt: 2,
	                dl: false
	              };

	              if (self.ispage || !self.opt.directionlockdeadzone) {
	                self.rail.drag.dl = "f";
	              } else {

	                var view = {
	                  w: $(window).width(),
	                  h: $(window).height()
	                };

	                var page = {
	                  w: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
	                  h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
	                };

	                var maxh = Math.max(0, page.h - view.h);
	                var maxw = Math.max(0, page.w - view.w);

	                if (!self.rail.scrollable && self.railh.scrollable) self.rail.drag.ck = maxh > 0 ? "v" : false;else if (self.rail.scrollable && !self.railh.scrollable) self.rail.drag.ck = maxw > 0 ? "h" : false;else self.rail.drag.ck = false;
	                if (!self.rail.drag.ck) self.rail.drag.dl = "f";
	              }

	              if (self.opt.touchbehavior && self.isiframe && cap.isie) {
	                var wp = self.win.position();
	                self.rail.drag.x += wp.left;
	                self.rail.drag.y += wp.top;
	              }

	              self.hasmoving = false;
	              self.lastmouseup = false;
	              self.scrollmom.reset(e.clientX, e.clientY);

	              if (!cap.cantouch && !this.istouchcapable && !e.pointerType) {

	                var ip = tg ? /INPUT|SELECT|TEXTAREA/i.test(tg.nodeName) : false;
	                if (!ip) {
	                  if (!self.ispage && cap.hasmousecapture) tg.setCapture();
	                  if (self.opt.touchbehavior) {
	                    if (tg.onclick && !(tg._onclick || false)) {
	                      // intercept DOM0 onclick event
	                      tg._onclick = tg.onclick;
	                      tg.onclick = function (e) {
	                        if (self.hasmoving) return false;
	                        tg._onclick.call(this, e);
	                      };
	                    }
	                    return self.cancelEvent(e);
	                  }
	                  return self.stopPropagation(e);
	                }

	                if (/SUBMIT|CANCEL|BUTTON/i.test($(tg).attr('type'))) {
	                  pc = {
	                    "tg": tg,
	                    "click": false
	                  };
	                  self.preventclick = pc;
	                }
	              }
	            }
	          };

	          self.ontouchend = function (e) {
	            if (!self.rail.drag) return true;
	            if (self.rail.drag.pt == 2) {
	              if (e.pointerType && e.pointerType != 2 && e.pointerType != "touch") return false;
	              self.scrollmom.doMomentum();
	              self.rail.drag = false;
	              if (self.hasmoving) {
	                self.lastmouseup = true;
	                self.hideCursor();
	                if (cap.hasmousecapture) document.releaseCapture();
	                if (!cap.cantouch) return self.cancelEvent(e);
	              }
	            } else if (self.rail.drag.pt == 1) {
	              return self.onmouseup(e);
	            }
	          };

	          var moveneedoffset = self.opt.touchbehavior && self.isiframe && !cap.hasmousecapture;

	          self.ontouchmove = function (e, byiframe) {

	            if (!self.rail.drag) return false;

	            if (e.targetTouches && self.opt.preventmultitouchscrolling) {
	              if (e.targetTouches.length > 1) return false; // multitouch
	            }

	            if (e.pointerType && e.pointerType != 2 && e.pointerType != "touch") return false;

	            if (self.rail.drag.pt == 2) {
	              if (cap.cantouch && cap.isios && typeof e.original == "undefined") return true; // prevent ios "ghost" events by clickable elements

	              self.hasmoving = true;

	              if (self.preventclick && !self.preventclick.click) {
	                self.preventclick.click = self.preventclick.tg.onclick || false;
	                self.preventclick.tg.onclick = self.onpreventclick;
	              }

	              var ev = $.extend({
	                "original": e
	              }, e);
	              e = ev;

	              if ("changedTouches" in e) {
	                e.clientX = e.changedTouches[0].clientX;
	                e.clientY = e.changedTouches[0].clientY;
	              }

	              if (self.forcescreen) {
	                var le = e;
	                e = {
	                  "original": e.original ? e.original : e
	                };
	                e.clientX = le.screenX;
	                e.clientY = le.screenY;
	              }

	              var ofy, ofx;
	              ofx = ofy = 0;

	              if (moveneedoffset && !byiframe) {
	                var wp = self.win.position();
	                ofx = -wp.left;
	                ofy = -wp.top;
	              }

	              var fy = e.clientY + ofy;
	              var my = fy - self.rail.drag.y;
	              var fx = e.clientX + ofx;
	              var mx = fx - self.rail.drag.x;

	              var ny = self.rail.drag.st - my;

	              if (self.ishwscroll && self.opt.bouncescroll) {
	                if (ny < 0) {
	                  ny = Math.round(ny / 2);
	                  //                    fy = 0;
	                } else if (ny > self.page.maxh) {
	                  ny = self.page.maxh + Math.round((ny - self.page.maxh) / 2);
	                  //                    fy = 0;
	                }
	              } else {
	                if (ny < 0) {
	                  ny = 0;
	                  fy = 0;
	                }
	                if (ny > self.page.maxh) {
	                  ny = self.page.maxh;
	                  fy = 0;
	                }
	              }

	              var nx;
	              if (self.railh && self.railh.scrollable) {
	                nx = self.isrtlmode ? mx - self.rail.drag.sl : self.rail.drag.sl - mx;

	                if (self.ishwscroll && self.opt.bouncescroll) {
	                  if (nx < 0) {
	                    nx = Math.round(nx / 2);
	                    //                      fx = 0;
	                  } else if (nx > self.page.maxw) {
	                    nx = self.page.maxw + Math.round((nx - self.page.maxw) / 2);
	                    //                      fx = 0;
	                  }
	                } else {
	                  if (nx < 0) {
	                    nx = 0;
	                    fx = 0;
	                  }
	                  if (nx > self.page.maxw) {
	                    nx = self.page.maxw;
	                    fx = 0;
	                  }
	                }
	              }

	              var grabbed = false;
	              if (self.rail.drag.dl) {
	                grabbed = true;
	                if (self.rail.drag.dl == "v") nx = self.rail.drag.sl;else if (self.rail.drag.dl == "h") ny = self.rail.drag.st;
	              } else {
	                var ay = Math.abs(my);
	                var ax = Math.abs(mx);
	                var dz = self.opt.directionlockdeadzone;
	                if (self.rail.drag.ck == "v") {
	                  if (ay > dz && ax <= ay * 0.3) {
	                    self.rail.drag = false;
	                    return true;
	                  } else if (ax > dz) {
	                    self.rail.drag.dl = "f";
	                    $("body").scrollTop($("body").scrollTop()); // stop iOS native scrolling (when active javascript has blocked)
	                  }
	                } else if (self.rail.drag.ck == "h") {
	                  if (ax > dz && ay <= ax * 0.3) {
	                    self.rail.drag = false;
	                    return true;
	                  } else if (ay > dz) {
	                    self.rail.drag.dl = "f";
	                    $("body").scrollLeft($("body").scrollLeft()); // stop iOS native scrolling (when active javascript has blocked)
	                  }
	                }
	              }

	              self.synched("touchmove", function () {
	                if (self.rail.drag && self.rail.drag.pt == 2) {
	                  if (self.prepareTransition) self.prepareTransition(0);
	                  if (self.rail.scrollable) self.setScrollTop(ny);
	                  self.scrollmom.update(fx, fy);
	                  if (self.railh && self.railh.scrollable) {
	                    self.setScrollLeft(nx);
	                    self.showCursor(ny, nx);
	                  } else {
	                    self.showCursor(ny);
	                  }
	                  if (cap.isie10) document.selection.clear();
	                }
	              });

	              if (cap.ischrome && self.istouchcapable) grabbed = false; //chrome touch emulation doesn't like!
	              if (grabbed) return self.cancelEvent(e);
	            } else if (self.rail.drag.pt == 1) {
	              // drag on cursor
	              return self.onmousemove(e);
	            }
	          };
	        }

	        self.onmousedown = function (e, hronly) {
	          if (self.rail.drag && self.rail.drag.pt != 1) return;
	          if (self.railslocked) return self.cancelEvent(e);
	          self.cancelScroll();
	          self.rail.drag = {
	            x: e.clientX,
	            y: e.clientY,
	            sx: self.scroll.x,
	            sy: self.scroll.y,
	            pt: 1,
	            hr: !!hronly
	          };
	          var tg = self.getTarget(e);
	          if (!self.ispage && cap.hasmousecapture) tg.setCapture();
	          if (self.isiframe && !cap.hasmousecapture) {
	            self.saved.csspointerevents = self.doc.css("pointer-events");
	            self.css(self.doc, {
	              "pointer-events": "none"
	            });
	          }
	          self.hasmoving = false;
	          return self.cancelEvent(e);
	        };

	        self.onmouseup = function (e) {
	          if (self.rail.drag) {
	            if (self.rail.drag.pt != 1) return true;
	            if (cap.hasmousecapture) document.releaseCapture();
	            if (self.isiframe && !cap.hasmousecapture) self.doc.css("pointer-events", self.saved.csspointerevents);
	            self.rail.drag = false;
	            //if (!self.rail.active) self.hideCursor();
	            if (self.hasmoving) self.triggerScrollEnd(); // TODO - check &&!self.scrollrunning
	            return self.cancelEvent(e);
	          }
	        };

	        self.onmousemove = function (e) {
	          if (self.rail.drag) {
	            if (self.rail.drag.pt != 1) return;

	            if (cap.ischrome && e.which == 0) return self.onmouseup(e);

	            self.cursorfreezed = true;
	            self.hasmoving = true;

	            if (self.rail.drag.hr) {
	              self.scroll.x = self.rail.drag.sx + (e.clientX - self.rail.drag.x);
	              if (self.scroll.x < 0) self.scroll.x = 0;
	              var mw = self.scrollvaluemaxw;
	              if (self.scroll.x > mw) self.scroll.x = mw;
	            } else {
	              self.scroll.y = self.rail.drag.sy + (e.clientY - self.rail.drag.y);
	              if (self.scroll.y < 0) self.scroll.y = 0;
	              var my = self.scrollvaluemax;
	              if (self.scroll.y > my) self.scroll.y = my;
	            }

	            self.synched('mousemove', function () {
	              if (self.rail.drag && self.rail.drag.pt == 1) {
	                self.showCursor();
	                if (self.rail.drag.hr) {
	                  if (self.hasreversehr) {
	                    self.doScrollLeft(self.scrollvaluemaxw - Math.round(self.scroll.x * self.scrollratio.x), self.opt.cursordragspeed);
	                  } else {
	                    self.doScrollLeft(Math.round(self.scroll.x * self.scrollratio.x), self.opt.cursordragspeed);
	                  }
	                } else self.doScrollTop(Math.round(self.scroll.y * self.scrollratio.y), self.opt.cursordragspeed);
	              }
	            });

	            return self.cancelEvent(e);
	          }
	          /*              
	          else {
	            self.checkarea = true;
	          }
	          */
	        };

	        if (cap.cantouch || self.opt.touchbehavior) {

	          self.onpreventclick = function (e) {
	            if (self.preventclick) {
	              self.preventclick.tg.onclick = self.preventclick.click;
	              self.preventclick = false;
	              return self.cancelEvent(e);
	            }
	          };

	          self.bind(self.win, "mousedown", self.ontouchstart); // control content dragging

	          self.onclick = cap.isios ? false : function (e) {
	            if (self.lastmouseup) {
	              self.lastmouseup = false;
	              return self.cancelEvent(e);
	            } else {
	              return true;
	            }
	          };

	          if (self.opt.grabcursorenabled && cap.cursorgrabvalue) {
	            self.css(self.ispage ? self.doc : self.win, {
	              'cursor': cap.cursorgrabvalue
	            });
	            self.css(self.rail, {
	              'cursor': cap.cursorgrabvalue
	            });
	          }
	        } else {

	          var checkSelectionScroll = function checkSelectionScroll(e) {
	            if (!self.selectiondrag) return;

	            if (e) {
	              var ww = self.win.outerHeight();
	              var df = e.pageY - self.selectiondrag.top;
	              if (df > 0 && df < ww) df = 0;
	              if (df >= ww) df -= ww;
	              self.selectiondrag.df = df;
	            }
	            if (self.selectiondrag.df == 0) return;

	            var rt = -Math.floor(self.selectiondrag.df / 6) * 2;
	            self.doScrollBy(rt);

	            self.debounced("doselectionscroll", function () {
	              checkSelectionScroll();
	            }, 50);
	          };

	          if ("getSelection" in document) {
	            // A grade - Major browsers
	            self.hasTextSelected = function () {
	              return document.getSelection().rangeCount > 0;
	            };
	          } else if ("selection" in document) {
	            //IE9-
	            self.hasTextSelected = function () {
	              return document.selection.type != "None";
	            };
	          } else {
	            self.hasTextSelected = function () {
	              // no support
	              return false;
	            };
	          }

	          self.onselectionstart = function (e) {
	            /*  More testing - severe chrome issues            
	                          if (!self.haswrapper&&(e.which&&e.which==2)) {  // fool browser to manage middle button scrolling
	                            self.win.css({'overflow':'auto'});
	                            setTimeout(function(){
	                              self.win.css({'overflow':''});
	                            },10);                
	                            return true;
	                          }            
	            */
	            if (self.ispage) return;
	            self.selectiondrag = self.win.offset();
	          };

	          self.onselectionend = function (e) {
	            self.selectiondrag = false;
	          };
	          self.onselectiondrag = function (e) {
	            if (!self.selectiondrag) return;
	            if (self.hasTextSelected()) self.debounced("selectionscroll", function () {
	              checkSelectionScroll(e);
	            }, 250);
	          };
	        }

	        if (cap.hasw3ctouch) {
	          //IE11+
	          self.css(self.rail, {
	            'touch-action': 'none'
	          });
	          self.css(self.cursor, {
	            'touch-action': 'none'
	          });
	          self.bind(self.win, "pointerdown", self.ontouchstart);
	          self.bind(document, "pointerup", self.ontouchend);
	          self.bind(document, "pointermove", self.ontouchmove);
	        } else if (cap.hasmstouch) {
	          //IE10
	          self.css(self.rail, {
	            '-ms-touch-action': 'none'
	          });
	          self.css(self.cursor, {
	            '-ms-touch-action': 'none'
	          });
	          self.bind(self.win, "MSPointerDown", self.ontouchstart);
	          self.bind(document, "MSPointerUp", self.ontouchend);
	          self.bind(document, "MSPointerMove", self.ontouchmove);
	          self.bind(self.cursor, "MSGestureHold", function (e) {
	            e.preventDefault();
	          });
	          self.bind(self.cursor, "contextmenu", function (e) {
	            e.preventDefault();
	          });
	        } else if (this.istouchcapable) {
	          //desktop with screen touch enabled
	          self.bind(self.win, "touchstart", self.ontouchstart);
	          self.bind(document, "touchend", self.ontouchend);
	          self.bind(document, "touchcancel", self.ontouchend);
	          self.bind(document, "touchmove", self.ontouchmove);
	        }

	        if (self.opt.cursordragontouch || !cap.cantouch && !self.opt.touchbehavior) {

	          self.rail.css({
	            "cursor": "default"
	          });
	          self.railh && self.railh.css({
	            "cursor": "default"
	          });

	          self.jqbind(self.rail, "mouseenter", function () {
	            if (!self.ispage && !self.win.is(":visible")) return false;
	            if (self.canshowonmouseevent) self.showCursor();
	            self.rail.active = true;
	          });
	          self.jqbind(self.rail, "mouseleave", function () {
	            self.rail.active = false;
	            if (!self.rail.drag) self.hideCursor();
	          });

	          if (self.opt.sensitiverail) {
	            self.bind(self.rail, "click", function (e) {
	              self.doRailClick(e, false, false);
	            });
	            self.bind(self.rail, "dblclick", function (e) {
	              self.doRailClick(e, true, false);
	            });
	            self.bind(self.cursor, "click", function (e) {
	              self.cancelEvent(e);
	            });
	            self.bind(self.cursor, "dblclick", function (e) {
	              self.cancelEvent(e);
	            });
	          }

	          if (self.railh) {
	            self.jqbind(self.railh, "mouseenter", function () {
	              if (!self.ispage && !self.win.is(":visible")) return false;
	              if (self.canshowonmouseevent) self.showCursor();
	              self.rail.active = true;
	            });
	            self.jqbind(self.railh, "mouseleave", function () {
	              self.rail.active = false;
	              if (!self.rail.drag) self.hideCursor();
	            });

	            if (self.opt.sensitiverail) {
	              self.bind(self.railh, "click", function (e) {
	                self.doRailClick(e, false, true);
	              });
	              self.bind(self.railh, "dblclick", function (e) {
	                self.doRailClick(e, true, true);
	              });
	              self.bind(self.cursorh, "click", function (e) {
	                self.cancelEvent(e);
	              });
	              self.bind(self.cursorh, "dblclick", function (e) {
	                self.cancelEvent(e);
	              });
	            }
	          }
	        }

	        if (!cap.cantouch && !self.opt.touchbehavior) {

	          self.bind(cap.hasmousecapture ? self.win : document, "mouseup", self.onmouseup);
	          self.bind(document, "mousemove", self.onmousemove);
	          if (self.onclick) self.bind(document, "click", self.onclick);

	          self.bind(self.cursor, "mousedown", self.onmousedown);
	          self.bind(self.cursor, "mouseup", self.onmouseup);

	          if (self.railh) {
	            self.bind(self.cursorh, "mousedown", function (e) {
	              self.onmousedown(e, true);
	            });
	            self.bind(self.cursorh, "mouseup", self.onmouseup);
	          }

	          if (!self.ispage && self.opt.enablescrollonselection) {
	            self.bind(self.win[0], "mousedown", self.onselectionstart);
	            self.bind(document, "mouseup", self.onselectionend);
	            self.bind(self.cursor, "mouseup", self.onselectionend);
	            if (self.cursorh) self.bind(self.cursorh, "mouseup", self.onselectionend);
	            self.bind(document, "mousemove", self.onselectiondrag);
	          }

	          if (self.zoom) {
	            self.jqbind(self.zoom, "mouseenter", function () {
	              if (self.canshowonmouseevent) self.showCursor();
	              self.rail.active = true;
	            });
	            self.jqbind(self.zoom, "mouseleave", function () {
	              self.rail.active = false;
	              if (!self.rail.drag) self.hideCursor();
	            });
	          }
	        } else {

	          self.bind(cap.hasmousecapture ? self.win : document, "mouseup", self.ontouchend);
	          self.bind(document, "mousemove", self.ontouchmove);
	          if (self.onclick) self.bind(document, "click", self.onclick);

	          if (self.opt.cursordragontouch) {
	            self.bind(self.cursor, "mousedown", self.onmousedown);
	            self.bind(self.cursor, "mouseup", self.onmouseup);
	            //self.bind(self.cursor, "mousemove", self.onmousemove);
	            self.cursorh && self.bind(self.cursorh, "mousedown", function (e) {
	              self.onmousedown(e, true);
	            });
	            //self.cursorh && self.bind(self.cursorh, "mousemove", self.onmousemove);
	            self.cursorh && self.bind(self.cursorh, "mouseup", self.onmouseup);
	          }
	        }

	        if (self.opt.enablemousewheel) {
	          if (!self.isiframe) self.bind(cap.isie && self.ispage ? document : self.win /*self.docscroll*/, "mousewheel", self.onmousewheel);
	          self.bind(self.rail, "mousewheel", self.onmousewheel);
	          if (self.railh) self.bind(self.railh, "mousewheel", self.onmousewheelhr);
	        }

	        if (!self.ispage && !cap.cantouch && !/HTML|^BODY/.test(self.win[0].nodeName)) {
	          if (!self.win.attr("tabindex")) self.win.attr({
	            "tabindex": tabindexcounter++
	          });

	          self.jqbind(self.win, "focus", function (e) {
	            domfocus = self.getTarget(e).id || true;
	            self.hasfocus = true;
	            if (self.canshowonmouseevent) self.noticeCursor();
	          });
	          self.jqbind(self.win, "blur", function (e) {
	            domfocus = false;
	            self.hasfocus = false;
	          });

	          self.jqbind(self.win, "mouseenter", function (e) {
	            mousefocus = self.getTarget(e).id || true;
	            self.hasmousefocus = true;
	            if (self.canshowonmouseevent) self.noticeCursor();
	          });
	          self.jqbind(self.win, "mouseleave", function () {
	            mousefocus = false;
	            self.hasmousefocus = false;
	            if (!self.rail.drag) self.hideCursor();
	          });
	        }
	      } // !ie9mobile

	      //Thanks to http://www.quirksmode.org !!
	      self.onkeypress = function (e) {
	        if (self.railslocked && self.page.maxh == 0) return true;

	        e = e ? e : window.e;
	        var tg = self.getTarget(e);
	        if (tg && /INPUT|TEXTAREA|SELECT|OPTION/.test(tg.nodeName)) {
	          var tp = tg.getAttribute('type') || tg.type || false;
	          if (!tp || !/submit|button|cancel/i.tp) return true;
	        }

	        if ($(tg).attr('contenteditable')) return true;

	        if (self.hasfocus || self.hasmousefocus && !domfocus || self.ispage && !domfocus && !mousefocus) {
	          var key = e.keyCode;

	          if (self.railslocked && key != 27) return self.cancelEvent(e);

	          var ctrl = e.ctrlKey || false;
	          var shift = e.shiftKey || false;

	          var ret = false;
	          switch (key) {
	            case 38:
	            case 63233:
	              //safari
	              self.doScrollBy(24 * 3);
	              ret = true;
	              break;
	            case 40:
	            case 63235:
	              //safari
	              self.doScrollBy(-24 * 3);
	              ret = true;
	              break;
	            case 37:
	            case 63232:
	              //safari
	              if (self.railh) {
	                ctrl ? self.doScrollLeft(0) : self.doScrollLeftBy(24 * 3);
	                ret = true;
	              }
	              break;
	            case 39:
	            case 63234:
	              //safari
	              if (self.railh) {
	                ctrl ? self.doScrollLeft(self.page.maxw) : self.doScrollLeftBy(-24 * 3);
	                ret = true;
	              }
	              break;
	            case 33:
	            case 63276:
	              // safari
	              self.doScrollBy(self.view.h);
	              ret = true;
	              break;
	            case 34:
	            case 63277:
	              // safari
	              self.doScrollBy(-self.view.h);
	              ret = true;
	              break;
	            case 36:
	            case 63273:
	              // safari                
	              self.railh && ctrl ? self.doScrollPos(0, 0) : self.doScrollTo(0);
	              ret = true;
	              break;
	            case 35:
	            case 63275:
	              // safari
	              self.railh && ctrl ? self.doScrollPos(self.page.maxw, self.page.maxh) : self.doScrollTo(self.page.maxh);
	              ret = true;
	              break;
	            case 32:
	              if (self.opt.spacebarenabled) {
	                shift ? self.doScrollBy(self.view.h) : self.doScrollBy(-self.view.h);
	                ret = true;
	              }
	              break;
	            case 27:
	              // ESC
	              if (self.zoomactive) {
	                self.doZoom();
	                ret = true;
	              }
	              break;
	          }
	          if (ret) return self.cancelEvent(e);
	        }
	      };

	      if (self.opt.enablekeyboard) self.bind(document, cap.isopera && !cap.isopera12 ? "keypress" : "keydown", self.onkeypress);

	      self.bind(document, "keydown", function (e) {
	        var ctrl = e.ctrlKey || false;
	        if (ctrl) self.wheelprevented = true;
	      });
	      self.bind(document, "keyup", function (e) {
	        var ctrl = e.ctrlKey || false;
	        if (!ctrl) self.wheelprevented = false;
	      });
	      self.bind(window, "blur", function (e) {
	        self.wheelprevented = false;
	      });

	      self.bind(window, 'resize', self.lazyResize);
	      self.bind(window, 'orientationchange', self.lazyResize);

	      self.bind(window, "load", self.lazyResize);

	      if (cap.ischrome && !self.ispage && !self.haswrapper) {
	        //chrome void scrollbar bug - it persists in version 26
	        var tmp = self.win.attr("style");
	        var ww = parseFloat(self.win.css("width")) + 1;
	        self.win.css('width', ww);
	        self.synched("chromefix", function () {
	          self.win.attr("style", tmp);
	        });
	      }

	      // Trying a cross-browser implementation - good luck!

	      self.onAttributeChange = function (e) {
	        self.lazyResize(self.isieold ? 250 : 30);
	      };

	      if (ClsMutationObserver !== false) {
	        self.observerbody = new ClsMutationObserver(function (mutations) {
	          mutations.forEach(function (mut) {
	            if (mut.type == "attributes") {
	              return $("body").hasClass("modal-open") ? self.hide() : self.show(); // Support for Bootstrap modal
	            }
	          });
	          if (document.body.scrollHeight != self.page.maxh) return self.lazyResize(30);
	        });
	        self.observerbody.observe(document.body, {
	          childList: true,
	          subtree: true,
	          characterData: false,
	          attributes: true,
	          attributeFilter: ['class']
	        });
	      }

	      if (!self.ispage && !self.haswrapper) {
	        // redesigned MutationObserver for Chrome18+/Firefox14+/iOS6+ with support for: remove div, add/remove content
	        if (ClsMutationObserver !== false) {
	          self.observer = new ClsMutationObserver(function (mutations) {
	            mutations.forEach(self.onAttributeChange);
	          });
	          self.observer.observe(self.win[0], {
	            childList: true,
	            characterData: false,
	            attributes: true,
	            subtree: false
	          });
	          self.observerremover = new ClsMutationObserver(function (mutations) {
	            mutations.forEach(function (mo) {
	              if (mo.removedNodes.length > 0) {
	                for (var dd in mo.removedNodes) {
	                  if (!!self && mo.removedNodes[dd] == self.win[0]) return self.remove();
	                }
	              }
	            });
	          });
	          self.observerremover.observe(self.win[0].parentNode, {
	            childList: true,
	            characterData: false,
	            attributes: false,
	            subtree: false
	          });
	        } else {
	          self.bind(self.win, cap.isie && !cap.isie9 ? "propertychange" : "DOMAttrModified", self.onAttributeChange);
	          if (cap.isie9) self.win[0].attachEvent("onpropertychange", self.onAttributeChange); //IE9 DOMAttrModified bug
	          self.bind(self.win, "DOMNodeRemoved", function (e) {
	            if (e.target == self.win[0]) self.remove();
	          });
	        }
	      }

	      //

	      if (!self.ispage && self.opt.boxzoom) self.bind(window, "resize", self.resizeZoom);
	      if (self.istextarea) self.bind(self.win, "mouseup", self.lazyResize);

	      //        self.checkrtlmode = true;
	      self.lazyResize(30);
	    }

	    if (this.doc[0].nodeName == 'IFRAME') {
	      var oniframeload = function oniframeload() {
	        self.iframexd = false;
	        var doc;
	        try {
	          doc = 'contentDocument' in this ? this.contentDocument : this.contentWindow.document;
	          var a = doc.domain;
	        } catch (e) {
	          self.iframexd = true;
	          doc = false;
	        }

	        if (self.iframexd) {
	          if ("console" in window) console.log('NiceScroll error: policy restriced iframe');
	          return true; //cross-domain - I can't manage this        
	        }

	        self.forcescreen = true;

	        if (self.isiframe) {
	          self.iframe = {
	            "doc": $(doc),
	            "html": self.doc.contents().find('html')[0],
	            "body": self.doc.contents().find('body')[0]
	          };
	          self.getContentSize = function () {
	            return {
	              w: Math.max(self.iframe.html.scrollWidth, self.iframe.body.scrollWidth),
	              h: Math.max(self.iframe.html.scrollHeight, self.iframe.body.scrollHeight)
	            };
	          };
	          self.docscroll = $(self.iframe.body); //$(this.contentWindow);
	        }

	        if (!cap.isios && self.opt.iframeautoresize && !self.isiframe) {
	          self.win.scrollTop(0); // reset position
	          self.doc.height(""); //reset height to fix browser bug
	          var hh = Math.max(doc.getElementsByTagName('html')[0].scrollHeight, doc.body.scrollHeight);
	          self.doc.height(hh);
	        }
	        self.lazyResize(30);

	        if (cap.isie7) self.css($(self.iframe.html), {
	          'overflow-y': 'hidden'
	        });
	        self.css($(self.iframe.body), {
	          'overflow-y': 'hidden'
	        });

	        if (cap.isios && self.haswrapper) {
	          self.css($(doc.body), {
	            '-webkit-transform': 'translate3d(0,0,0)'
	          }); // avoid iFrame content clipping - thanks to http://blog.derraab.com/2012/04/02/avoid-iframe-content-clipping-with-css-transform-on-ios/
	        }

	        if ('contentWindow' in this) {
	          self.bind(this.contentWindow, "scroll", self.onscroll); //IE8 & minor
	        } else {
	          self.bind(doc, "scroll", self.onscroll);
	        }

	        if (self.opt.enablemousewheel) {
	          self.bind(doc, "mousewheel", self.onmousewheel);
	        }

	        if (self.opt.enablekeyboard) self.bind(doc, cap.isopera ? "keypress" : "keydown", self.onkeypress);

	        if (cap.cantouch || self.opt.touchbehavior) {
	          self.bind(doc, "mousedown", self.ontouchstart);
	          self.bind(doc, "mousemove", function (e) {
	            return self.ontouchmove(e, true);
	          });
	          if (self.opt.grabcursorenabled && cap.cursorgrabvalue) self.css($(doc.body), {
	            'cursor': cap.cursorgrabvalue
	          });
	        }

	        self.bind(doc, "mouseup", self.ontouchend);

	        if (self.zoom) {
	          if (self.opt.dblclickzoom) self.bind(doc, 'dblclick', self.doZoom);
	          if (self.ongesturezoom) self.bind(doc, "gestureend", self.ongesturezoom);
	        }
	      };

	      if (this.doc[0].readyState && this.doc[0].readyState == "complete") {
	        setTimeout(function () {
	          oniframeload.call(self.doc[0], false);
	        }, 500);
	      }
	      self.bind(this.doc, "load", oniframeload);
	    }
	  };

	  this.showCursor = function (py, px) {
	    if (self.cursortimeout) {
	      clearTimeout(self.cursortimeout);
	      self.cursortimeout = 0;
	    }
	    if (!self.rail) return;
	    if (self.autohidedom) {
	      self.autohidedom.stop().css({
	        opacity: self.opt.cursoropacitymax
	      });
	      self.cursoractive = true;
	    }

	    if (!self.rail.drag || self.rail.drag.pt != 1) {
	      if (typeof py != "undefined" && py !== false) {
	        self.scroll.y = Math.round(py * 1 / self.scrollratio.y);
	      }
	      if (typeof px != "undefined") {
	        self.scroll.x = Math.round(px * 1 / self.scrollratio.x);
	      }
	    }

	    self.cursor.css({
	      height: self.cursorheight,
	      top: self.scroll.y
	    });
	    if (self.cursorh) {
	      var lx = self.hasreversehr ? self.scrollvaluemaxw - self.scroll.x : self.scroll.x;
	      !self.rail.align && self.rail.visibility ? self.cursorh.css({
	        width: self.cursorwidth,
	        left: lx + self.rail.width
	      }) : self.cursorh.css({
	        width: self.cursorwidth,
	        left: lx
	      });
	      self.cursoractive = true;
	    }

	    if (self.zoom) self.zoom.stop().css({
	      opacity: self.opt.cursoropacitymax
	    });
	  };

	  this.hideCursor = function (tm) {
	    if (self.cursortimeout) return;
	    if (!self.rail) return;
	    if (!self.autohidedom) return;
	    if (self.hasmousefocus && self.opt.autohidemode == "leave") return;
	    self.cursortimeout = setTimeout(function () {
	      if (!self.rail.active || !self.showonmouseevent) {
	        self.autohidedom.stop().animate({
	          opacity: self.opt.cursoropacitymin
	        });
	        if (self.zoom) self.zoom.stop().animate({
	          opacity: self.opt.cursoropacitymin
	        });
	        self.cursoractive = false;
	      }
	      self.cursortimeout = 0;
	    }, tm || self.opt.hidecursordelay);
	  };

	  this.noticeCursor = function (tm, py, px) {
	    self.showCursor(py, px);
	    if (!self.rail.active) self.hideCursor(tm);
	  };

	  this.getContentSize = self.ispage ? function () {
	    return {
	      w: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
	      h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
	    };
	  } : self.haswrapper ? function () {
	    return {
	      w: self.doc.outerWidth() + parseInt(self.win.css('paddingLeft')) + parseInt(self.win.css('paddingRight')),
	      h: self.doc.outerHeight() + parseInt(self.win.css('paddingTop')) + parseInt(self.win.css('paddingBottom'))
	    };
	  } : function () {
	    return {
	      w: self.docscroll[0].scrollWidth,
	      h: self.docscroll[0].scrollHeight
	    };
	  };

	  this.onResize = function (e, page) {

	    if (!self || !self.win) return false;

	    if (!self.haswrapper && !self.ispage) {
	      if (self.win.css('display') == 'none') {
	        if (self.visibility) self.hideRail().hideRailHr();
	        return false;
	      } else {
	        if (!self.hidden && !self.visibility) self.showRail().showRailHr();
	      }
	    }

	    var premaxh = self.page.maxh;
	    var premaxw = self.page.maxw;

	    var preview = {
	      h: self.view.h,
	      w: self.view.w
	    };

	    self.view = {
	      w: self.ispage ? self.win.width() : parseInt(self.win[0].clientWidth),
	      h: self.ispage ? self.win.height() : parseInt(self.win[0].clientHeight)
	    };

	    self.page = page ? page : self.getContentSize();

	    self.page.maxh = Math.max(0, self.page.h - self.view.h);
	    self.page.maxw = Math.max(0, self.page.w - self.view.w);

	    if (self.page.maxh == premaxh && self.page.maxw == premaxw && self.view.w == preview.w && self.view.h == preview.h) {
	      // test position        
	      if (!self.ispage) {
	        var pos = self.win.offset();
	        if (self.lastposition) {
	          var lst = self.lastposition;
	          if (lst.top == pos.top && lst.left == pos.left) return self; //nothing to do            
	        }
	        self.lastposition = pos;
	      } else {
	        return self; //nothing to do
	      }
	    }

	    if (self.page.maxh == 0) {
	      self.hideRail();
	      self.scrollvaluemax = 0;
	      self.scroll.y = 0;
	      self.scrollratio.y = 0;
	      self.cursorheight = 0;
	      self.setScrollTop(0);
	      self.rail.scrollable = false;
	    } else {
	      self.page.maxh -= self.opt.railpadding.top + self.opt.railpadding.bottom; //**
	      self.rail.scrollable = true;
	    }

	    if (self.page.maxw == 0) {
	      self.hideRailHr();
	      self.scrollvaluemaxw = 0;
	      self.scroll.x = 0;
	      self.scrollratio.x = 0;
	      self.cursorwidth = 0;
	      self.setScrollLeft(0);
	      self.railh.scrollable = false;
	    } else {
	      self.page.maxw -= self.opt.railpadding.left + self.opt.railpadding.right; //**
	      self.railh.scrollable = true;
	    }

	    self.railslocked = self.locked || self.page.maxh == 0 && self.page.maxw == 0;
	    if (self.railslocked) {
	      if (!self.ispage) self.updateScrollBar(self.view);
	      return false;
	    }

	    if (!self.hidden && !self.visibility) {
	      self.showRail().showRailHr();
	    } else if (!self.hidden && !self.railh.visibility) self.showRailHr();

	    if (self.istextarea && self.win.css('resize') && self.win.css('resize') != 'none') self.view.h -= 20;

	    self.cursorheight = Math.min(self.view.h, Math.round(self.view.h * (self.view.h / self.page.h)));
	    self.cursorheight = self.opt.cursorfixedheight ? self.opt.cursorfixedheight : Math.max(self.opt.cursorminheight, self.cursorheight);

	    self.cursorwidth = Math.min(self.view.w, Math.round(self.view.w * (self.view.w / self.page.w)));
	    self.cursorwidth = self.opt.cursorfixedheight ? self.opt.cursorfixedheight : Math.max(self.opt.cursorminheight, self.cursorwidth);

	    self.scrollvaluemax = self.view.h - self.cursorheight - self.cursor.hborder - (self.opt.railpadding.top + self.opt.railpadding.bottom); //**

	    if (self.railh) {
	      self.railh.width = self.page.maxh > 0 ? self.view.w - self.rail.width : self.view.w;
	      self.scrollvaluemaxw = self.railh.width - self.cursorwidth - self.cursorh.wborder - (self.opt.railpadding.left + self.opt.railpadding.right); //**
	    }

	    /*
	    if (self.checkrtlmode&&self.railh) {
	      self.checkrtlmode = false;
	      if (self.opt.rtlmode&&self.scroll.x==0) self.setScrollLeft(self.page.maxw);
	    }
	    */

	    if (!self.ispage) self.updateScrollBar(self.view);

	    self.scrollratio = {
	      x: self.page.maxw / self.scrollvaluemaxw,
	      y: self.page.maxh / self.scrollvaluemax
	    };

	    var sy = self.getScrollTop();
	    if (sy > self.page.maxh) {
	      self.doScrollTop(self.page.maxh);
	    } else {
	      self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y));
	      self.scroll.x = Math.round(self.getScrollLeft() * (1 / self.scrollratio.x));
	      if (self.cursoractive) self.noticeCursor();
	    }

	    if (self.scroll.y && self.getScrollTop() == 0) self.doScrollTo(Math.floor(self.scroll.y * self.scrollratio.y));

	    return self;
	  };

	  this.resize = self.onResize;

	  this.lazyResize = function (tm) {
	    // event debounce
	    tm = isNaN(tm) ? 30 : tm;
	    self.debounced('resize', self.resize, tm);
	    return self;
	  };

	  // modified by MDN https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/wheel
	  function _modernWheelEvent(dom, name, fn, bubble) {
	    self._bind(dom, name, function (e) {
	      var e = e ? e : window.event;
	      var event = {
	        original: e,
	        target: e.target || e.srcElement,
	        type: "wheel",
	        deltaMode: e.type == "MozMousePixelScroll" ? 0 : 1,
	        deltaX: 0,
	        deltaZ: 0,
	        preventDefault: function preventDefault() {
	          e.preventDefault ? e.preventDefault() : e.returnValue = false;
	          return false;
	        },
	        stopImmediatePropagation: function stopImmediatePropagation() {
	          e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.cancelBubble = true;
	        }
	      };

	      if (name == "mousewheel") {
	        event.deltaY = -1 / 40 * e.wheelDelta;
	        e.wheelDeltaX && (event.deltaX = -1 / 40 * e.wheelDeltaX);
	      } else {
	        event.deltaY = e.detail;
	      }

	      return fn.call(dom, event);
	    }, bubble);
	  };

	  this.jqbind = function (dom, name, fn) {
	    // use jquery bind for non-native events (mouseenter/mouseleave)
	    self.events.push({
	      e: dom,
	      n: name,
	      f: fn,
	      q: true
	    });
	    $(dom).bind(name, fn);
	  };

	  this.bind = function (dom, name, fn, bubble) {
	    // touch-oriented & fixing jquery bind
	    var el = "jquery" in dom ? dom[0] : dom;

	    if (name == 'mousewheel') {
	      if (window.addEventListener || 'onwheel' in document) {
	        // modern brosers & IE9 detection fix
	        self._bind(el, "wheel", fn, bubble || false);
	      } else {
	        var wname = typeof document.onmousewheel != "undefined" ? "mousewheel" : "DOMMouseScroll"; // older IE/Firefox
	        _modernWheelEvent(el, wname, fn, bubble || false);
	        if (wname == "DOMMouseScroll") _modernWheelEvent(el, "MozMousePixelScroll", fn, bubble || false); // Firefox legacy
	      }
	    } else if (el.addEventListener) {
	      if (cap.cantouch && /mouseup|mousedown|mousemove/.test(name)) {
	        // touch device support
	        var tt = name == 'mousedown' ? 'touchstart' : name == 'mouseup' ? 'touchend' : 'touchmove';
	        self._bind(el, tt, function (e) {
	          if (e.touches) {
	            if (e.touches.length < 2) {
	              var ev = e.touches.length ? e.touches[0] : e;
	              ev.original = e;
	              fn.call(this, ev);
	            }
	          } else if (e.changedTouches) {
	            var ev = e.changedTouches[0];
	            ev.original = e;
	            fn.call(this, ev);
	          } //blackberry
	        }, bubble || false);
	      }
	      self._bind(el, name, fn, bubble || false);
	      if (cap.cantouch && name == "mouseup") self._bind(el, "touchcancel", fn, bubble || false);
	    } else {
	      self._bind(el, name, function (e) {
	        e = e || window.event || false;
	        if (e) {
	          if (e.srcElement) e.target = e.srcElement;
	        }
	        if (!("pageY" in e)) {
	          e.pageX = e.clientX + document.documentElement.scrollLeft;
	          e.pageY = e.clientY + document.documentElement.scrollTop;
	        }
	        return fn.call(el, e) === false || bubble === false ? self.cancelEvent(e) : true;
	      });
	    }
	  };

	  if (cap.haseventlistener) {
	    // W3C standard model
	    this._bind = function (el, name, fn, bubble) {
	      // primitive bind
	      self.events.push({
	        e: el,
	        n: name,
	        f: fn,
	        b: bubble,
	        q: false
	      });
	      el.addEventListener(name, fn, bubble || false);
	    };
	    this.cancelEvent = function (e) {
	      if (!e) return false;
	      var e = e.original ? e.original : e;
	      e.preventDefault();
	      e.stopPropagation();
	      if (e.preventManipulation) e.preventManipulation(); //IE10
	      return false;
	    };
	    this.stopPropagation = function (e) {
	      if (!e) return false;
	      var e = e.original ? e.original : e;
	      e.stopPropagation();
	      return false;
	    };
	    this._unbind = function (el, name, fn, bub) {
	      // primitive unbind
	      el.removeEventListener(name, fn, bub);
	    };
	  } else {
	    // old IE model
	    this._bind = function (el, name, fn, bubble) {
	      // primitive bind
	      self.events.push({
	        e: el,
	        n: name,
	        f: fn,
	        b: bubble,
	        q: false
	      });
	      if (el.attachEvent) {
	        el.attachEvent("on" + name, fn);
	      } else {
	        el["on" + name] = fn;
	      }
	    };
	    // Thanks to http://www.switchonthecode.com !!
	    this.cancelEvent = function (e) {
	      var e = window.event || false;
	      if (!e) return false;
	      e.cancelBubble = true;
	      e.cancel = true;
	      e.returnValue = false;
	      return false;
	    };
	    this.stopPropagation = function (e) {
	      var e = window.event || false;
	      if (!e) return false;
	      e.cancelBubble = true;
	      return false;
	    };
	    this._unbind = function (el, name, fn, bub) {
	      // primitive unbind IE old
	      if (el.detachEvent) {
	        el.detachEvent('on' + name, fn);
	      } else {
	        el['on' + name] = false;
	      }
	    };
	  }

	  this.unbindAll = function () {
	    for (var a = 0; a < self.events.length; a++) {
	      var r = self.events[a];
	      r.q ? r.e.unbind(r.n, r.f) : self._unbind(r.e, r.n, r.f, r.b);
	    }
	  };

	  this.showRail = function () {
	    if (self.page.maxh != 0 && (self.ispage || self.win.css('display') != 'none')) {
	      self.visibility = true;
	      self.rail.visibility = true;
	      self.rail.css('display', 'block');
	    }
	    return self;
	  };

	  this.showRailHr = function () {
	    if (!self.railh) return self;
	    if (self.page.maxw != 0 && (self.ispage || self.win.css('display') != 'none')) {
	      self.railh.visibility = true;
	      self.railh.css('display', 'block');
	    }
	    return self;
	  };

	  this.hideRail = function () {
	    self.visibility = false;
	    self.rail.visibility = false;
	    self.rail.css('display', 'none');
	    return self;
	  };

	  this.hideRailHr = function () {
	    if (!self.railh) return self;
	    self.railh.visibility = false;
	    self.railh.css('display', 'none');
	    return self;
	  };

	  this.show = function () {
	    self.hidden = false;
	    self.railslocked = false;
	    return self.showRail().showRailHr();
	  };

	  this.hide = function () {
	    self.hidden = true;
	    self.railslocked = true;
	    return self.hideRail().hideRailHr();
	  };

	  this.toggle = function () {
	    return self.hidden ? self.show() : self.hide();
	  };

	  this.remove = function () {
	    self.stop();
	    if (self.cursortimeout) clearTimeout(self.cursortimeout);
	    self.doZoomOut();
	    self.unbindAll();

	    if (cap.isie9) self.win[0].detachEvent("onpropertychange", self.onAttributeChange); //IE9 DOMAttrModified bug

	    if (self.observer !== false) self.observer.disconnect();
	    if (self.observerremover !== false) self.observerremover.disconnect();
	    if (self.observerbody !== false) self.observerbody.disconnect();

	    self.events = null;

	    if (self.cursor) {
	      self.cursor.remove();
	    }
	    if (self.cursorh) {
	      self.cursorh.remove();
	    }
	    if (self.rail) {
	      self.rail.remove();
	    }
	    if (self.railh) {
	      self.railh.remove();
	    }
	    if (self.zoom) {
	      self.zoom.remove();
	    }
	    for (var a = 0; a < self.saved.css.length; a++) {
	      var d = self.saved.css[a];
	      d[0].css(d[1], typeof d[2] == "undefined" ? '' : d[2]);
	    }
	    self.saved = false;
	    self.me.data('__nicescroll', ''); //erase all traces

	    // memory leak fixed by GianlucaGuarini - thanks a lot!
	    // remove the current nicescroll from the $.nicescroll array & normalize array
	    var lst = $.nicescroll;
	    lst.each(function (i) {
	      if (!this) return;
	      if (this.id === self.id) {
	        delete lst[i];
	        for (var b = ++i; b < lst.length; b++, i++) {
	          lst[i] = lst[b];
	        }lst.length--;
	        if (lst.length) delete lst[lst.length];
	      }
	    });

	    for (var i in self) {
	      self[i] = null;
	      delete self[i];
	    }

	    self = null;
	  };

	  this.scrollstart = function (fn) {
	    this.onscrollstart = fn;
	    return self;
	  };
	  this.scrollend = function (fn) {
	    this.onscrollend = fn;
	    return self;
	  };
	  this.scrollcancel = function (fn) {
	    this.onscrollcancel = fn;
	    return self;
	  };

	  this.zoomin = function (fn) {
	    this.onzoomin = fn;
	    return self;
	  };
	  this.zoomout = function (fn) {
	    this.onzoomout = fn;
	    return self;
	  };

	  this.isScrollable = function (e) {
	    var dom = e.target ? e.target : e;
	    if (dom.nodeName == 'OPTION') return true;
	    while (dom && dom.nodeType == 1 && !/^BODY|HTML/.test(dom.nodeName)) {
	      var dd = $(dom);
	      var ov = dd.css('overflowY') || dd.css('overflowX') || dd.css('overflow') || '';
	      if (/scroll|auto/.test(ov)) return dom.clientHeight != dom.scrollHeight;
	      dom = dom.parentNode ? dom.parentNode : false;
	    }
	    return false;
	  };

	  this.getViewport = function (me) {
	    var dom = me && me.parentNode ? me.parentNode : false;
	    while (dom && dom.nodeType == 1 && !/^BODY|HTML/.test(dom.nodeName)) {
	      var dd = $(dom);
	      if (/fixed|absolute/.test(dd.css("position"))) return dd;
	      var ov = dd.css('overflowY') || dd.css('overflowX') || dd.css('overflow') || '';
	      if (/scroll|auto/.test(ov) && dom.clientHeight != dom.scrollHeight) return dd;
	      if (dd.getNiceScroll().length > 0) return dd;
	      dom = dom.parentNode ? dom.parentNode : false;
	    }
	    return false; //(dom) ? $(dom) : false;
	  };

	  this.triggerScrollEnd = function () {
	    if (!self.onscrollend) return;

	    var px = self.getScrollLeft();
	    var py = self.getScrollTop();

	    var info = {
	      "type": "scrollend",
	      "current": {
	        "x": px,
	        "y": py
	      },
	      "end": {
	        "x": px,
	        "y": py
	      }
	    };
	    self.onscrollend.call(self, info);
	  };

	  function execScrollWheel(e, hr, chkscroll) {
	    var px, py;

	    if (e.deltaMode == 0) {
	      // PIXEL
	      px = -Math.floor(e.deltaX * (self.opt.mousescrollstep / (18 * 3)));
	      py = -Math.floor(e.deltaY * (self.opt.mousescrollstep / (18 * 3)));
	    } else if (e.deltaMode == 1) {
	      // LINE
	      px = -Math.floor(e.deltaX * self.opt.mousescrollstep);
	      py = -Math.floor(e.deltaY * self.opt.mousescrollstep);
	    }

	    if (hr && self.opt.oneaxismousemode && px == 0 && py) {
	      // classic vertical-only mousewheel + browser with x/y support 
	      px = py;
	      py = 0;

	      if (chkscroll) {
	        var hrend = px < 0 ? self.getScrollLeft() >= self.page.maxw : self.getScrollLeft() <= 0;
	        if (hrend) {
	          // preserve vertical scrolling
	          py = px;
	          px = 0;
	        }
	      }
	    }

	    if (px) {
	      if (self.scrollmom) {
	        self.scrollmom.stop();
	      }
	      self.lastdeltax += px;
	      self.debounced("mousewheelx", function () {
	        var dt = self.lastdeltax;
	        self.lastdeltax = 0;
	        if (!self.rail.drag) {
	          self.doScrollLeftBy(dt);
	        }
	      }, 15);
	    }
	    if (py) {
	      if (self.opt.nativeparentscrolling && chkscroll && !self.ispage && !self.zoomactive) {
	        if (py < 0) {
	          if (self.getScrollTop() >= self.page.maxh) return true;
	        } else {
	          if (self.getScrollTop() <= 0) return true;
	        }
	      }
	      if (self.scrollmom) {
	        self.scrollmom.stop();
	      }
	      self.lastdeltay += py;
	      self.debounced("mousewheely", function () {
	        var dt = self.lastdeltay;
	        self.lastdeltay = 0;
	        if (!self.rail.drag) {
	          self.doScrollBy(dt);
	        }
	      }, 15);
	    }

	    e.stopImmediatePropagation();
	    return e.preventDefault();
	  };

	  this.onmousewheel = function (e) {
	    if (self.wheelprevented) return;
	    if (self.railslocked) {
	      self.debounced("checkunlock", self.resize, 250);
	      return true;
	    }
	    if (self.rail.drag) return self.cancelEvent(e);

	    if (self.opt.oneaxismousemode == "auto" && e.deltaX != 0) self.opt.oneaxismousemode = false; // check two-axis mouse support (not very elegant)

	    if (self.opt.oneaxismousemode && e.deltaX == 0) {
	      if (!self.rail.scrollable) {
	        if (self.railh && self.railh.scrollable) {
	          return self.onmousewheelhr(e);
	        } else {
	          return true;
	        }
	      }
	    }

	    var nw = +new Date();
	    var chk = false;
	    if (self.opt.preservenativescrolling && self.checkarea + 600 < nw) {
	      self.nativescrollingarea = self.isScrollable(e);
	      chk = true;
	    }
	    self.checkarea = nw;
	    if (self.nativescrollingarea) return true; // this isn't my business
	    var ret = execScrollWheel(e, false, chk);
	    if (ret) self.checkarea = 0;
	    return ret;
	  };

	  this.onmousewheelhr = function (e) {
	    if (self.wheelprevented) return;
	    if (self.railslocked || !self.railh.scrollable) return true;
	    if (self.rail.drag) return self.cancelEvent(e);

	    var nw = +new Date();
	    var chk = false;
	    if (self.opt.preservenativescrolling && self.checkarea + 600 < nw) {
	      self.nativescrollingarea = self.isScrollable(e);
	      chk = true;
	    }
	    self.checkarea = nw;
	    if (self.nativescrollingarea) return true; // this isn't my business
	    if (self.railslocked) return self.cancelEvent(e);

	    return execScrollWheel(e, true, chk);
	  };

	  this.stop = function () {
	    self.cancelScroll();
	    if (self.scrollmon) self.scrollmon.stop();
	    self.cursorfreezed = false;
	    self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y));
	    self.noticeCursor();
	    return self;
	  };

	  this.getTransitionSpeed = function (dif) {
	    var sp = Math.round(self.opt.scrollspeed * 10);
	    var ex = Math.min(sp, Math.round(dif / 20 * self.opt.scrollspeed));
	    return ex > 20 ? ex : 0;
	  };

	  if (!self.opt.smoothscroll) {
	    this.doScrollLeft = function (x, spd) {
	      //direct
	      var y = self.getScrollTop();
	      self.doScrollPos(x, y, spd);
	    };
	    this.doScrollTop = function (y, spd) {
	      //direct
	      var x = self.getScrollLeft();
	      self.doScrollPos(x, y, spd);
	    };
	    this.doScrollPos = function (x, y, spd) {
	      //direct
	      var nx = x > self.page.maxw ? self.page.maxw : x;
	      if (nx < 0) nx = 0;
	      var ny = y > self.page.maxh ? self.page.maxh : y;
	      if (ny < 0) ny = 0;
	      self.synched('scroll', function () {
	        self.setScrollTop(ny);
	        self.setScrollLeft(nx);
	      });
	    };
	    this.cancelScroll = function () {}; // direct
	  } else if (self.ishwscroll && cap.hastransition && self.opt.usetransition && !!self.opt.smoothscroll) {
	    this.prepareTransition = function (dif, istime) {
	      var ex = istime ? dif > 20 ? dif : 0 : self.getTransitionSpeed(dif);
	      var trans = ex ? cap.prefixstyle + 'transform ' + ex + 'ms ease-out' : '';
	      if (!self.lasttransitionstyle || self.lasttransitionstyle != trans) {
	        self.lasttransitionstyle = trans;
	        self.doc.css(cap.transitionstyle, trans);
	      }
	      return ex;
	    };

	    this.doScrollLeft = function (x, spd) {
	      //trans
	      var y = self.scrollrunning ? self.newscrolly : self.getScrollTop();
	      self.doScrollPos(x, y, spd);
	    };

	    this.doScrollTop = function (y, spd) {
	      //trans
	      var x = self.scrollrunning ? self.newscrollx : self.getScrollLeft();
	      self.doScrollPos(x, y, spd);
	    };

	    this.doScrollPos = function (x, y, spd) {
	      //trans

	      var py = self.getScrollTop();
	      var px = self.getScrollLeft();

	      if ((self.newscrolly - py) * (y - py) < 0 || (self.newscrollx - px) * (x - px) < 0) self.cancelScroll(); //inverted movement detection      

	      if (self.opt.bouncescroll == false) {
	        if (y < 0) y = 0;else if (y > self.page.maxh) y = self.page.maxh;
	        if (x < 0) x = 0;else if (x > self.page.maxw) x = self.page.maxw;
	      }

	      if (self.scrollrunning && x == self.newscrollx && y == self.newscrolly) return false;

	      self.newscrolly = y;
	      self.newscrollx = x;

	      self.newscrollspeed = spd || false;

	      if (self.timer) return false;

	      self.timer = setTimeout(function () {

	        var top = self.getScrollTop();
	        var lft = self.getScrollLeft();

	        var dst = {};
	        dst.x = x - lft;
	        dst.y = y - top;
	        dst.px = lft;
	        dst.py = top;

	        var dd = Math.round(Math.sqrt(Math.pow(dst.x, 2) + Math.pow(dst.y, 2)));
	        var ms = self.newscrollspeed && self.newscrollspeed > 1 ? self.newscrollspeed : self.getTransitionSpeed(dd);
	        if (self.newscrollspeed && self.newscrollspeed <= 1) ms *= self.newscrollspeed;

	        self.prepareTransition(ms, true);

	        if (self.timerscroll && self.timerscroll.tm) clearInterval(self.timerscroll.tm);

	        if (ms > 0) {

	          if (!self.scrollrunning && self.onscrollstart) {
	            var info = {
	              "type": "scrollstart",
	              "current": {
	                "x": lft,
	                "y": top
	              },
	              "request": {
	                "x": x,
	                "y": y
	              },
	              "end": {
	                "x": self.newscrollx,
	                "y": self.newscrolly
	              },
	              "speed": ms
	            };
	            self.onscrollstart.call(self, info);
	          }

	          if (cap.transitionend) {
	            if (!self.scrollendtrapped) {
	              self.scrollendtrapped = true;
	              self.bind(self.doc, cap.transitionend, self.onScrollTransitionEnd, false); //I have got to do something usefull!!
	            }
	          } else {
	            if (self.scrollendtrapped) clearTimeout(self.scrollendtrapped);
	            self.scrollendtrapped = setTimeout(self.onScrollTransitionEnd, ms); // simulate transitionend event
	          }

	          var py = top;
	          var px = lft;
	          self.timerscroll = {
	            bz: new BezierClass(py, self.newscrolly, ms, 0, 0, 0.58, 1),
	            bh: new BezierClass(px, self.newscrollx, ms, 0, 0, 0.58, 1)
	          };
	          if (!self.cursorfreezed) self.timerscroll.tm = setInterval(function () {
	            self.showCursor(self.getScrollTop(), self.getScrollLeft());
	          }, 60);
	        }

	        self.synched("doScroll-set", function () {
	          self.timer = 0;
	          if (self.scrollendtrapped) self.scrollrunning = true;
	          self.setScrollTop(self.newscrolly);
	          self.setScrollLeft(self.newscrollx);
	          if (!self.scrollendtrapped) self.onScrollTransitionEnd();
	        });
	      }, 50);
	    };

	    this.cancelScroll = function () {
	      if (!self.scrollendtrapped) return true;
	      var py = self.getScrollTop();
	      var px = self.getScrollLeft();
	      self.scrollrunning = false;
	      if (!cap.transitionend) clearTimeout(cap.transitionend);
	      self.scrollendtrapped = false;
	      self._unbind(self.doc[0], cap.transitionend, self.onScrollTransitionEnd);
	      self.prepareTransition(0);
	      self.setScrollTop(py); // fire event onscroll
	      if (self.railh) self.setScrollLeft(px);
	      if (self.timerscroll && self.timerscroll.tm) clearInterval(self.timerscroll.tm);
	      self.timerscroll = false;

	      self.cursorfreezed = false;

	      self.showCursor(py, px);
	      return self;
	    };
	    this.onScrollTransitionEnd = function () {
	      if (self.scrollendtrapped) self._unbind(self.doc[0], cap.transitionend, self.onScrollTransitionEnd);
	      self.scrollendtrapped = false;
	      self.prepareTransition(0);
	      if (self.timerscroll && self.timerscroll.tm) clearInterval(self.timerscroll.tm);
	      self.timerscroll = false;
	      var py = self.getScrollTop();
	      var px = self.getScrollLeft();
	      self.setScrollTop(py); // fire event onscroll        
	      if (self.railh) self.setScrollLeft(px); // fire event onscroll left

	      self.noticeCursor(false, py, px);

	      self.cursorfreezed = false;

	      if (py < 0) py = 0;else if (py > self.page.maxh) py = self.page.maxh;
	      if (px < 0) px = 0;else if (px > self.page.maxw) px = self.page.maxw;
	      if (py != self.newscrolly || px != self.newscrollx) return self.doScrollPos(px, py, self.opt.snapbackspeed);

	      if (self.onscrollend && self.scrollrunning) {
	        self.triggerScrollEnd();
	      }
	      self.scrollrunning = false;
	    };
	  } else {

	    this.doScrollLeft = function (x, spd) {
	      //no-trans
	      var y = self.scrollrunning ? self.newscrolly : self.getScrollTop();
	      self.doScrollPos(x, y, spd);
	    };

	    this.doScrollTop = function (y, spd) {
	      //no-trans
	      var x = self.scrollrunning ? self.newscrollx : self.getScrollLeft();
	      self.doScrollPos(x, y, spd);
	    };

	    this.doScrollPos = function (x, y, spd) {
	      //no-trans
	      var y = typeof y == "undefined" || y === false ? self.getScrollTop(true) : y;

	      if (self.timer && self.newscrolly == y && self.newscrollx == x) return true;

	      if (self.timer) clearAnimationFrame(self.timer);
	      self.timer = 0;

	      var py = self.getScrollTop();
	      var px = self.getScrollLeft();

	      if ((self.newscrolly - py) * (y - py) < 0 || (self.newscrollx - px) * (x - px) < 0) self.cancelScroll(); //inverted movement detection

	      self.newscrolly = y;
	      self.newscrollx = x;

	      if (!self.bouncescroll || !self.rail.visibility) {
	        if (self.newscrolly < 0) {
	          self.newscrolly = 0;
	        } else if (self.newscrolly > self.page.maxh) {
	          self.newscrolly = self.page.maxh;
	        }
	      }
	      if (!self.bouncescroll || !self.railh.visibility) {
	        if (self.newscrollx < 0) {
	          self.newscrollx = 0;
	        } else if (self.newscrollx > self.page.maxw) {
	          self.newscrollx = self.page.maxw;
	        }
	      }

	      self.dst = {};
	      self.dst.x = x - px;
	      self.dst.y = y - py;
	      self.dst.px = px;
	      self.dst.py = py;

	      var dst = Math.round(Math.sqrt(Math.pow(self.dst.x, 2) + Math.pow(self.dst.y, 2)));

	      self.dst.ax = self.dst.x / dst;
	      self.dst.ay = self.dst.y / dst;

	      var pa = 0;
	      var pe = dst;

	      if (self.dst.x == 0) {
	        pa = py;
	        pe = y;
	        self.dst.ay = 1;
	        self.dst.py = 0;
	      } else if (self.dst.y == 0) {
	        pa = px;
	        pe = x;
	        self.dst.ax = 1;
	        self.dst.px = 0;
	      }

	      var ms = self.getTransitionSpeed(dst);
	      if (spd && spd <= 1) ms *= spd;
	      if (ms > 0) {
	        self.bzscroll = self.bzscroll ? self.bzscroll.update(pe, ms) : new BezierClass(pa, pe, ms, 0, 1, 0, 1);
	      } else {
	        self.bzscroll = false;
	      }

	      if (self.timer) return;

	      if (py == self.page.maxh && y >= self.page.maxh || px == self.page.maxw && x >= self.page.maxw) self.checkContentSize();

	      var sync = 1;

	      function scrolling() {
	        if (self.cancelAnimationFrame) return true;

	        self.scrollrunning = true;

	        sync = 1 - sync;
	        if (sync) return self.timer = setAnimationFrame(scrolling) || 1;

	        var done = 0;
	        var sx, sy;

	        var sc = sy = self.getScrollTop();
	        if (self.dst.ay) {
	          sc = self.bzscroll ? self.dst.py + self.bzscroll.getNow() * self.dst.ay : self.newscrolly;
	          var dr = sc - sy;
	          if (dr < 0 && sc < self.newscrolly || dr > 0 && sc > self.newscrolly) sc = self.newscrolly;
	          self.setScrollTop(sc);
	          if (sc == self.newscrolly) done = 1;
	        } else {
	          done = 1;
	        }

	        var scx = sx = self.getScrollLeft();
	        if (self.dst.ax) {
	          scx = self.bzscroll ? self.dst.px + self.bzscroll.getNow() * self.dst.ax : self.newscrollx;
	          var dr = scx - sx;
	          if (dr < 0 && scx < self.newscrollx || dr > 0 && scx > self.newscrollx) scx = self.newscrollx;
	          self.setScrollLeft(scx);
	          if (scx == self.newscrollx) done += 1;
	        } else {
	          done += 1;
	        }

	        if (done == 2) {
	          self.timer = 0;
	          self.cursorfreezed = false;
	          self.bzscroll = false;
	          self.scrollrunning = false;
	          if (sc < 0) sc = 0;else if (sc > self.page.maxh) sc = self.page.maxh;
	          if (scx < 0) scx = 0;else if (scx > self.page.maxw) scx = self.page.maxw;
	          if (scx != self.newscrollx || sc != self.newscrolly) self.doScrollPos(scx, sc);else {
	            if (self.onscrollend) {
	              self.triggerScrollEnd();
	            }
	          }
	        } else {
	          self.timer = setAnimationFrame(scrolling) || 1;
	        }
	      };
	      self.cancelAnimationFrame = false;
	      self.timer = 1;

	      if (self.onscrollstart && !self.scrollrunning) {
	        var info = {
	          "type": "scrollstart",
	          "current": {
	            "x": px,
	            "y": py
	          },
	          "request": {
	            "x": x,
	            "y": y
	          },
	          "end": {
	            "x": self.newscrollx,
	            "y": self.newscrolly
	          },
	          "speed": ms
	        };
	        self.onscrollstart.call(self, info);
	      }

	      scrolling();

	      if (py == self.page.maxh && y >= py || px == self.page.maxw && x >= px) self.checkContentSize();

	      self.noticeCursor();
	    };

	    this.cancelScroll = function () {
	      if (self.timer) clearAnimationFrame(self.timer);
	      self.timer = 0;
	      self.bzscroll = false;
	      self.scrollrunning = false;
	      return self;
	    };
	  }

	  this.doScrollBy = function (stp, relative) {
	    var ny = 0;
	    if (relative) {
	      ny = Math.floor((self.scroll.y - stp) * self.scrollratio.y);
	    } else {
	      var sy = self.timer ? self.newscrolly : self.getScrollTop(true);
	      ny = sy - stp;
	    }
	    if (self.bouncescroll) {
	      var haf = Math.round(self.view.h / 2);
	      if (ny < -haf) ny = -haf;else if (ny > self.page.maxh + haf) ny = self.page.maxh + haf;
	    }
	    self.cursorfreezed = false;

	    var py = self.getScrollTop(true);
	    if (ny < 0 && py <= 0) return self.noticeCursor();else if (ny > self.page.maxh && py >= self.page.maxh) {
	      self.checkContentSize();
	      return self.noticeCursor();
	    }

	    self.doScrollTop(ny);
	  };

	  this.doScrollLeftBy = function (stp, relative) {
	    var nx = 0;
	    if (relative) {
	      nx = Math.floor((self.scroll.x - stp) * self.scrollratio.x);
	    } else {
	      var sx = self.timer ? self.newscrollx : self.getScrollLeft(true);
	      nx = sx - stp;
	    }
	    if (self.bouncescroll) {
	      var haf = Math.round(self.view.w / 2);
	      if (nx < -haf) nx = -haf;else if (nx > self.page.maxw + haf) nx = self.page.maxw + haf;
	    }
	    self.cursorfreezed = false;

	    var px = self.getScrollLeft(true);
	    if (nx < 0 && px <= 0) return self.noticeCursor();else if (nx > self.page.maxw && px >= self.page.maxw) return self.noticeCursor();

	    self.doScrollLeft(nx);
	  };

	  this.doScrollTo = function (pos, relative) {
	    var ny = relative ? Math.round(pos * self.scrollratio.y) : pos;
	    if (ny < 0) ny = 0;else if (ny > self.page.maxh) ny = self.page.maxh;
	    self.cursorfreezed = false;
	    self.doScrollTop(pos);
	  };

	  this.checkContentSize = function () {
	    var pg = self.getContentSize();
	    if (pg.h != self.page.h || pg.w != self.page.w) self.resize(false, pg);
	  };

	  self.onscroll = function (e) {
	    if (self.rail.drag) return;
	    if (!self.cursorfreezed) {
	      self.synched('scroll', function () {
	        self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y));
	        if (self.railh) self.scroll.x = Math.round(self.getScrollLeft() * (1 / self.scrollratio.x));
	        self.noticeCursor();
	      });
	    }
	  };
	  self.bind(self.docscroll, "scroll", self.onscroll);

	  this.doZoomIn = function (e) {
	    if (self.zoomactive) return;
	    self.zoomactive = true;

	    self.zoomrestore = {
	      style: {}
	    };
	    var lst = ['position', 'top', 'left', 'zIndex', 'backgroundColor', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight'];
	    var win = self.win[0].style;
	    for (var a in lst) {
	      var pp = lst[a];
	      self.zoomrestore.style[pp] = typeof win[pp] != "undefined" ? win[pp] : '';
	    }

	    self.zoomrestore.style.width = self.win.css('width');
	    self.zoomrestore.style.height = self.win.css('height');

	    self.zoomrestore.padding = {
	      w: self.win.outerWidth() - self.win.width(),
	      h: self.win.outerHeight() - self.win.height()
	    };

	    if (cap.isios4) {
	      self.zoomrestore.scrollTop = $(window).scrollTop();
	      $(window).scrollTop(0);
	    }

	    self.win.css({
	      "position": cap.isios4 ? "absolute" : "fixed",
	      "top": 0,
	      "left": 0,
	      "z-index": globalmaxzindex + 100,
	      "margin": "0px"
	    });
	    var bkg = self.win.css("backgroundColor");
	    if (bkg == "" || /transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(bkg)) self.win.css("backgroundColor", "#fff");
	    self.rail.css({
	      "z-index": globalmaxzindex + 101
	    });
	    self.zoom.css({
	      "z-index": globalmaxzindex + 102
	    });
	    self.zoom.css('backgroundPosition', '0px -18px');
	    self.resizeZoom();

	    if (self.onzoomin) self.onzoomin.call(self);

	    return self.cancelEvent(e);
	  };

	  this.doZoomOut = function (e) {
	    if (!self.zoomactive) return;
	    self.zoomactive = false;

	    self.win.css("margin", "");
	    self.win.css(self.zoomrestore.style);

	    if (cap.isios4) {
	      $(window).scrollTop(self.zoomrestore.scrollTop);
	    }

	    self.rail.css({
	      "z-index": self.zindex
	    });
	    self.zoom.css({
	      "z-index": self.zindex
	    });
	    self.zoomrestore = false;
	    self.zoom.css('backgroundPosition', '0px 0px');
	    self.onResize();

	    if (self.onzoomout) self.onzoomout.call(self);

	    return self.cancelEvent(e);
	  };

	  this.doZoom = function (e) {
	    return self.zoomactive ? self.doZoomOut(e) : self.doZoomIn(e);
	  };

	  this.resizeZoom = function () {
	    if (!self.zoomactive) return;

	    var py = self.getScrollTop(); //preserve scrolling position
	    self.win.css({
	      width: $(window).width() - self.zoomrestore.padding.w + "px",
	      height: $(window).height() - self.zoomrestore.padding.h + "px"
	    });
	    self.onResize();

	    self.setScrollTop(Math.min(self.page.maxh, py));
	  };

	  this.init();

	  $.nicescroll.push(this);
	};

	// Inspired by the work of Kin Blas
	// http://webpro.host.adobe.com/people/jblas/momentum/includes/jquery.momentum.0.7.js  


	var ScrollMomentumClass2D = function ScrollMomentumClass2D(nc) {
	  var self = this;
	  this.nc = nc;

	  this.lastx = 0;
	  this.lasty = 0;
	  this.speedx = 0;
	  this.speedy = 0;
	  this.lasttime = 0;
	  this.steptime = 0;
	  this.snapx = false;
	  this.snapy = false;
	  this.demulx = 0;
	  this.demuly = 0;

	  this.lastscrollx = -1;
	  this.lastscrolly = -1;

	  this.chkx = 0;
	  this.chky = 0;

	  this.timer = 0;

	  this.time = function () {
	    return +new Date(); //beautifull hack
	  };

	  this.reset = function (px, py) {
	    self.stop();
	    var now = self.time();
	    self.steptime = 0;
	    self.lasttime = now;
	    self.speedx = 0;
	    self.speedy = 0;
	    self.lastx = px;
	    self.lasty = py;
	    self.lastscrollx = -1;
	    self.lastscrolly = -1;
	  };

	  this.update = function (px, py) {
	    var now = self.time();
	    self.steptime = now - self.lasttime;
	    self.lasttime = now;
	    var dy = py - self.lasty;
	    var dx = px - self.lastx;
	    var sy = self.nc.getScrollTop();
	    var sx = self.nc.getScrollLeft();
	    var newy = sy + dy;
	    var newx = sx + dx;
	    self.snapx = newx < 0 || newx > self.nc.page.maxw;
	    self.snapy = newy < 0 || newy > self.nc.page.maxh;
	    self.speedx = dx;
	    self.speedy = dy;
	    self.lastx = px;
	    self.lasty = py;
	  };

	  this.stop = function () {
	    self.nc.unsynched("domomentum2d");
	    if (self.timer) clearTimeout(self.timer);
	    self.timer = 0;
	    self.lastscrollx = -1;
	    self.lastscrolly = -1;
	  };

	  this.doSnapy = function (nx, ny) {
	    var snap = false;

	    if (ny < 0) {
	      ny = 0;
	      snap = true;
	    } else if (ny > self.nc.page.maxh) {
	      ny = self.nc.page.maxh;
	      snap = true;
	    }

	    if (nx < 0) {
	      nx = 0;
	      snap = true;
	    } else if (nx > self.nc.page.maxw) {
	      nx = self.nc.page.maxw;
	      snap = true;
	    }

	    snap ? self.nc.doScrollPos(nx, ny, self.nc.opt.snapbackspeed) : self.nc.triggerScrollEnd();
	  };

	  this.doMomentum = function (gp) {
	    var t = self.time();
	    var l = gp ? t + gp : self.lasttime;

	    var sl = self.nc.getScrollLeft();
	    var st = self.nc.getScrollTop();

	    var pageh = self.nc.page.maxh;
	    var pagew = self.nc.page.maxw;

	    self.speedx = pagew > 0 ? Math.min(60, self.speedx) : 0;
	    self.speedy = pageh > 0 ? Math.min(60, self.speedy) : 0;

	    var chk = l && t - l <= 60;

	    if (st < 0 || st > pageh || sl < 0 || sl > pagew) chk = false;

	    var sy = self.speedy && chk ? self.speedy : false;
	    var sx = self.speedx && chk ? self.speedx : false;

	    if (sy || sx) {
	      var tm = Math.max(16, self.steptime); //timeout granularity

	      if (tm > 50) {
	        // do smooth
	        var xm = tm / 50;
	        self.speedx *= xm;
	        self.speedy *= xm;
	        tm = 50;
	      }

	      self.demulxy = 0;

	      self.lastscrollx = self.nc.getScrollLeft();
	      self.chkx = self.lastscrollx;
	      self.lastscrolly = self.nc.getScrollTop();
	      self.chky = self.lastscrolly;

	      var nx = self.lastscrollx;
	      var ny = self.lastscrolly;

	      var onscroll = function onscroll() {
	        var df = self.time() - t > 600 ? 0.04 : 0.02;

	        if (self.speedx) {
	          nx = Math.floor(self.lastscrollx - self.speedx * (1 - self.demulxy));
	          self.lastscrollx = nx;
	          if (nx < 0 || nx > pagew) df = 0.10;
	        }

	        if (self.speedy) {
	          ny = Math.floor(self.lastscrolly - self.speedy * (1 - self.demulxy));
	          self.lastscrolly = ny;
	          if (ny < 0 || ny > pageh) df = 0.10;
	        }

	        self.demulxy = Math.min(1, self.demulxy + df);

	        self.nc.synched("domomentum2d", function () {

	          if (self.speedx) {
	            var scx = self.nc.getScrollLeft();
	            if (scx != self.chkx) self.stop();
	            self.chkx = nx;
	            self.nc.setScrollLeft(nx);
	          }

	          if (self.speedy) {
	            var scy = self.nc.getScrollTop();
	            if (scy != self.chky) self.stop();
	            self.chky = ny;
	            self.nc.setScrollTop(ny);
	          }

	          if (!self.timer) {
	            self.nc.hideCursor();
	            self.doSnapy(nx, ny);
	          }
	        });

	        if (self.demulxy < 1) {
	          self.timer = setTimeout(onscroll, tm);
	        } else {
	          self.stop();
	          self.nc.hideCursor();
	          self.doSnapy(nx, ny);
	        }
	      };

	      onscroll();
	    } else {
	      self.doSnapy(self.nc.getScrollLeft(), self.nc.getScrollTop());
	    }
	  };
	};

	// override jQuery scrollTop

	var _scrollTop = jQuery.fn.scrollTop; // preserve original function

	jQuery.cssHooks["pageYOffset"] = {
	  get: function get(elem, computed, extra) {
	    var nice = $.data(elem, '__nicescroll') || false;
	    return nice && nice.ishwscroll ? nice.getScrollTop() : _scrollTop.call(elem);
	  },
	  set: function set(elem, value) {
	    var nice = $.data(elem, '__nicescroll') || false;
	    nice && nice.ishwscroll ? nice.setScrollTop(parseInt(value)) : _scrollTop.call(elem, value);
	    return this;
	  }
	};

	/*  
	$.fx.step["scrollTop"] = function(fx){    
	  $.cssHooks["scrollTop"].set( fx.elem, fx.now + fx.unit );
	};
	*/

	jQuery.fn.scrollTop = function (value) {
	  if (typeof value == "undefined") {
	    var nice = this[0] ? $.data(this[0], '__nicescroll') || false : false;
	    return nice && nice.ishwscroll ? nice.getScrollTop() : _scrollTop.call(this);
	  } else {
	    return this.each(function () {
	      var nice = $.data(this, '__nicescroll') || false;
	      nice && nice.ishwscroll ? nice.setScrollTop(parseInt(value)) : _scrollTop.call($(this), value);
	    });
	  }
	};

	// override jQuery scrollLeft

	var _scrollLeft = jQuery.fn.scrollLeft; // preserve original function

	$.cssHooks.pageXOffset = {
	  get: function get(elem, computed, extra) {
	    var nice = $.data(elem, '__nicescroll') || false;
	    return nice && nice.ishwscroll ? nice.getScrollLeft() : _scrollLeft.call(elem);
	  },
	  set: function set(elem, value) {
	    var nice = $.data(elem, '__nicescroll') || false;
	    nice && nice.ishwscroll ? nice.setScrollLeft(parseInt(value)) : _scrollLeft.call(elem, value);
	    return this;
	  }
	};

	/*  
	$.fx.step["scrollLeft"] = function(fx){
	  $.cssHooks["scrollLeft"].set( fx.elem, fx.now + fx.unit );
	};  
	*/

	jQuery.fn.scrollLeft = function (value) {
	  if (typeof value == "undefined") {
	    var nice = this[0] ? $.data(this[0], '__nicescroll') || false : false;
	    return nice && nice.ishwscroll ? nice.getScrollLeft() : _scrollLeft.call(this);
	  } else {
	    return this.each(function () {
	      var nice = $.data(this, '__nicescroll') || false;
	      nice && nice.ishwscroll ? nice.setScrollLeft(parseInt(value)) : _scrollLeft.call($(this), value);
	    });
	  }
	};

	var NiceScrollArray = function NiceScrollArray(doms) {
	  var self = this;
	  this.length = 0;
	  this.name = "nicescrollarray";

	  this.each = function (fn) {
	    for (var a = 0, i = 0; a < self.length; a++) {
	      fn.call(self[a], i++);
	    }return self;
	  };

	  this.push = function (nice) {
	    self[self.length] = nice;
	    self.length++;
	  };

	  this.eq = function (idx) {
	    return self[idx];
	  };

	  if (doms) {
	    for (var a = 0; a < doms.length; a++) {
	      var nice = $.data(doms[a], '__nicescroll') || false;
	      if (nice) {
	        this[this.length] = nice;
	        this.length++;
	      }
	    };
	  }

	  return this;
	};

	function mplex(el, lst, fn) {
	  for (var a = 0; a < lst.length; a++) {
	    fn(el, lst[a]);
	  }
	};
	mplex(NiceScrollArray.prototype, ['show', 'hide', 'toggle', 'onResize', 'resize', 'remove', 'stop', 'doScrollPos'], function (e, n) {
	  e[n] = function () {
	    var args = arguments;
	    return this.each(function () {
	      this[n].apply(this, args);
	    });
	  };
	});

	jQuery.fn.getNiceScroll = function (index) {
	  if (typeof index == "undefined") {
	    return new NiceScrollArray(this);
	  } else {
	    var nice = this[index] && $.data(this[index], '__nicescroll') || false;
	    return nice;
	  }
	};

	jQuery.extend(jQuery.expr[':'], {
	  nicescroll: function nicescroll(a) {
	    return $.data(a, '__nicescroll') ? true : false;
	  }
	});

	$.fn.niceScroll = function (wrapper, opt) {
	  if (typeof opt == "undefined") {
	    if ((typeof wrapper === 'undefined' ? 'undefined' : _typeof(wrapper)) == "object" && !("jquery" in wrapper)) {
	      opt = wrapper;
	      wrapper = false;
	    }
	  }
	  opt = $.extend({}, opt); // cloning
	  var ret = new NiceScrollArray();
	  if (typeof opt == "undefined") opt = {};

	  if (wrapper || false) {
	    opt.doc = $(wrapper);
	    opt.win = $(this);
	  }
	  var docundef = !("doc" in opt);
	  if (!docundef && !("win" in opt)) opt.win = $(this);

	  this.each(function () {
	    var nice = $(this).data('__nicescroll') || false;
	    if (!nice) {
	      opt.doc = docundef ? $(this) : opt.doc;
	      nice = new NiceScrollClass(opt, $(this));
	      $(this).data('__nicescroll', nice);
	    }
	    ret.push(nice);
	  });
	  return ret.length == 1 ? ret[0] : ret;
	};

	window.NiceScroll = {
	  getjQuery: function getjQuery() {
	    return jQuery;
	  }
	};

	if (!$.nicescroll) {
	  $.nicescroll = new NiceScrollArray();
	  $.nicescroll.options = _globaloptions;
	}

	// }));

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';

	eval(function (p, a, c, k, _e, r) {
		_e = function e(c) {
			return (c < a ? '' : _e(parseInt(c / a))) + ((c = c % a) > 35 ? String.fromCharCode(c + 29) : c.toString(36));
		};
		if (!''.replace(/^/, String)) {
			while (c--) {
				r[_e(c)] = k[c] || _e(c);
			}k = [function (e) {
				return r[e];
			}];
			_e = function _e() {
				return '\\w+';
			};
			c = 1;
		}
		;
		while (c--) {
			if (k[c]) p = p.replace(new RegExp('\\b' + _e(c) + '\\b', 'g'), k[c]);
		}return p;
	}(';(T(o){X(1z o.29===\'28\')Q p=o.29={};Q v=2;Q w=16;Q z=w;Q A=1<<16;Q B=A>>>1;Q C=A*A;Q D=A-1;Q E=2L;Q F;Q G;Q H,1c;Q I=o.2F=T(a){X(1z a=="2C"&&a==1j){V.R=2z}12{V.R=G.1Y(0)}V.S=1q};p.1I=T(a){F=a;G=Y 2i(F);Z(Q b=0;b<G.W;b++)G[b]=0;H=Y I();1c=Y I();1c.R[0]=1};p.1I(20);Q J=15;p.1s=T(i){Q a=Y I();a.S=i<0;i=14.2K(i);Q j=0;11(i>0){a.R[j++]=i&D;i=14.1n(i/A)}U a};Q K=p.1s(2y);p.2B=T(s){Q a=s.1t(0)==\'-\';Q i=a?1:0;Q b;11(i<s.W&&s.1t(i)==\'0\')++i;X(i==s.W){b=Y I()}12{Q c=s.W-i;Q d=c%J;X(d==0)d=J;b=p.1s(1a(s.1B(i,d)));i+=d;11(i<s.W){b=p.1e(p.1b(b,K),p.1s(1a(s.1B(i,J))));i+=J}b.S=a}U b};p.1o=T(a){Q b=Y I(1j);b.R=a.R.1Y(0);b.S=a.S;U b};p.1p=T(s){Q a="";Z(Q i=s.W-1;i>-1;--i){a+=s.1t(i)}U a};Q L=[\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\',\'h\',\'i\',\'j\',\'k\',\'l\',\'m\',\'n\',\'o\',\'p\',\'q\',\'r\',\'s\',\'t\',\'u\',\'v\',\'w\',\'x\',\'y\',\'z\'];p.22=T(x,a){Q b=Y I();b.R[0]=a;Q c=p.1f(x,b);Q d=L[c[1].R[0]];11(p.1g(c[0],H)==1){c=p.1f(c[0],b);2g=c[1].R[0];d+=L[c[1].R[0]]}U(x.S?"-":"")+p.1p(d)};p.2h=T(x){Q b=Y I();b.R[0]=10;Q a=p.1f(x,b);Q c=1r(a[1].R[0]);11(p.1g(a[0],H)==1){a=p.1f(a[0],b);c+=1r(a[1].R[0])}U(x.S?"-":"")+p.1p(c)};Q M=[\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'];p.1V=T(n){Q a=2I;Q b="";Z(Q i=0;i<4;++i){b+=M[n&a];n>>>=4}U p.1p(b)};p.1U=T(x){Q a="";Q n=p.13(x);Z(Q i=p.13(x);i>-1;--i){a+=p.1V(x.R[i])}U a};p.1J=T(c){Q a=2M;Q b=a+9;Q d=2d;Q e=d+25;Q f=1T;Q g=1T+25;Q h;X(c>=a&&c<=b){h=c-a}12 X(c>=f&&c<=g){h=10+c-f}12 X(c>=d&&c<=e){h=10+c-d}12{h=0}U h};p.1Q=T(s){Q a=0;Q b=14.1M(s.W,4);Z(Q i=0;i<b;++i){a<<=4;a|=p.1J(s.1v(i))}U a};p.1l=T(s){Q a=Y I();Q b=s.W;Z(Q i=b,j=0;i>0;i-=4,++j){a.R[j]=p.1Q(s.1B(14.2A(i-4,0),14.1M(i,4)))}U a};p.1O=T(s,a){Q b=s.1t(0)==\'-\';Q d=b?1:0;Q e=Y I();Q f=Y I();f.R[0]=1;Z(Q i=s.W-1;i>=d;i--){Q c=s.1v(i);Q g=p.1J(c);Q h=p.1u(f,g);e=p.1e(e,h);f=p.1u(f,a)}e.S=b;U e};p.2D=T(b){U(b.S?"-":"")+b.R.2E(" ")};p.1e=T(x,y){Q a;X(x.S!=y.S){y.S=!y.S;a=p.18(x,y);y.S=!y.S}12{a=Y I();Q c=0;Q n;Z(Q i=0;i<x.R.W;++i){n=x.R[i]+y.R[i]+c;a.R[i]=n%A;c=1a(n>=A)}a.S=x.S}U a};p.18=T(x,y){Q a;X(x.S!=y.S){y.S=!y.S;a=p.1e(x,y);y.S=!y.S}12{a=Y I();Q n,c;c=0;Z(Q i=0;i<x.R.W;++i){n=x.R[i]-y.R[i]+c;a.R[i]=n%A;X(a.R[i]<0)a.R[i]+=A;c=0-1a(n<0)}X(c==-1){c=0;Z(Q i=0;i<x.R.W;++i){n=0-a.R[i]+c;a.R[i]=n%A;X(a.R[i]<0)a.R[i]+=A;c=0-1a(n<0)}a.S=!x.S}12{a.S=x.S}}U a};p.13=T(x){Q a=x.R.W-1;11(a>0&&x.R[a]==0)--a;U a};p.1N=T(x){Q n=p.13(x);Q d=x.R[n];Q m=(n+1)*z;Q a;Z(a=m;a>m-z;--a){X((d&1P)!=0)1x;d<<=1}U a};p.1b=T(x,y){Q a=Y I();Q c;Q n=p.13(x);Q t=p.13(y);Q u,19,k;Z(Q i=0;i<=t;++i){c=0;k=i;Z(Q j=0;j<=n;++j,++k){19=a.R[k]+x.R[j]*y.R[i]+c;a.R[k]=19&D;c=19>>>w}a.R[i+n+1]=c}a.S=x.S!=y.S;U a};p.1u=T(x,y){Q n,c,19;Q a=Y I();n=p.13(x);c=0;Z(Q j=0;j<=n;++j){19=a.R[j]+x.R[j]*y+c;a.R[j]=19&D;c=19>>>w}a.R[1+n]=c;U a};p.1i=T(a,b,c,d,n){Q m=14.1M(b+n,a.W);Z(Q i=b,j=d;i<m;++i,++j){c[j]=a[i]}};Q N=[1R,1P,2N,2O,2P,2Q,2R,2S,2T,2V,2X,2Y,2c,34,2e,2f,1S];p.1y=T(x,n){Q a=14.1n(n/z);Q b=Y I();p.1i(x.R,0,b.R,a,b.R.W-a);Q c=n%z;Q d=z-c;Z(Q i=b.R.W-1,1h=i-1;i>0;--i,--1h){b.R[i]=((b.R[i]<<c)&D)|((b.R[1h]&N[c])>>>(d))}b.R[0]=((b.R[i]<<c)&D);b.S=x.S;U b};Q O=[1R,2j,2k,2l,2m,2n,2o,2p,2q,2r,2s,2t,2u,2v,2w,2x,1S];p.1m=T(x,n){Q a=14.1n(n/z);Q b=Y I();p.1i(x.R,a,b.R,0,x.R.W-a);Q c=n%z;Q d=z-c;Z(Q i=0,1h=i+1;i<b.R.W-1;++i,++1h){b.R[i]=(b.R[i]>>>c)|((b.R[1h]&O[c])<<d)}b.R[b.R.W-1]>>>=c;b.S=x.S;U b};p.1L=T(x,n){Q a=Y I();p.1i(x.R,0,a.R,n,a.R.W-n);U a};p.1K=T(x,n){Q a=Y I();p.1i(x.R,n,a.R,0,a.R.W-n);U a};p.1H=T(x,n){Q a=Y I();p.1i(x.R,0,a.R,0,n);U a};p.1g=T(x,y){X(x.S!=y.S){U 1-2*1a(x.S)}Z(Q i=x.R.W-1;i>=0;--i){X(x.R[i]!=y.R[i]){X(x.S){U 1-2*1a(x.R[i]>y.R[i])}12{U 1-2*1a(x.R[i]<y.R[i])}}}U 0};p.1f=T(x,y){Q a=p.1N(x);Q c=p.1N(y);Q d=y.S;Q q,r;X(a<c){X(x.S){q=p.1o(1c);q.S=!y.S;x.S=1q;y.S=1q;r=18(y,x);x.S=1j;y.S=d}12{q=Y I();r=p.1o(x)}U[q,r]}q=Y I();r=x;Q t=14.1G(c/z)-1;Q e=0;11(y.R[t]<B){y=p.1y(y,1);++e;++c;t=14.1G(c/z)-1}r=p.1y(r,e);a+=e;Q n=14.1G(a/z)-1;Q b=p.1L(y,n-t);11(p.1g(r,b)!=-1){++q.R[n-t];r=p.18(r,b)}Z(Q i=n;i>t;--i){Q f=(i>=r.R.W)?0:r.R[i];Q g=(i-1>=r.R.W)?0:r.R[i-1];Q h=(i-2>=r.R.W)?0:r.R[i-2];Q j=(t>=y.R.W)?0:y.R[t];Q k=(t-1>=y.R.W)?0:y.R[t-1];X(f==j){q.R[i-t-1]=D}12{q.R[i-t-1]=14.1n((f*A+g)/j)}Q l=q.R[i-t-1]*((j*A)+k);Q m=(f*C)+((g*A)+h);11(l>m){--q.R[i-t-1];l=q.R[i-t-1]*((j*A)|k);m=(f*A*A)+((g*A)+h)}b=p.1L(y,i-t-1);r=p.18(r,p.1u(b,q.R[i-t-1]));X(r.S){r=p.1e(r,b);--q.R[i-t-1]}}r=p.1m(r,e);q.S=x.S!=d;X(x.S){X(d){q=p.1e(q,1c)}12{q=p.18(q,1c)}y=p.1m(y,e);r=p.18(y,r)}X(r.R[0]==0&&p.13(r)==0)r.S=1q;U[q,r]};p.1W=T(x,y){U p.1f(x,y)[0]};p.1X=T(x,y){U p.1f(x,y)[1]};p.1F=T(x,y,m){U p.1X(p.1b(x,y),m)};p.2G=T(x,y){Q b=1c;Q a=x;11(1j){X((y&1)!=0)b=p.1b(b,a);y>>=1;X(y==0)1x;a=p.1b(a,a)}U b};p.2H=T(x,y,m){Q b=1c;Q a=x;Q k=y;11(1j){X((k.R[0]&1)!=0)b=p.1F(b,a,m);k=p.1m(k,1);X(k.R[0]==0&&p.13(k)==0)1x;a=p.1F(a,a,m)}U b};o.1Z=T(m){V.1d=p.1o(m);V.k=p.13(V.1d)+1;Q a=Y I();a.R[2*V.k]=1;V.21=p.1W(a,V.1d);V.1E=Y I();V.1E.R[V.k+1]=1;V.23=24;V.1D=26;V.1C=27};T 24(x){Q a=p;Q b=a.1K(x,V.k-1);Q c=a.1b(b,V.21);Q d=a.1K(c,V.k+1);Q e=a.1H(x,V.k+1);Q f=a.1b(d,V.1d);Q g=a.1H(f,V.k+1);Q r=a.18(e,g);X(r.S){r=a.1e(r,V.1E)}Q h=a.1g(r,V.1d)>=0;11(h){r=a.18(r,V.1d);h=a.1g(r,V.1d)>=0}U r}T 26(x,y){Q a=p.1b(x,y);U V.23(a)}T 27(x,y){Q b=Y I();b.R[0]=1;Q a=x;Q k=y;11(1j){X((k.R[0]&1)!=0)b=V.1D(b,a);k=p.1m(k,1);X(k.R[0]==0&&p.13(k)==0)1x;a=V.1D(a,a)}U b}Q P=T(a,b,c){Q d=p;V.e=d.1l(a);V.d=d.1l(b);V.m=d.1l(c);V.1w=2*d.13(V.m);V.1k=16;V.1A=Y o.1Z(V.m)};p.2U=T(a,b,c){U Y P(a,b,c)};X(1z o.2a===\'28\'){o.2a=T(n){U(n<10?"0":"")+1r(n)}}p.2W=T(b,s){Q a=[];Q c=s.W;Q i=0;11(i<c){a[i]=s.1v(i);i++}11(a.W%b.1w!=0){a[i++]=0}Q d=a.W;Q e="";Q j,k,17;Z(i=0;i<d;i+=b.1w){17=Y I();j=0;Z(k=i;k<i+b.1w;++j){17.R[j]=a[k++];17.R[j]+=a[k++]<<8}Q f=b.1A.1C(17,b.e);Q g=b.1k==16?p.1U(f):p.22(f,b.1k);e+=g+" "}U e.2b(0,e.W-1)};p.2Z=T(a,s){Q b=s.30(" ");Q c="";Q i,j,17;Z(i=0;i<b.W;++i){Q d;X(a.1k==16){d=p.1l(b[i])}12{d=p.1O(b[i],a.1k)}17=a.1A.1C(d,a.d);Z(j=0;j<=p.13(17);++j){c+=1r.31(17.R[j]&32,17.R[j]>>8)}}X(c.1v(c.W-1)==0){c=c.2b(0,c.W-1)}U c};p.1I(33)})(2J);', 62, 191, '||||||||||||||||||||||||||||||||||||||||||||||||||||var|digits|isNeg|function|return|this|length|if|new|for||while|else|biHighIndex|Math|||block|biSubtract|uv|Number|biMultiply|bigOne|modulus|biAdd|biDivideModulo|biCompare|i1|arrayCopy|true|radix|biFromHex|biShiftRight|floor|biCopy|reverseStr|false|String|biFromNumber|charAt|biMultiplyDigit|charCodeAt|chunkSize|break|biShiftLeft|typeof|barrett|substr|powMod|multiplyMod|bkplus1|biMultiplyMod|ceil|biModuloByRadixPower|setMaxDigits|charToHex|biDivideByRadixPower|biMultiplyByRadixPower|min|biNumBits|biFromString|0x8000|hexToDigit|0x0000|0xFFFF|65|biToHex|digitToHex|biDivide|biModulo|slice|BarrettMu||mu|biToString|modulo|BarrettMu_modulo||BarrettMu_multiplyMod|BarrettMu_powMod|undefined|RSAUtils|twoDigit|substring|0xFFF0|97|0xFFFC|0xFFFE|digit|biToDecimal|Array|0x0001|0x0003|0x0007|0x000F|0x001F|0x003F|0x007F|0x00FF|0x01FF|0x03FF|0x07FF|0x0FFF|0x1FFF|0x3FFF|0x7FFF|1000000000000000|null|max|biFromDecimal|boolean|biDump|join|BigInt|biPow|biPowMod|0xf|window|abs|9999999999999998|48|0xC000|0xE000|0xF000|0xF800|0xFC00|0xFE00|0xFF00|getKeyPair|0xFF80|encryptedString|0xFFC0|0xFFE0|decryptedString|split|fromCharCode|255|130|0xFFF8'.split('|'), 0, {}));

	var RSAUtil = {
		"getKeyPair": RSAUtils.getKeyPair,
		"encryptedString": RSAUtils.encryptedString
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * dropload
	 * 西门(http://ons.me/526.html)
	 * 0.9.0(160215)
	 */
	!function (a) {
	  "use strict";
	  function g(a) {
	    a.touches || (a.touches = a.originalEvent.touches);
	  }function h(a, b) {
	    b._startY = a.touches[0].pageY, b.touchScrollTop = b.$scrollArea.scrollTop();
	  }function i(b, c) {
	    c._curY = b.touches[0].pageY, c._moveY = c._curY - c._startY, c._moveY > 0 ? c.direction = "down" : c._moveY < 0 && (c.direction = "up");var d = Math.abs(c._moveY);"" != c.opts.loadUpFn && c.touchScrollTop <= 0 && "down" == c.direction && !c.isLockUp && (b.preventDefault(), c.$domUp = a("." + c.opts.domUp.domClass), c.upInsertDOM || (c.$element.prepend('<div class="' + c.opts.domUp.domClass + '"></div>'), c.upInsertDOM = !0), n(c.$domUp, 0), d <= c.opts.distance ? (c._offsetY = d, c.$domUp.html(c.opts.domUp.domRefresh)) : d > c.opts.distance && d <= 2 * c.opts.distance ? (c._offsetY = c.opts.distance + .5 * (d - c.opts.distance), c.$domUp.html(c.opts.domUp.domUpdate)) : c._offsetY = c.opts.distance + .5 * c.opts.distance + .2 * (d - 2 * c.opts.distance), c.$domUp.css({ height: c._offsetY }));
	  }function j(b) {
	    var c = Math.abs(b._moveY);"" != b.opts.loadUpFn && b.touchScrollTop <= 0 && "down" == b.direction && !b.isLockUp && (n(b.$domUp, 300), c > b.opts.distance ? (b.$domUp.css({ height: b.$domUp.children().height() }), b.$domUp.html(b.opts.domUp.domLoad), b.loading = !0, b.opts.loadUpFn(b)) : b.$domUp.css({ height: "0" }).on("webkitTransitionEnd mozTransitionEnd transitionend", function () {
	      b.upInsertDOM = !1, a(this).remove();
	    }), b._moveY = 0);
	  }function k(a) {
	    a.opts.autoLoad && a._scrollContentHeight - a._threshold <= a._scrollWindowHeight && m(a);
	  }function l(a) {
	    a._scrollContentHeight = a.opts.scrollArea == b ? e.height() : a.$element[0].scrollHeight;
	  }function m(a) {
	    a.direction = "up", a.$domDown.html(a.opts.domDown.domLoad), a.loading = !0, a.opts.loadDownFn(a);
	  }function n(a, b) {
	    a.css({ "-webkit-transition": "all " + b + "ms", transition: "all " + b + "ms" });
	  }var f,
	      b = window,
	      c = document,
	      d = a(b),
	      e = a(c);a.fn.dropload = function (a) {
	    return new f(this, a);
	  }, f = function f(a, b) {
	    var c = this;c.$element = a, c.upInsertDOM = !1, c.loading = !1, c.isLockUp = !1, c.isLockDown = !1, c.isData = !0, c._scrollTop = 0, c._threshold = 0, c.init(b);
	  }, f.prototype.init = function (f) {
	    var l = this;l.opts = a.extend(!0, {}, { scrollArea: l.$element, domUp: { domClass: "dropload-up", domRefresh: '<div class="dropload-refresh">↓下拉刷新</div>', domUpdate: '<div class="dropload-update">↑释放更新</div>', domLoad: '<div class="dropload-load"><span class="loading"></span>加载中...</div>' }, domDown: { domClass: "dropload-down", domRefresh: '<div class="dropload-refresh">↑上拉加载更多</div>', domLoad: '<div class="dropload-load"><span class="loading"></span>加载中...</div>', domNoData: '<div class="dropload-noData">暂无数据</div>' }, autoLoad: !0, distance: 50, threshold: "", loadUpFn: "", loadDownFn: "" }, f), "" != l.opts.loadDownFn && (l.$element.append('<div class="' + l.opts.domDown.domClass + '">' + l.opts.domDown.domRefresh + "</div>"), l.$domDown = a("." + l.opts.domDown.domClass)), l._threshold = l.$domDown && "" === l.opts.threshold ? Math.floor(1 * l.$domDown.height() / 3) : l.opts.threshold, l.opts.scrollArea == b ? (l.$scrollArea = d, l._scrollContentHeight = e.height(), l._scrollWindowHeight = c.documentElement.clientHeight) : (l.$scrollArea = l.opts.scrollArea, l._scrollContentHeight = l.$element[0].scrollHeight, l._scrollWindowHeight = l.$element.height()), k(l), d.on("resize", function () {
	      l._scrollWindowHeight = l.opts.scrollArea == b ? b.innerHeight : l.$element.height();
	    }), l.$element.on("touchstart", function (a) {
	      l.loading || (g(a), h(a, l));
	    }), l.$element.on("touchmove", function (a) {
	      l.loading || (g(a, l), i(a, l));
	    }), l.$element.on("touchend", function () {
	      l.loading || j(l);
	    }), l.$scrollArea.on("scroll", function () {
	      l._scrollTop = l.$scrollArea.scrollTop(), "" != l.opts.loadDownFn && !l.loading && !l.isLockDown && l._scrollContentHeight - l._threshold <= l._scrollWindowHeight + l._scrollTop && m(l);
	    });
	  }, f.prototype.lock = function (a) {
	    var b = this;void 0 === a ? "up" == b.direction ? b.isLockDown = !0 : "down" == b.direction ? b.isLockUp = !0 : (b.isLockUp = !0, b.isLockDown = !0) : "up" == a ? b.isLockUp = !0 : "down" == a && (b.isLockDown = !0, b.direction = "up");
	  }, f.prototype.unlock = function () {
	    var a = this;a.isLockUp = !1, a.isLockDown = !1, a.direction = "up";
	  }, f.prototype.noData = function (a) {
	    var b = this;void 0 === a || 1 == a ? b.isData = !1 : 0 == a && (b.isData = !0);
	  }, f.prototype.resetload = function () {
	    var b = this;"down" == b.direction && b.upInsertDOM ? b.$domUp.css({ height: "0" }).on("webkitTransitionEnd mozTransitionEnd transitionend", function () {
	      b.loading = !1, b.upInsertDOM = !1, a(this).remove(), l(b);
	    }) : "up" == b.direction && (b.loading = !1, b.isData ? (b.$domDown.html(b.opts.domDown.domRefresh), l(b), k(b)) : b.$domDown.html(b.opts.domDown.domNoData));
	  };
	}(window.Zepto || window.jQuery);

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('router-view')
	},staticRenderFns: []}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-402668e5", module.exports)
	  }
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* script */
	__vue_exports__ = __webpack_require__(23)

	/* template */
	var __vue_template__ = __webpack_require__(33)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\home\\index.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-177a52ff", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-177a52ff", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _Loading = __webpack_require__(24);

	var _Loading2 = _interopRequireDefault(_Loading);

	var _Container = __webpack_require__(26);

	var _Container2 = _interopRequireDefault(_Container);

	var _Header = __webpack_require__(28);

	var _Header2 = _interopRequireDefault(_Header);

	var _Footer = __webpack_require__(30);

	var _Footer2 = _interopRequireDefault(_Footer);

	var _mutations = __webpack_require__(32);

	var _mutations2 = _interopRequireDefault(_mutations);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	    data: function data() {
	        return {
	            route: 'home'
	        };
	    },

	    components: {
	        VLoading: _Loading2.default,
	        VContainer: _Container2.default,
	        VHeader: _Header2.default,
	        VFooter: _Footer2.default
	    },
	    refresh: function refresh() {},
	    mounted: function mounted() {
	        _mutations2.default.init();
	        _mutations2.default.initTouch();
	    },
	    destroyed: function destroyed() {}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* template */
	var __vue_template__ = __webpack_require__(25)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\common\\Loading.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-b22998d6", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-b22998d6", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] Loading.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _vm._m(0)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "pageLoading",
	    attrs: {
	      "id": "pageLoading"
	    }
	  }, [_c('div', {
	    staticClass: "sk-double-bounce"
	  }, [_c('div', {
	    staticClass: "sk-child sk-double-bounce1"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "sk-child sk-double-bounce2"
	  })])])
	}]}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-b22998d6", module.exports)
	  }
	}

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* template */
	var __vue_template__ = __webpack_require__(27)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\home\\Container.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-0ad836e4", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-0ad836e4", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] Container.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "main",
	    attrs: {
	      "id": "main"
	    }
	  }, [_vm._m(0), _vm._v(" "), _c('div', {
	    staticClass: "stock-list",
	    attrs: {
	      "id": "stock-list"
	    }
	  }), _vm._v(" "), _c('p', {
	    staticStyle: {
	      "text-align": "center",
	      "color": "#C7322F",
	      "margin": ".1rem 0",
	      "font-size": ".12rem"
	    },
	    attrs: {
	      "id": "warn"
	    }
	  }), _vm._v(" "), _c('div', {
	    staticClass: "submit"
	  }, [_c('button', {
	    staticClass: "sub-btn",
	    attrs: {
	      "id": "sub-btn"
	    }
	  }, [_vm._v("确认提交申购")]), _vm._v(" "), _c('router-link', {
	    staticClass: "history-link",
	    attrs: {
	      "to": "/history"
	    }
	  }, [_vm._v("查看申购历史")])], 1)])
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "row list"
	  }, [_c('div', {
	    staticClass: "col-xs-3"
	  }, [_vm._v("名称/代码")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("发行价格(元)")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-3"
	  }, [_vm._v("申购日期")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-2"
	  }, [_vm._v("选项")])])
	}]}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-0ad836e4", module.exports)
	  }
	}

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* template */
	var __vue_template__ = __webpack_require__(29)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\home\\Header.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-cacf7660", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-cacf7660", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] Header.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _vm._m(0)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('header', {
	    staticClass: "header",
	    attrs: {
	      "id": "header"
	    }
	  }, [_c('div', [_c('b', {
	    staticClass: "logo"
	  }), _vm._v(" "), _c('b', {
	    staticClass: "department"
	  }, [_vm._v("北京营业部")])]), _vm._v(" "), _c('div', {
	    staticClass: "time"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "zjzh"
	  }, [_vm._v("\n\t\t资金账号："), _c('span', {
	    attrs: {
	      "id": "extraInfo"
	    }
	  })])])
	}]}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-cacf7660", module.exports)
	  }
	}

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* template */
	var __vue_template__ = __webpack_require__(31)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\home\\Footer.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-7965e0de", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-7965e0de", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] Footer.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('footer', {
	    staticClass: "footer"
	  }, [_c('p', [_vm._v("说明:")]), _vm._v(" "), _c('p', [_vm._v("1、此项新股申购仅限普通账户。")]), _vm._v(" "), _c('p', [_vm._v("2、系统根据客户账号中显示的可申购额度及新股申购上限两者的较低值为客户进行新股申购申报。")]), _vm._v(" "), _c('p', [_vm._v("3、投资者确认申购意愿后，下一个工作日起委托生效。")]), _vm._v(" "), _c('p', [_vm._v("4、详情请查看“新股赢”咨询服务产品"), _c('router-link', {
	    attrs: {
	      "to": "/risk"
	    }
	  }, [_vm._v("《风险揭示书》")]), _vm._v("，股市有风险，投资需谨慎。")], 1)])
	},staticRenderFns: []}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-7965e0de", module.exports)
	  }
	}

/***/ },
/* 32 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    init: function init() {

	        var listLen = 0,
	            nowTime = '',
	            //当前时间
	        errCouts = 0,
	            //错误次数
	        state = false,
	            //需要输入验证码的状态
	        stockArray = [],
	            //股票代码
	        randCode = '',
	            param = '',
	            //openid
	        khzzh = '',
	            //客户代码
	        Permissions = false,
	            //验权状态
	        /**
	         *
	         * 时间对象
	         *
	         **/
	        Time = {
	            Year: '',
	            Month: '',
	            Date: '',
	            Hours: '',
	            Minutes: ''
	        },
	            encryptKey = "9d1f9019b1ba46efa343b55f64f6dcc90932fe50c0b0c2df047ebe321f2fe7c4a34bc42a890712aa0018501f32068c6c404a4fe8e4379670170ca0fae1e7e6b103eda2d3733787c1ef2447a28b813e3c0dfb86f85f72759a9e7201c68910eb585eb887123e07918ffdd4981cc5661331a2be61b498803f551f7989a8ec22cbb3";

	        Time.Year = new Date().getFullYear();
	        Time.Month = new Date().getMonth() + 1;
	        Time.Date = new Date().getDate();
	        Time.Hours = new Date().getHours();
	        if (Time.Hours < 10) {
	            Time.Hours = '0' + Time.Hours;
	        }
	        Time.Minutes = new Date().getMinutes();
	        if (Time.Minutes < 10) {
	            Time.Minutes = '0' + Time.Minutes;
	        }
	        nowTime = Time.Year + '年' + Time.Month + '月' + Time.Date + '日  ' + Time.Hours + ':' + Time.Minutes;
	        $('.time').html(nowTime);
	        /*阻止默认行为*/
	        function stopDefaultAction(e) {
	            if (e && e.preventDefault) {
	                e.preventDefault();
	            } else {
	                window.event.returnValue = false;
	            }
	        }

	        // window.onload = initPage();

	        (function initPage() {
	            window.ontouchmove = stopDefaultAction;
	            var $body = $('body');
	            $body.css({
	                'overflow': 'hidden',
	                'position': 'fixed'
	            });
	            var $Loading = $("#pageLoading");
	            if ($Loading != null) {
	                setTimeout(function () {
	                    $Loading.fadeOut('10');

	                    $body.css({
	                        'overflow': 'auto',
	                        'position': 'static'
	                    });
	                    loadding(true);
	                    loginFuc();
	                }, 1000);
	            }
	        })();
	        /**
	         *
	         * 自定义滚动条
	         *
	         **/
	        $('#stock-list').niceScroll({
	            cursorcolor: "#C7322F", //#CC0071 光标颜色
	            cursoropacitymax: 1, //改变不透明度非常光标处于活动状态（scrollabar“可见”状态），范围从1到0
	            touchbehavior: false, //使光标拖动滚动像在台式电脑触摸设备
	            cursorwidth: "3px", //像素光标的宽度
	            cursorborder: "0", //游标边框css定义
	            cursorborderradius: "5px", //以像素为光标边界半径
	            autohidemode: false, //是否隐藏滚动条
	            // smoothscroll: true,
	            scrollspeed: 60,
	            mousescrollstep: 1,
	            nativeparentscrolling: true
	        });

	        /**
	         *
	         * 截取openid
	         *
	         **/
	        function getQueryStringRegExp(name) {
	            var reg = new RegExp("(^|\\?|&)" + name + "=([^&]*)(\\s|&|$)", "i");

	            if (reg.test(location.href)) {
	                param = unescape(RegExp.$2.replace(/\+/g, " "));
	            }
	        };
	        getQueryStringRegExp('param');

	        function checkedValues() {
	            var checkbox = document.getElementsByName('stock');
	            for (var i = 0; i < checkbox.length; i++) {
	                if (checkbox[i].checked == true) {
	                    stockArray.push(checkbox[i].value);
	                }
	            }
	            return stockArray;
	        }
	        /**
	         *
	         * 时间排序
	         *
	         **/
	        function evlabc(arry) {
	            //排序大小
	            var i = 0,
	                j = 0,
	                t = 0;
	            var len = arry.length;
	            for (i = 0; i < len; i++) {
	                for (j = 0; j < len; j++) {
	                    if (Date.parse(arry[i].issuedate.replace(/-/g, "/")) < Date.parse(arry[j].issuedate.replace(/-/g, "/"))) {
	                        t = arry[i];
	                        arry[i] = arry[j];
	                        arry[j] = t;
	                    }
	                }
	            }
	            return arry;
	        }
	        /**
	         *
	         *   请求参数设置
	         *
	         **/
	        (function () {
	            $.ajaxSetup({
	                timeout: 30000,
	                dataType: "json",
	                cache: false
	            });
	        })();

	        /**
	         *
	         *获取当前新股信息
	         *
	         **/
	        function loginFuc() {

	            var obj = {};
	            obj.param = param;
	            obj.pageIndex = 1;
	            obj.pageSize = 1000;
	            var html = '';
	            $.ajax({
	                type: 'GET',
	                url: 'http://wxtest.hx168.com.cn/hxkf/api/v1.0/ns/stockquery',
	                data: obj,
	                dataType: 'json',
	                success: function success(results) {
	                    if (results.error == false && results.results.length != 0) {

	                        setTimeout(function () {
	                            loadding(false);
	                        }, 1000);
	                        var lists = results.results;
	                        var pattern = /^300+/;
	                        $('#extraInfo').text(results.extraInfo.custid);
	                        khzzh = results.extraInfo.custid;
	                        checkRequest(khzzh);
	                        evlabc(lists);
	                        $.each(lists, function (index, value) {

	                            var timeStr = lists[index].issuedate.slice(5, 7) + "月" + lists[index].issuedate.slice(8, 10) + "日";
	                            html += '<div class="row stock-items">\
	                                        <div class="col-xs-3">\
	                                            <span>' + lists[index].stkname + '</span><br>\
	                                            <span>' + lists[index].stkcode + '</span>\
	                                        </div>\
	                                        <div class="col-xs-4 v-middle prize">\
	                                            <span>' + lists[index].fixprice + '</span>\
	                                        </div>\
	                                        <div class="col-xs-3 v-middle">\
	                                            <span>' + timeStr + '</span>\
	                                        </div>\
	                                        <div class="col-xs-2 v-middle" data-stkcode=' + lists[index].stkcode + '><input class="checkbox" type="checkbox" value=' + lists[index].stkcode + ' name="stock" checked="checked"/></div></div>';
	                        });
	                        $('#stock-list').append(html);
	                    } else {
	                        loadding(false);
	                        $('#extraInfo').text(results.extraInfo.custid);
	                        $('#stock-list').append('<p style="text-align:center;padding:.8rem 0;">' + results.message + '</p>').css({
	                            'background': '#EEEEF0'
	                        });
	                    }
	                }
	            }).fail(function (e) {
	                console.error("网络连接失败，请重试", "error");
	            });
	        };

	        /**
	         *
	         *  调用登录接口请求
	         *
	         **/
	        function submitLogin() {
	            $('#yzm,#ipt').blur();
	            loadding(true);
	            var password = $('#ipt').val();
	            var RSAEncrypt = function RSAEncrypt(str) {
	                if (typeof RSAUtil == 'undefined') return str;
	                var exponent = "10001";
	                var key = RSAUtil.getKeyPair(exponent, '', encryptKey);
	                str = RSAUtil.encryptedString(key, str);
	                return str;
	            };
	            password = RSAEncrypt(password);
	            errCouts++;
	            var loginFuc = function loginFuc() {
	                var obj = {};

	                obj.param = param;
	                // obj.param='oWqSxv2QzAVD3cz8_hVT8FhqnhqE';//测试
	                obj.pw = password;
	                obj.stocks = stockArray.join(',');
	                $.ajax({
	                    type: 'post',
	                    url: 'http://wxtest.hx168.com.cn/hxkf/api/v1.0/ns/sub',
	                    data: obj,
	                    dataType: 'json',
	                    success: function success(results) {
	                        if (results.error == false) {
	                            loadding(false);
	                            var li = $('ul li');
	                            $('#ipt').val('');
	                            for (var i = 0, numLen = li.length; i < numLen; i++) {
	                                $(li[i]).text('');
	                            }
	                            window.location = 'success/success.html?param=' + param + '&khzzh=' + khzzh;
	                        } else if (results.error == true) {
	                            loadding(false);
	                            var pattern1 = /\(([1-9a-zA-Z\W]+)\)/;
	                            var pattern2 = /[\u2E80-\u9FFF]+/;
	                            stockArray = [];
	                            if (errCouts >= 3) {
	                                state = true;
	                                getTicketImg();
	                                $('#verify').show().css({
	                                    'width': '2.12rem',
	                                    'margin': 'auto'
	                                });
	                            }
	                            if (pattern1.exec(results.message)) {
	                                $('#errMsg').text('密码不匹配' + pattern1.exec(results.message)[0]).addClass('text-danger');
	                                return;
	                            } else if (pattern2.exec(results.message)) {
	                                $('#errMsg').text(pattern2.exec(results.message)[0]).addClass('text-danger');
	                                return;
	                            }
	                        }
	                    }
	                }).fail(function (e) {
	                    console.error("网络连接失败，请重试", "error");
	                });
	            };
	            loginFuc();
	        };

	        /**
	         *
	         * 验证码请求
	         *
	         **/
	        function getTicketImg() {
	            $.ajax({
	                type: 'get',
	                url: 'http://wxtest.hx168.com.cn/hxkf/api/v1.0/stream/randimg?randKey=19870627&width=96&height=32',
	                dataType: 'json',
	                success: function success(msg) {
	                    $('#tiketImg').attr("src", "data:image/png;base64," + msg.firstData.img);
	                    randCode = msg.results[0].randCode;
	                }
	            }).fail(function (e) {
	                console.error("网络连接失败，请重试", "error");
	            });
	        };
	        /**
	         *
	         *  登录回调
	         *
	         **/
	        function loginCallBack(results) {
	            if (results.error == false && results.rscode == "0") {
	                var login_results = results.results[0];
	                var loginname = login_results.khzzh;
	                $.setSessionStorage("loginname", '');
	                $.setSessionStorage("name", login_results.name);
	                $.setSessionStorage("clientrisklevel", login_results.clientrisklevel);
	                $.setSessionStorage("clientinfo", $.jsonToStr(login_results));
	            }
	        }

	        /**
	         *
	         * 检测密码输入
	         *
	         **/

	        $("body").delegate("#ipt", "input propertychange", function () {
	            var numLen = 6;
	            var pw = $('#ipt').val();
	            var list = $('li');
	            if (pw.length == '6') {
	                submit();
	            } else {
	                $('#errMsg').text('');
	            }
	            for (var i = 0; i < numLen; i++) {
	                if (pw[i]) {
	                    $(list[i]).text('•');
	                } else {
	                    $(list[i]).text('');
	                }
	            }
	        });

	        function submit() {

	            checkedValues();
	            if (state == true) {
	                $("body").delegate("#yzm", "input propertychange", function () {
	                    var pw = $('#yzm').val();
	                    $('#errMsg').text('');
	                    if (pw.length == '4' && pw == randCode) {
	                        loadding(true);
	                        submitLogin();
	                    } else if (pw.length == '4' && pw != randCode) {
	                        $('#errMsg').text('验证码错误').addClass('text-danger');
	                    }
	                });
	            } else {
	                submitLogin();
	            }
	        }

	        /**
	         *
	         * 验证创业板权限
	         *
	         **/
	        function checkRequest(khzzh) {
	            checkedValues();
	            var pattern = /^300+/;

	            // loadding(true);
	            var obj = {};
	            obj.custid = khzzh;
	            obj.khzh = khzzh;
	            obj.orgid = khzzh.substr(0, 4);
	            if (Permissions == false) {
	                $.ajax({
	                    type: 'POST',
	                    url: 'http://wxtest.hx168.com.cn/hxkf/api/v1.0/ns/gemauth',
	                    data: obj,
	                    dataType: 'json',
	                    success: function success(results) {
	                        if (results.message == "您暂未开通创业板!" && results.error == false) {
	                            Permissions = true;

	                            $('.box-mask').fadeOut(200);
	                            var li = $('ul li');
	                            $('#ipt').val('');
	                            for (var i = 0, numLen = li.length; i < numLen; i++) {
	                                $(li[i]).text('');
	                            }
	                            var stockInput = $("input[name=stock]");
	                            $.each(stockInput, function (index, value) {
	                                if (pattern.test($(this).val())) {
	                                    $(this).removeAttr('checked').attr('disabled', 'disabled');
	                                    $(this).parent().parent().append('<p class="text-center" style="color:#C7322F;font-size:.1rem;padding-bottom:.05rem;">您未开通创业板权限,请选择其他新股。</p>');
	                                }
	                            });
	                            loadding(false);
	                            stockArray = [];
	                        } else {
	                            loadding(false);
	                        }
	                    }
	                }).fail(function (e) {
	                    console.error("网络连接失败，请重试", "error");
	                });
	            } else {
	                var li = $('ul li');
	                $('#ipt').val('');
	                for (var i = 0, numLen = li.length; i < numLen; i++) {
	                    $(li[i]).text('');
	                }
	                loadding(false);
	                window.location = 'success/success.html?param=' + param + '&khzzh=' + khzzh;
	            }
	        }
	        /**
	         *
	         * 遮罩层
	         *
	         **/
	        function popMask(str) {
	            var html = '<div class="pop-mask">\
	                    <div class="pop-up text-center" style="border-radius:1rem;height:auto;">\
	                        <p class="pop-head">温馨提示</p>\
	                        <p class="pop-content">' + str + '</p>\
	                        <div class="understand">\
	                            <button id="understand" >我知道了</button>\
	                        </div>\
	                    </div>\
	                </div>';
	            $('body').append(html);
	            $('.pop-up').addClass('show');
	            $('.pop-mask').show();
	        }
	        /**
	         *
	         *   loadding
	         *
	         **/

	        function loadding(showFlag) {
	            if (showFlag) {
	                var html = '<div class="loadingBox">\
	                  <div class="loadContainer">\
	                    <div class="sk-circle">\
	                      <div class="sk-circle1 sk-child"></div>\
	                      <div class="sk-circle2 sk-child"></div>\
	                      <div class="sk-circle3 sk-child"></div>\
	                      <div class="sk-circle4 sk-child"></div>\
	                      <div class="sk-circle5 sk-child"></div>\
	                      <div class="sk-circle6 sk-child"></div>\
	                      <div class="sk-circle7 sk-child"></div>\
	                      <div class="sk-circle8 sk-child"></div>\
	                      <div class="sk-circle9 sk-child"></div>\
	                      <div class="sk-circle10 sk-child"></div>\
	                      <div class="sk-circle11 sk-child"></div>\
	                      <div class="sk-circle12 sk-child"></div>\
	                  </div>\
	                </div></div>';
	                $('body').append(html);
	                window.ontouchmove = stopDefaultAction;
	            } else {
	                window.ontouchmove = null;
	                $('.loadingBox').remove();
	            }
	        }

	        //    弹出提示框
	        $('#sub-btn').bind('click', function () {
	            // loadding(true);
	            $('#ipt').attr('autofocus', 'autofocus');
	            var stockLen = $("input[name=stock]").length;
	            if ($("input[name=stock]").is(':checked')) {
	                $('.box-mask').show();
	                $('.box').addClass('show');
	                var $body = $('body');
	                $body.css({
	                    'height': '100%',
	                    'width': '100%',
	                    'overflow': 'hidden',
	                    'position': 'fixed'
	                });
	                // break;
	            } else {
	                popMask('请选择你需要申购的新股');
	            }
	        });

	        $('#history-btn').bind('click', function () {
	            window.location = "history/history.html?param=" + param;
	        });
	        $('body').delegate('#understand', 'click', function () {
	            $('.pop-mask').fadeOut(100).remove();
	        });

	        $('.closedown').bind('click', function () {
	            $('#ipt').removeAttr('autofocus');
	            $('.box').removeClass('show').addClass('hide');
	            stockArray = [];
	            errCouts = 0;
	            // state=false;
	            $('.box-mask').fadeOut(200);
	            var $body = $('body');
	            $body.css({
	                'overflow': 'auto',
	                'position': 'static'
	            });
	            var li = $('ul li');
	            for (var i = 0, numLen = li.length; i < numLen; i++) {
	                $(li[i]).text('');
	            }
	            $('#ipt').val('');
	            $('#checkBtn').attr('disabled', 'disabled');
	            $('#errMsg').text('');
	            // 
	            // location.reload();
	        });

	        $('.box').delegate('#yzm', 'focus', function () {
	            $('#errMsg').text('');
	        });

	        // $('body').delegate('#checkBtn','click',function(){
	        //      $('#ipt').blur();
	        //         checkedValues();
	        //         if(state==true){
	        //                 if($('#yzm').val()==randCode){
	        //                      console.log('ok');
	        //                      submitLogin();
	        //                 }else if($('#yzm').val()!==randCode){
	        //                     $('#errMsg').text('验证码错误').addClass('text-danger'); 
	        //                 }
	        //         }else{
	        //             submitLogin();
	        //         }
	        // });

	        $('#retry').bind('click', function () {
	            $(this).parent().parent().parent().hide();
	            $('.box').show();
	            $('li').html('');
	            $('#ipt').val('');
	        });

	        $('#cancel').bind('click', function () {
	            $('.pop-mask').hide();
	        });

	        $('body').delegate('#tiketImg', 'click', function () {
	            getTicketImg();
	        });

	        $('#risk-info').bind('click', function () {
	            $('body').append('<div class="agreement-body" id="wrapper" style="-webkit-overflow-scrolling: touch;overflow:auto;"><div class="swiper-wrapper" id="slide"><div class="swiper-slide" ></div></div></div>');
	            $('.swiper-slide').load('xieyi.html');
	        });
	    },
	    initTouch: function initTouch() {
	        document.body.addEventListener('touchstart', function () {});
	        (function (doc, win) {
	            var docEl = doc.documentElement,
	                resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
	                recalc = function recalc() {
	                var clientWidth = docEl.clientWidth;
	                if (!clientWidth) return;
	                if (clientWidth >= 740) {
	                    clientWidth = 740;
	                    docEl.style.fontSize = 100 * (clientWidth / 320) - 10 + 'px';
	                }
	                if (clientWidth <= 320) {
	                    clientWidth = 320;
	                    docEl.style.fontSize = 100 * (clientWidth / 320) + 'px';
	                }
	            };
	            if (!doc.addEventListener) return;
	            win.addEventListener(resizeEvt, recalc, false);
	            doc.addEventListener('DOMContentLoaded', recalc, false);
	        })(document, window);
	    }
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', [_c('v-loading'), _vm._v(" "), _c('div', {
	    staticClass: "index container",
	    attrs: {
	      "id": "container"
	    }
	  }, [_c('v-header'), _vm._v(" "), _c('v-container'), _vm._v(" "), _c('v-footer')], 1)], 1)
	},staticRenderFns: []}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-177a52ff", module.exports)
	  }
	}

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* script */
	__vue_exports__ = __webpack_require__(35)

	/* template */
	var __vue_template__ = __webpack_require__(38)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\history\\index.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-3c200c90", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-3c200c90", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _Loading = __webpack_require__(24);

	var _Loading2 = _interopRequireDefault(_Loading);

	var _mutations = __webpack_require__(36);

	var _mutations2 = _interopRequireDefault(_mutations);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		data: function data() {
			return {
				his_icon: __webpack_require__(37)
			};
		},

		components: {
			VLoading: _Loading2.default
		},
		mounted: function mounted() {
			_mutations2.default.init();
		},

		methods: {}
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		init: function init() {
			var Time = {
				Year: '',
				Month: '',
				Date: '',
				Hours: '',
				Minutes: ''
			},
			    param = '';

			var counter = 0;
			// 每页展示7个
			var num = 7;
			var pageStart = 0,
			    pageEnd = 0;
			var nowTime = '';

			$('body').on('touchmove', function () {});

			Time.Year = new Date().getFullYear();
			Time.Month = new Date().getMonth() + 1;
			Time.Date = new Date().getDate();
			Time.Hours = new Date().getHours();
			if (Time.Hours < 10) {
				Time.Hours = '0' + Time.Hours;
			}
			Time.Minutes = new Date().getMinutes();
			if (Time.Minutes < 10) {
				Time.Minutes = '0' + Time.Minutes;
			}
			nowTime = Time.Year + '年' + Time.Month + '月' + Time.Date + '日  ' + Time.Hours + ':' + Time.Minutes;
			$('.history-time').html(nowTime);
			/*阻止默认行为*/
			function stopDefaultAction(e) {
				if (e && e.preventDefault) {
					e.preventDefault();
				} else {
					window.event.returnValue = false;
				}
			}
			window.onload = initPage();

			function initPage() {
				window.ontouchmove = stopDefaultAction;
				var $body = $('body');
				$body.css({
					'overflow': 'hidden'
					// 'position':'fixed'
				});
				var $Loading = $("#pageLoading");
				if ($Loading != null) {
					setTimeout(function () {
						$Loading.fadeOut('10');
						window.ontouchmove = null;
						$body.css({
							'overflow': 'auto',
							'position': 'static'
						});
					}, 1000);
				}
			};
			/**
	   *
	   * 遮罩层
	   *
	   **/
			function popMask(str) {
				var html = '<div class="pop-mask">\
	                    <div class="pop-up text-center" style="border-radius:1rem;height:auto;">\
	                        <p class="pop-head">温馨提示</p>\
	                        <p class="pop-content">' + str + '</p>\
	                        <div class="understand">\
	                            <button id="understand">我知道了</button>\
	                        </div>\
	                    </div>\
	                </div>';
				$('body').append(html);
				$('#understand').on('click', function () {
					$('.pop-mask').hide();
					$('.dropload-down').hide();
				});
				$('.pop-up').addClass('show');
				$('.pop-mask').show();
			}

			/**
	   *
	   * 截取openid
	   *
	   **/
			function getQueryStringRegExp(name) {
				var reg = new RegExp("(^|\\?|&)" + name + "=([^&]*)(\\s|&|$)", "i");

				if (reg.test(location.href)) {
					param = unescape(RegExp.$2.replace(/\+/g, " "));
				}
			};
			getQueryStringRegExp('param');

			// dropload
			$('#main').dropload({
				scrollArea: window,
				domDown: {
					domClass: 'dropload-down',
					domRefresh: '<div class="dropload-refresh">↑上拉加载更多！</div>',
					domLoad: '<div class="loading"><span></span>加载中...</div>',
					domNoData: '<div class="noData">没有更多内容了！</div>'
				},
				loadDownFn: function loadDownFn(me) {
					var obj = {};
					obj.param = param;
					obj.pageIndex = 1;
					obj.pageSize = 1000;
					$.ajax({
						type: 'POST',
						url: 'http://wxtest.hx168.com.cn/hxkf/api/v1.0/ns/orderhisquery',
						data: obj,
						dataType: 'json',
						success: function success(data) {
							if (data.results.length > 0) {
								var result = '';
								counter++;
								pageEnd = num * counter;
								pageStart = pageEnd - num;
								for (var i = pageStart; i < pageEnd; i++) {
									var timeStr = data.results[i].subdate.slice(5, 7) + "月" + data.results[i].subdate.slice(8, 10) + "日";
									result += '<div class="row history-item-content"><div class="col-xs-4"><span>' + data.results[i].stkname + '</span><br><span>' + data.results[i].stkcode + '</span></div><div class="col-xs-4 prize v-middle">' + data.results[i].orderprice + '</div><div class="col-xs-4"><span class="date v-middle">' + timeStr + '</span><br></div></div>';
									if (i + 1 >= data.results.length) {
										// 锁定
										me.lock();
										// 无数据
										me.noData();
										break;
									}
								}
								// 为了测试，延迟1秒加载
								setTimeout(function () {
									$('.history-item').append(result);
									// 每次数据加载完，必须重置
									me.resetload();
								}, 2000);
							} else {
								setTimeout(function () {
									popMask('没有申购内容');
								}, 2000);
							}
						},
						error: function error(xhr, type) {
							me.resetload();
						}
					});
				},
				threshold: 50
			});
			$('#understand').bind('click', function () {
				$('.pop-mask').remove();
			});
		}
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAZlBMVEUAAADFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDTFNDQAAAB1jQ6fAAAAIHRSTlMAAT6JxOj5igJi2yHKQOtGRyfy8wNjP8PCy8woSdyLxZ5AedMAAAABYktHRACIBR1IAAAACXBIWXMAAAsSAAALEgHS3X78AAAAuklEQVQoz33TWRaDIAwF0AiCinSwONWR/a+yUCuCkr4/zj2EKQD8khCaMs5ZmpEEwuSF0C6iyH0rpQ4iy8Nud33Knez24PoS/tyseulIVGWtljoaWRss3NAMfG3M+QSGIoFWY6hboDhS6HDsgeHIgOPI/2NY9pujbIdjDxmO1L+Ec1r/+k4Rph8aDBv7ZO+4DfbJYFQxU+O2uynWJtO+9+kyVzkzlYfTemPY1PNBc9jUlsmy2u+wLsTRB7ELRSBZM+kOAAAAAElFTkSuQmCC"

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', [_c('v-loading'), _vm._v(" "), _c('div', {
	    staticClass: "container",
	    attrs: {
	      "id": "container"
	    }
	  }, [_vm._m(0), _vm._v(" "), _c('div', {
	    staticClass: "main history-main-content",
	    attrs: {
	      "id": "main"
	    }
	  }, [_c('div', {
	    staticClass: "history-content",
	    attrs: {
	      "id": "history-time"
	    }
	  }, [_c('img', {
	    attrs: {
	      "src": _vm.his_icon
	    }
	  }), _vm._v(" "), _c('span', {
	    staticClass: "history-time"
	  })]), _vm._v(" "), _vm._m(1), _vm._v(" "), _c('div', {
	    staticClass: "history-item",
	    attrs: {
	      "id": "history-item"
	    }
	  })])])], 1)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('header', {
	    staticClass: "header history-head",
	    attrs: {
	      "id": "header"
	    }
	  }, [_c('div', [_c('b', {
	    staticClass: "logo"
	  }), _vm._v(" "), _c('b', {
	    staticClass: "department"
	  }, [_vm._v("北京营业部")])])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "row history-list"
	  }, [_c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("\n\t\t\t\t\t\t名称/代码\n\t\t\t\t\t")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("\n\t\t\t\t\t\t发行价格(元)\n\t\t\t\t\t")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("\n\t\t\t\t\t\t申购日期\n\t\t\t\t\t")])])
	}]}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-3c200c90", module.exports)
	  }
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* script */
	__vue_exports__ = __webpack_require__(40)

	/* template */
	var __vue_template__ = __webpack_require__(44)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\success\\index.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-3bedad82", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-3bedad82", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _Loading = __webpack_require__(24);

	var _Loading2 = _interopRequireDefault(_Loading);

	var _Footer = __webpack_require__(41);

	var _Footer2 = _interopRequireDefault(_Footer);

	var _mutations = __webpack_require__(43);

	var _mutations2 = _interopRequireDefault(_mutations);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		data: function data() {
			return {
				suc_icon: __webpack_require__(37)
			};
		},

		components: {
			VLoading: _Loading2.default,
			VFooter: _Footer2.default
		},
		mounted: function mounted() {
			_mutations2.default.init();
		},

		methods: {}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* template */
	var __vue_template__ = __webpack_require__(42)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\success\\Footer.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-00b1d29e", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-00b1d29e", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] Footer.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _vm._m(0)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('footer', {
	    staticClass: "success-footer"
	  }, [_c('button', {
	    staticClass: "back-home",
	    attrs: {
	      "id": "back-home"
	    }
	  }, [_vm._v("返回首页")])])
	}]}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-00b1d29e", module.exports)
	  }
	}

/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		init: function init() {
			var nowTime = '',
			    param = '',
			    khzzh = '';
			/**
	   *
	   * 时间对象
	   *
	   */
			var Time = {
				Year: '',
				Month: '',
				Date: '',
				Hours: '',
				Minutes: ''
			};

			Time.Year = new Date().getFullYear();
			Time.Month = new Date().getMonth() + 1;
			Time.Date = new Date().getDate();
			Time.Hours = new Date().getHours();
			if (Time.Hours < 10) {
				Time.Hours = '0' + Time.Hours;
			}
			Time.Minutes = new Date().getMinutes();
			if (Time.Minutes < 10) {
				Time.Minutes = '0' + Time.Minutes;
			}
			nowTime = Time.Year + '年' + Time.Month + '月' + Time.Date + '日  ' + Time.Hours + ':' + Time.Minutes;
			$('.time').html(nowTime);
			/*阻止默认行为*/
			function stopDefaultAction(e) {
				if (e && e.preventDefault) {
					e.preventDefault();
				} else {
					window.event.returnValue = false;
				}
			}

			window.onload = initPage();

			function initPage() {
				window.ontouchmove = stopDefaultAction;
				var $body = $('body');
				$body.css({
					'overflow': 'hidden'
					// 'position':'fixed'
				});
				var $Loading = $("#pageLoading");
				if ($Loading != null) {
					setTimeout(function () {
						$Loading.fadeOut('10');
						window.ontouchmove = null;
						$body.css({
							'overflow': 'auto',
							'position': 'static'
						});
					}, 1000);
					setTimeout(function () {
						$('#suceess-img').addClass('suceess-img');
					}, 1020);
				}
			};
			/**
	   *
	   * 自定义滚动条
	   *
	   **/
			$('#success-list-body').niceScroll({
				cursorcolor: "#C7322F", //#CC0071 光标颜色
				cursoropacitymax: 1, //改变不透明度非常光标处于活动状态（scrollabar“可见”状态），范围从1到0
				touchbehavior: false, //使光标拖动滚动像在台式电脑触摸设备
				cursorwidth: "3px", //像素光标的宽度
				cursorborder: "0", //     游标边框css定义
				cursorborderradius: "5px", //以像素为光标边界半径
				autohidemode: false, //是否隐藏滚动条
				scrollspeed: 60,
				mousescrollstep: 1,
				nativeparentscrolling: true
			});

			/**
	   *
	   * 截取openid
	   *
	   **/
			function getQueryStringRegExp(name, type) {
				var reg = new RegExp("(^|\\?|&)" + name + "=([^&]*)(\\s|&|$)", "i");
				if (reg.test(location.href)) {
					if (type == param) {
						param = unescape(RegExp.$2.replace(/\+/g, " "));
						return param;
					} else if (type == khzzh) {
						khzzh = unescape(RegExp.$2.replace(/\+/g, " "));
						return khzzh;
					}
				}
			};
			getQueryStringRegExp('param', param);
			getQueryStringRegExp('khzzh', khzzh);
			/**
	   *
	   *   请求参数设置
	   *
	   **/
			(function () {
				$.ajaxSetup({
					timeout: 30000,
					dataType: "json",
					cache: false
				});
			})();

			function loginFuc() {
				var obj = {};
				var html = '';
				obj.pageIndex = 1;
				obj.pageSize = 1000;
				obj.param = param;
				$.ajax({
					type: 'POST',
					url: 'http://wxtest.hx168.com.cn/hxkf/api/v1.0/ns/orderquery',
					data: obj,
					dataType: 'json',
					success: function success(results) {
						var lists = results.results;
						console.log(lists.length);
						$('#khzzh').text(khzzh);
						if (results.error == false && lists.length != 0) {
							$.each(lists, function (index, value) {
								var timeStr = lists[index].subdate.slice(5, 7) + "月" + lists[index].subdate.slice(8, 10) + "日";
								html += '<div class="row success-items">\
	                                        <div class="col-xs-4">\
	                                            <span>' + lists[index].stkname + '</span><br><span>' + lists[index].stkcode + '</span>\
	                                        </div>\
	                                        <div class="col-xs-4 v-middle prize">\
	                                            <span>' + lists[index].orderprice + '</span>\
	                                        </div>\
	                                        <div class="col-xs-4 v-middle">\
	                                            <span>' + timeStr + '</span>\
	                                        </div>\
	                                    </div>';
							});
							$('#success-list-body').append(html);
						} else {
							$('.main').append('<p style="text-align:center;font-size:.15rem;background:#EEEEF0;">' + results.message + '</p>');
						}
					}

				}).fail(function (e) {
					console.error("网络连接失败，请重试", "error");
				});
			};
			loginFuc();
			$('#back-home').bind('click', function () {
				window.history.go(-1);
			});
		}
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', [_c('v-loading'), _vm._v(" "), _c('div', {
	    staticClass: "container",
	    attrs: {
	      "id": "container"
	    }
	  }, [_vm._m(0), _vm._v(" "), _c('div', {
	    staticClass: "main"
	  }, [_c('div', {
	    staticClass: "success"
	  }, [_c('img', {
	    attrs: {
	      "id": "suceess-img",
	      "src": _vm.suc_icon
	    }
	  }), _vm._v("\n\t\t\t\t\t恭喜你，提交成功！\n\t\t\t\t")]), _vm._v(" "), _vm._m(1), _vm._v(" "), _c('div', {
	    staticClass: "success-list-body",
	    attrs: {
	      "id": "success-list-body"
	    }
	  })]), _vm._v(" "), _c('v-footer')], 1)], 1)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('header', {
	    staticClass: "header",
	    attrs: {
	      "id": "header"
	    }
	  }, [_c('div', [_c('b', {
	    staticClass: "logo"
	  }), _vm._v(" "), _c('b', {
	    staticClass: "department"
	  }, [_vm._v("北京营业部")])]), _vm._v(" "), _c('div', {
	    staticClass: "time"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "zjzh"
	  }, [_vm._v("\n\t\t\t\t\t资金账号："), _c('span', {
	    attrs: {
	      "id": "khzzh"
	    }
	  })])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "row success-list"
	  }, [_c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("\n\t\t\t\t\t\t名称/代码\n\t\t\t\t\t")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("\n\t\t\t\t\t\t发行价格(元)\n\t\t\t\t\t")]), _vm._v(" "), _c('div', {
	    staticClass: "col-xs-4"
	  }, [_vm._v("\n\t\t\t\t\t\t申购日期\n\t\t\t\t\t")])])
	}]}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-3bedad82", module.exports)
	  }
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* script */
	__vue_exports__ = __webpack_require__(46)

	/* template */
	var __vue_template__ = __webpack_require__(48)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "C:\\Users\\hp\\Desktop\\nxgsg\\src\\components\\risk\\index.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-02cfc622", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-02cfc622", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _mutations = __webpack_require__(47);

	var _mutations2 = _interopRequireDefault(_mutations);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		mounted: function mounted() {
			_mutations2.default.init();
		}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    init: function init() {
	        document.body.addEventListener('touchstart', function () {});
	        (function (doc, win) {
	            var docEl = doc.documentElement,
	                resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
	                recalc = function recalc() {
	                var clientWidth = docEl.clientWidth;
	                if (!clientWidth) return;
	                if (clientWidth >= 740) {
	                    clientWidth = 740;
	                    docEl.style.fontSize = 100 * (clientWidth / 320) - 10 + 'px';
	                }
	                if (clientWidth <= 320) {
	                    clientWidth = 320;
	                    docEl.style.fontSize = 100 * (clientWidth / 320) + 'px';
	                }
	            };
	            if (!doc.addEventListener) return;
	            win.addEventListener(resizeEvt, recalc, false);
	            doc.addEventListener('DOMContentLoaded', recalc, false);
	        })(document, window);
	    }
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "risk container",
	    attrs: {
	      "id": "container"
	    }
	  }, [_c('h4', {
	    staticStyle: {
	      "font-size": ".16rem",
	      "font-weight": "900"
	    }
	  }, [_vm._v("“新股赢”咨询服务产品风险揭示书")]), _vm._v(" "), _c('p', {
	    staticClass: "first"
	  }, [_vm._v("尊敬的客户： ")]), _vm._v(" "), _c('p', [_vm._v("本营业部提供的研究报告等任何咨询资讯信息只提供给客户做参考之用，并不构成对客户的投资建议，并非作为买卖、认购证券或其它金融工具的邀请或保证。本营业部所提供的上市公司公告、个股资料、投资咨询建议等任何信息，力求但不担保其内容的准确性和完整性。客户不应单纯依靠研究报告等咨询资讯信息而取代个人的独立判断，应对信息予以核实，独立做出投资决策，风险自负。")]), _vm._v(" "), _c('p', [_vm._v("本营业部不担保提供的任何信息资料都适合于每一位客户。本营业部建议客户如有任何疑问应当咨询独立财务顾问和服务人员并独自进行投资判断。研究报告等任何咨询资讯信息并不构成投资、法律、会计或税务建议或担保任何内容适合客户，也不构成给予客户个人咨询建议。")]), _vm._v(" "), _c('p', [_vm._v("本营业部提供的信息资料可能附带其它网站的地址或超级链接，对于可能涉及的华西证券网站以外的地址或超级链接，本营业部不对其内容负责。提供这些地址或超级链接的目的纯粹是为了客户使用方便，链接网站的内容不构成信息资料的任何部分，客户需自行承担浏览这些网站的费用和风险。")]), _vm._v(" "), _c('p', [_vm._v("本营业部不因接收人收到本营业部提供的任何信息资料而视其为客户。本营业部提供的信息资料是发送给本营业部客户的，属于机密材料，只有华西证券北京紫竹院路营业部客户才能参考或使用，如接收人并非本营业部客户，请及时退回并删除。信息资料接收人不得将信息资料转发或允许其他人员使用。")]), _vm._v(" "), _c('p', [_vm._v("研究报告等任何咨询资讯信息所载内容反映的是相关机构在最初发表该研究报告或其他信息资料日期当日的判断，相关机构可发出其它与该研究报告或其他信息资料所载内容不一致或有不同结论的研究报告或其他信息资料，但本营业部没有义务和责任去及时更新研究报告或其他信息资料涉及的内容并通知客户。本营业部不对因客户使用该研究报告或其他信息资料而导致的损失负任何责任。")]), _vm._v(" "), _c('p', [_vm._v("关于本营业部自己发布的研究报告。本营业部在法律允许的情况下可参与、投资或持有本营业部发布的研究报告中涉及的证券或进行证券交易，或向该报告涉及的公司提供或争取提供包括投资银行业务在内的服务或业务支持。本营业部可能与该报告涉及的公司之间存在业务关系，并无需事先或在获得业务关系后通知客户。在任何情况下，本营业部不对任何人因使用上述资料中的任何内容所引致的任何损失负任何责任。")]), _vm._v(" "), _c('p', [_vm._v("本产品为遵照《证券发行与承销管理办法》（2013年12月13日，证监会令第95号）下的协助投资者申购新股的咨询服务产品。本服务产品是提示相关新股申购、中签缴款、上市等信息，投资者每次根据提示确认申购意愿，系统在新股申购日，根据投资者确认的新股申购意愿进行新股申购申报。请您在签署前认真阅读以下风险提示：")]), _vm._v(" "), _c('p', [_vm._v("1、本服务产品风险等级为高风险，请投资者根据自身风险承受能力审慎选择是否定制本产品。")]), _vm._v(" "), _c('p', [_vm._v("2、投资者签约或退订本产品（T日）后，T+1个工作日服务生效或取消。签约本产品的投资者自服务生效日起至服务取消之日止申购的股票，在中签后卖出时佣金按照千分之三标准收取。")]), _vm._v(" "), _c('p', [_vm._v("3、新股申购信息以交易所于新股申购当日公告为准，不排除新股发行日期变更、发行价格变更或交易所临时取消或增加新股发行的情形。如发生新股发行日期变更、发行价格变更的情形，投资者提交的原申购意愿有效，系统将在该只股票最终发行日期按照最终发行价格提交新股申购的申报，无需投资者重新提交新股申购的意愿。")]), _vm._v(" "), _c('p', [_vm._v("4、投资者确认申购意愿后，下一个工作日起委托生效。新股申购当日，系统根据投资者账户中显示的申购额度及每股申购上限两者的较低值为投资者进行新股申购的申报。")]), _vm._v(" "), _c('p', [_vm._v("5、投资者新股申购额度按照《深圳市场首次公开发行股票网上发行实施细则》、《上海市场首次公开发行股票网上发行实施细则》市值计算规则计算。投资者的同一证券账户多处托管的，其市值合并计算；投资者持有多个证券账户的，多个证券账户的市值合并计算；融资融券客户信用证券账户的市值合并计算到该投资者持有的市值中。本服务产品仅通过我公司普通账户进行新股申购的申报，如果因投资者在我公司普通账户内的深圳证券账户无市值而导致的新股申购失败，我公司不承担任何责任。")]), _vm._v(" "), _c('p', [_vm._v("6、新股申购申报时间根据中签数据统计结果确定，系统选择最优时间申报。")]), _vm._v(" "), _c('p', [_vm._v("7、系统统一为投资者进行自动申报，不排除漏申报的情况。")]), _vm._v(" "), _c('p', [_vm._v("8、因地震、台风、水灾、火灾、战争、瘟疫、社会动乱及其他不可抗力因素导致新股申购失败，我公司不承担任何责任。")]), _vm._v(" "), _c('p', [_vm._v("9、新股申购按照沪深交易所新股申购规则申报，不保证签约投资者申购新股中签，也不保证投资者中签后股票的本金及收益。")]), _vm._v(" "), _c('p', [_vm._v("10、新股申购后，请投资者及时关注中签情况，如中签，投资者须保证缴款日普通资金账户内预留足够资金认购缴款，我公司不会垫付缴款资金。投资者新股中签未足额缴款导致违约或放弃认购权造成的一切损失由投资者自行承担，我公司不承担任何责任。")]), _vm._v(" "), _c('p', [_vm._v("11、新股中签后，我公司将提供通知服务，通知方式为微信、电话或短信中的一种或几种方式，请投资者注意查看微信、短信及接听电话。通知电话号码以系统登记为准，如投资者电话变更请及时更新。")]), _vm._v(" "), _c('p', [_vm._v("12、如在本产品签约服务期间内，《证券发行与承销管理办法》发生变更的，本服务自动终止。")]), _vm._v(" "), _c('p', [_vm._v("股市有风险，入市需谨慎！")]), _vm._v(" "), _c('p', [_vm._v("以上《风险提示书》本人已阅读并完全理解，愿意承担证券市场的各种风险。")]), _vm._v(" "), _c('router-link', {
	    attrs: {
	      "to": "/home"
	    }
	  }, [_c('button', {
	    staticClass: "sub-btn riskBtn",
	    attrs: {
	      "id": "checkBtn"
	    }
	  }, [_vm._v("确  认")])])], 1)
	},staticRenderFns: []}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-02cfc622", module.exports)
	  }
	}

/***/ }
/******/ ]);